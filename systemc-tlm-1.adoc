:source-highlighter: coderay

:toc: left

SystemC中的TLM 1.0 组件
[[chap::tlm_1_0]]

=== 引言

SystemC的TLM分为1.0版和2.0版本，虽然1.0版本的TLM已经不推荐使用，但在一些legacy的Code
（例如我们和UVM做仿真的TLM接口定义中）仍然存在。所以本部分我们主要介绍TLM 1.0版本的内容。
理解TLM 1.0部分的设计思路，也能更好帮助我们去探索TLM 2.0的设计选择。

TLM 1.0时代的建模，主要基于REQUEST和RESPONSE的思想。即，发起端发出REQUEST请求，接收端返回一个RESPONSE
应答。 TLM 1.0主要分为以下几个部分：

* interface部分
* channel部分，主要是tlm_fifo
* port部分
* adaptor部分
* analysis部分

=== TLM 1.0 Interfaces

tlm 1.0的Interfaces部分主要有如下几类：

* core interfaces
  - tlm_transport_if
  - tlm_blocking_get_if
  - tlm_blocking_put_if
  - tlm_blocking_peek_if
  - tlm_nonblocking_get_if
  - tlm_nonblocking_put_if
  - tlm_nonblocking_peek_if
* fifo interfaces
* master slave interfaceo

其中，所有的core部分的interface定义的层次关系如下图所示：

.tlm 1中的interfaces层次关系
image::tlm_1_interfaces.png[]

图中淡绿色部分为直接继承自sc_interface的基础interfaces类，这些基础类中的红色字体表示定义的接口函数名称。
注意tlm_transport_if游离在主要的继承体系之外。tlm_transport_if的作用主要是提供一种简单的req-rsp机制，对于简单的建模来说这就足够了。如果需要较为
复杂的建模方式，就需要区分读和写（put/get/peek）了。

==== core interfaces 

core interfaces的内容之前已经罗列了。首先是tlm_transport_if，定义如下：
[[tlm::1::tlm_transport_if]]

.src/tlm_core/tlm_1/tlm_req_resp/tlm_1_interfaces/tlm_core_ifs.h
[source,cpp]
----
// bidirectional blocking interfaces

template < typename REQ , typename RSP >
class tlm_transport_if : public virtual sc_core::sc_interface
{
public:
  virtual RSP transport( const REQ & ) = 0;

  virtual void transport( const REQ &req , RSP &rsp ) {
    rsp = transport( req );
  }

};
----

从代码可以看出， `tlm_transport_if` 是一个阻塞式的interface，接口函数transport需要接受请求数据REQ，然后
返回应答请求的数据RSP。REQ和RSP可以有不同的数据类型，所以`tlm_transport_if` 的模板需要接受两个类型参数。

tlm_transport_if是双端口的interface，不仅可以发起请求，还可以接受返回的应答数据。除此之外，TLM 1中还定义了一系列
的单端口的interface，我们在之后将一一介绍。

首先是 tlm_blocking_get_if：
[[tlm::1::tlm_blocking_get_if]]

.src/tlm_core/tlm_1/tlm_req_resp/tlm_1_interfaces/tlm_core_ifs.h
[source,cpp]
----
template < typename T >
class tlm_blocking_get_if : public virtual sc_core::sc_interface
{
public:
  virtual T get( tlm_tag<T> *t = 0 ) = 0;
  virtual void get( T &t ) { t = get(); }

};
----

定义的接口函数接受一个 `tlm_tag<T>` 类型的指针（默认值为空指针），返回类型T的数据.

除了get之外，还可以put，即 tlm_blocking_put_if:
[[tlm::1::tlm_blocking_put_if]]

.src/tlm_core/tlm_1/tlm_req_resp/tlm_1_interfaces/tlm_core_ifs.h
[source,cpp]
----
template < typename T >
class tlm_blocking_put_if : public virtual sc_core::sc_interface
{
public:
  virtual void put( const T &t ) = 0;
};
----

这里的接口函数就是传入一个`const T&`即可。

值得注意的是，TLM 1中还定义了一个peek的操作：
[[tlm::1::tlm_blocking_peek_if]]

.src/tlm_core/tlm_1/tlm_req_resp/tlm_1_interfaces/tlm_core_ifs.h
[source,cpp]
----
template < typename T >
class tlm_blocking_peek_if : public virtual sc_core::sc_interface
{
public:
  virtual T peek( tlm_tag<T> *t = 0 ) const = 0;
  virtual void peek( T &t ) const { t = peek(); }

};
----

tlm_blocking_peek_if的实现和 <<tlm::1::tlm_blocking_get_if, tlm_blocking_get_if>>
基本一样，除了接口函数的名称从get变成peek之外，其他没有区别。


TIP: get和peek的区别在于，get操作需要获取一个元素，当
数据被get盗之后，数据就等于消费掉了。而peek是一种retrieve操作，或者query操作，是查询元素。peek一个元素，并不会
消费掉这个元素。被peek的元素，必须在未来被get之后，才能消费掉。除此之外，get元素只能按照时间顺序get到put进去的元素，而
peek一个元素可以乱序查询。

上述的get/peek和put都是阻塞版本，其对应的非阻塞版本的interface则是：

tlm_nonblocking_get_if的定义是：
[[tlm::1::tlm_nonblocking_get_if]]

.src/tlm_core/tlm_1/tlm_req_resp/tlm_1_interfaces/tlm_core_ifs.h
[source,cpp]
----
template < typename T >
class tlm_nonblocking_get_if : public virtual sc_core::sc_interface
{
public:
  virtual bool nb_get( T &t ) = 0;
  virtual bool nb_can_get( tlm_tag<T> *t = 0 ) const = 0;
  virtual const sc_core::sc_event &ok_to_get( tlm_tag<T> *t = 0 ) const = 0;
};
----

其中定义了3个接口函数，分别是：

* nb_get，非阻塞地尝试获取类型T的数据
* nb_can_get，非阻塞地返回是否可以有数据可供get
* ok_to_get，返回事件的引用，标志有数据可供get的事件发生

tlm_nonblocking_put_if的定义则是:
[[tlm::1::tlm_nonblocking_put_if]]

.src/tlm_core/tlm_1/tlm_req_resp/tlm_1_interfaces/tlm_core_ifs.h
[source,cpp]
----
template < typename T >
class tlm_nonblocking_put_if : public virtual sc_core::sc_interface
{
public:
  virtual bool nb_put( const T &t ) = 0;
  virtual bool nb_can_put( tlm_tag<T> *t = 0 ) const = 0;
  virtual const sc_core::sc_event &ok_to_put( tlm_tag<T> *t = 0 ) const = 0;
};
----

其定义的3个接口函数分别是：

* nb_put，非阻塞地尝试put数据
* nb_can_put，非阻塞地返回是否可以put数据
* ok_to_put，返回一个事件引用，标志有空间可put的事件发生

tlm_nonblocking_peek_if的定义则是：
[[tlm::1::tlm_nonblocking_peek_if]]

.src/tlm_core/tlm_1/tlm_req_resp/tlm_1_interfaces/tlm_core_ifs.h
[source,cpp]
----
template < typename T >
class tlm_nonblocking_peek_if : public virtual sc_core::sc_interface
{
public:
  virtual bool nb_peek( T &t ) const = 0;
  virtual bool nb_can_peek( tlm_tag<T> *t = 0 ) const = 0;
  virtual const sc_core::sc_event &ok_to_peek( tlm_tag<T> *t = 0 ) const = 0;
};
----

这里定义的接口函数基本和get/put一样，就不再赘述了。

[[tlm::1::tlm_get_if]]
此外，还有三个组合起来的interface, tlm_get_if, tlm_put_if和tlm_peek_if:
[[tlm::1::tlm_put_if]]

.src/tlm_core/tlm_1/tlm_req_resp/tlm_1_interfaces/tlm_core_ifs.h
[source,cpp]
----
template < typename T >
class tlm_get_if :
  public virtual tlm_blocking_get_if< T > ,
  public virtual tlm_nonblocking_get_if< T > {};

template < typename T >
class tlm_put_if :
  public virtual tlm_blocking_put_if< T > ,
  public virtual tlm_nonblocking_put_if< T > {};

template < typename T >
class tlm_peek_if :
  public virtual tlm_blocking_peek_if< T > ,
  public virtual tlm_nonblocking_peek_if< T > {};
----

[[tlm::1::tlm_peek_if]]
这3个interface，都是对应的阻塞和非阻塞interface组合在一起。

[[tlm::1::tlm_blocking_get_peek_if]]
除此之外，还有get和peek组合起来的interface, tlm_blocking_get_peek_if, tlm_nonblocking_get_peek_if
[[tlm::1::tlm_nonblocking_get_peek_if]]
和tlm_get_peek_if:
[[tlm::1::tlm_get_peek_if]]


.src/tlm_core/tlm_1/tlm_req_resp/tlm_1_interfaces/tlm_core_ifs.h
[source,cpp]
----
template < typename T >
class tlm_blocking_get_peek_if :
  public virtual tlm_blocking_get_if<T> ,
  public virtual tlm_blocking_peek_if<T> {};

template < typename T >
class tlm_nonblocking_get_peek_if :
  public virtual tlm_nonblocking_get_if<T> ,
  public virtual tlm_nonblocking_peek_if<T> {};


template < typename T >
class tlm_get_peek_if :
  public virtual tlm_get_if<T> ,
  public virtual tlm_peek_if<T> ,
  public virtual tlm_blocking_get_peek_if<T> ,
  public virtual tlm_nonblocking_get_peek_if<T>
  {};
----

==== fifo interfaces

tlm中的fifo interfaces，主要为TLM FIFO提供interface能力的描述。

首先，是一个tlm_fifo_debug_if:
[[tlm::1::tlm_fifo_debug_if]]

.src/tlm_core/tlm_1/tlm_req_resp/tlm_1_interfaces/tlm_fifo_ifs.h
[source,cpp]
----
template< typename T >
class tlm_fifo_debug_if : public virtual sc_core::sc_interface
{
public:
  virtual int used() const = 0;
  virtual int size() const = 0;
  virtual void debug() const = 0;

  //
  // non blocking peek and poke - no notification
  //
  // n is index of data :
  // 0 <= n < size(), where 0 is most recently written, and size() - 1
  // is oldest ie the one about to be read.
  //

  virtual bool nb_peek( T & , int n ) const = 0;
  virtual bool nb_poke( const T & , int n = 0 ) = 0;

};
----

tlm_fifo_debug_if是一个用来辅助debug的interface，定义的接口函数有：

* used/size/debug，这三个都是FIFO的size操作和打印debug信息
* nb_peek
* nb_poke

[[tlm::1::tlm_fifo_put_if]]
在tlm_fifo_debug_if的基础上，扩充出来了两个interface：和
<<tlm::1::tlm_put_if, tlm_put_if>>组合得到的tlm_put_if，
以及和<<tlm::1::tlm_get_peek_if, tlm_get_peek_if>>组合
得到的tlm_fifo_get_if:
[[tlm::1::tlm_fifo_get_if]]

.src/tlm_core/tlm_1/tlm_req_resp/tlm_1_interfaces/tlm_fifo_ifs.h
[source,cpp]
----
template < typename T >
class tlm_fifo_put_if :
  public virtual tlm_put_if<T> ,
  public virtual tlm_fifo_debug_if<T> {};

template < typename T >
class tlm_fifo_get_if :
  public virtual tlm_get_peek_if<T> ,
  public virtual tlm_fifo_debug_if<T>
{
  using tlm_get_peek_if<T>::nb_peek;
  using tlm_fifo_debug_if<T>::nb_peek;
};
----

fifo的interface中，还有一个非模板类的interface, tlm_fifo_config_size_if
[[tlm::1::tlm_fifo_config_size_if]]

.src/tlm_core/tlm_1/tlm_req_resp/tlm_1_interfaces/tlm_fifo_ifs.h
[source,cpp]
----
class tlm_fifo_config_size_if : public virtual sc_core::sc_interface
{
public:
  virtual void nb_expand( unsigned int n = 1 ) = 0;
  virtual void nb_unbound( unsigned int n = 16 ) = 0;

  virtual bool nb_reduce( unsigned int n = 1 ) = 0;
  virtual bool nb_bound( unsigned int n ) = 0;

};
----

==== master-slave interfaces

master-slave的interface定义结合了之前的interface部分。master-slave部分需要两个模板参数，分别
标识请求数据点类型和应答数据的类型。

首先是一个阻塞的master接口，tlm_blocking_master_if，组合了blocking的put请求，以及blocking的
get/peek应答：
[[tlm::1::tlm_blocking_master_if]]

.src/tlm_core/tlm_1/tlm_req_resp/tlm_1_interfaces/tlm_master_slave_ifs.h
[source,cpp]
----
template < typename REQ , typename RSP>
class tlm_blocking_master_if :
  public virtual tlm_blocking_put_if< REQ > ,
  public virtual tlm_blocking_get_peek_if< RSP > {};
----

那么，与之相对应的，阻塞的master接口，tlm_blocking_slave_if，组合了blocking的get/peek请求，以及
blocking地put应答：
[[tlm::1::tlm_blocking_slave_if]]

.src/tlm_core/tlm_1/tlm_req_resp/tlm_1_interfaces/tlm_master_slave_ifs.h
[source,cpp]
----
template < typename REQ , typename RSP>
class tlm_blocking_slave_if :
  public virtual tlm_blocking_put_if< RSP > ,
  public virtual tlm_blocking_get_peek_if< REQ > {};
----

这是符合逻辑的。对于master而言，发起（put）请求，获取（get/peek）应答。而对于slave而言，则是
获取（get/peek）请求，响应（put）应答。

[[tlm::1::tlm_nonblocking_master_if]]
对应的非阻塞版本则是：
[[tlm::1::tlm_nonblocking_slave_if]]

.src/tlm_core/tlm_1/tlm_req_resp/tlm_1_interfaces/tlm_master_slave_ifs.h
[source,cpp]
----
// nonblocking

template < typename REQ , typename RSP >
class tlm_nonblocking_master_if :
  public virtual tlm_nonblocking_put_if< REQ > ,
  public virtual tlm_nonblocking_get_peek_if< RSP > {};

template < typename REQ , typename RSP >
class tlm_nonblocking_slave_if :
  public virtual tlm_nonblocking_put_if< RSP > ,
  public virtual tlm_nonblocking_get_peek_if< REQ > {};
----

[[tlm::1::tlm_master_if]]
以及组合了阻塞和非阻塞的总的tlm_master_if和tlm_slave_if:
[[tlm::1::tlm_slave_if]]

.src/tlm_core/tlm_1/tlm_req_resp/tlm_1_interfaces/tlm_master_slave_ifs.h
[source,cpp]
----
template < typename REQ , typename RSP >
class tlm_master_if :
  public virtual tlm_put_if< REQ > ,
  public virtual tlm_get_peek_if< RSP > ,
  public virtual tlm_blocking_master_if< REQ , RSP > ,
  public virtual tlm_nonblocking_master_if< REQ , RSP > {};

template < typename REQ , typename RSP >
class tlm_slave_if :
  public virtual tlm_put_if< RSP > ,
  public virtual tlm_get_peek_if< REQ > ,
  public virtual tlm_blocking_slave_if< REQ , RSP > ,
  public virtual tlm_nonblocking_slave_if< REQ , RSP > {};
----

=== TLM 1.0 Channels

TLM 1.0定义了几种channel，包括tlm_fifo，request-response channel等。

==== tlm fifo
[[tlm::1::tlm_fifo]]

((tlm_fifo))是TLM 1.0中最为重要的channel之一。tlm_fifo重新实现了fifo功能，而不是直接继承自sc_fifo：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_fifo/tlm_fifo.h
[source,cpp]
----
template <typename T>
class tlm_fifo :
  public virtual tlm_fifo_get_if<T>,
  public virtual tlm_fifo_put_if<T>,
  public sc_core::sc_prim_channel
{
    // blabla
protected:

    circular_buffer<T> buffer; <1>

    int m_size;                  // logical size of fifo <2>

    int m_num_readable;          // #samples readable <2>
    int m_num_read;          // #samples read during this delta cycle <2>
    int m_num_written;           // #samples written during this delta cycle <2>
    bool m_expand;               // has an expand occurred during this delta cycle ? <3>
    int m_num_read_no_notify;    // #samples read without notify during this delta cycle <4>

    sc_core::sc_event m_data_read_event; <2>
    sc_core::sc_event m_data_written_event; <2>

    // blabla
};
----
<1> 和sc_fifo使用一个raw buffer不同，tlm_fifo使用一个circular buffer
<2> 和sc_fifo一样，tlm_fifo同样使用这4个计数器，以及两个事件作为FIFO的信息建模
<3> tlm_fifo支持动态扩充大小
<4> 从名字来看，这个含义是如果读的数目不超过这个变量设定的值，则无需notify，但实际上，现在的SC中的这个值固定是0，也就是只要有read发生，就notify

tlm_fifo首先是一个sc_prim_channel，tlm_fifo的建模和<<data::sc_fifo, sc_core::sc_fifo>>基本一样，这从
相应的成员函数中就可以看出来。与sc_fifo略有不同的是，tlm_fifo使用了一个circular buffer来作为保存数据的部分，而不是
想sc_fifo一眼个，使用一个raw buffer加上读写指针来穆尼circular buffer。此外，tlm_fifo支持在运行时调整size，这
是sc_fifo不具备的能力。作为一个primitive channel，最重要的两点就是何时调用 
<<api::sc_prim_channel::request_update, `request_update`>> ，以及如何实现 
<<api::sc_prim_channel::update, `update`>>
接口函数。我们首先看一下tlm_fifo的update接口函数的实现：
[[tlm::1::tlm_fifo::update]]

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_fifo/tlm_fifo.h
[source,cpp]
----
template < typename T>
inline
void
tlm_fifo<T>::update()
{
    if( m_num_read > m_num_read_no_notify || m_expand ) { <1>
  m_data_read_event.notify( sc_core::SC_ZERO_TIME );
    }

    if( m_num_written > 0 ) { <2>
  m_data_written_event.notify( sc_core::SC_ZERO_TIME );
    }

    m_expand = false;
    m_num_read = 0;
    m_num_written = 0;
    m_num_readable = buffer.used();
    m_num_read_no_notify = 0;

}
----
<1> 如果读的数目超过设定的限制（实际上是0），或者tlm_fifo的size变大，那么就将触发读事件，这实际上相当于fifo有额外的空间释放
<2> 如果有写入的数据，那么就触发写事件，这相当于fifo有数据可以读取

从tlm_fifo的update可以看出，除了在读事件的判断上增加了一个 `m_expand` 以外，和
<<data::sc_fifo, sc_core::sc_fifo>>的
<<api::sc_fifo::update, update>>函数基本是一样的。


除了作为一个primitive channel，tlm_fifo同时继承了<<tlm::1::tlm_fifo_get_if, tlm_fifo_get_if>>
和<<tlm::1::tlm_fifo_put_if, tlm_fifo_put_if>>两个接口，这意味着tlm_fifo需要实现众多的接口函数定义，包括
这些直接继承自sc_interface的基础类的接口函数：

* tlm_fifo_debug_if
* tlm_blocking_get_if
* tlm_blocking_put_if
* tlm_blocking_peek_if
* tlm_nonblocking_get_if
* tlm_nonblocking_put_if
* tlm_nonblocking_peek_if

在实现这些接口函数的时候，tlm_fifo可以调用request_update，实现自己作为一个primitive channel的功能。

===== tlm_fifo_debug_if implementation

首先看下tlm_fifo是如何实现<<tlm::1::tlm_fifo_debug_if, tlm_fifo_debug_if>>的接口函数的。

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_fifo/tlm_fifo.h
[source,cpp]
----
    int used() const {
      return m_num_readable - m_num_read; <1>
    }

    int size() const {
      return m_size;
    }

    void debug() const {

      if( is_empty() ) std::cout << "empty" << std::endl;
      if( is_full() ) std::cout << "full" << std::endl;

      std::cout << "size " << size() << " - " << used() << " used "
                << std::endl;
      std::cout << "readable " << m_num_readable
                << std::endl;
      std::cout << "written/read " << m_num_written << "/" << m_num_read
                << std::endl;

    }
----
<1> fifo中已经使用的数量，等于原本的数量减去已经读出去的数量

used, size和debug的实现相对比较简单。而nb_peek和nb_poke的实现则相对复杂一些，从nb_peek和nb_poke的实现，我们
也能够理解get和peek的区别了：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_fifo/tlm_fifo_peek.h
[source,cpp]
----
template < typename T>
inline
bool
tlm_fifo<T>::nb_peek( T &t , int n ) const {

  if( n >= used() || n < -1 ) {
    return false;
  }

  if( n == -1 ) {
    n = used() - 1;
  }

  t = buffer.peek_data( n );
  return true;

}

template < typename T>
inline
bool
tlm_fifo<T>::nb_poke( const T &t , int n ) {

  if( n >= used() || n < 0 ) {
    return false;
  }

  buffer.poke_data( n ) = t;
  return true;

}
----

从这里我们可以看出，peek的操作相比于get，更类似于一种索引（而不是弹出FIFO）的操作。对于nb_peek，如果给定的
索引值超出索引范围，或者小于-1，那么就无法peek。如果设定为-1，那么peek的就是可用的数据中最后一个。poke操作
泽合peak相反，相当于为一个位置设定值。如果位置等于size，则相当于append。（这一点待确认）

===== tlm_blocking_get_if implementation

<<tlm::1::tlm_blocking_get_if, tlm_blocking_get_if>>所需要实现的接口函数只有一个阻塞的get方法：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_fifo/tlm_fifo_put_get.h
[source,cpp]
----
template <typename T>
inline
T
tlm_fifo<T>::get( tlm_tag<T> * )
{

  while( is_empty() ) {
    wait( m_data_written_event );
  }

  m_num_read ++;
  request_update(); <1>

  return buffer.read();

}
----
<1> 因为读取了数据，所以这里需要调用<<api::sc_prim_channel::request_update, request_update>>，将自己放入primitive channel的待更新列表中

这个get的实现还是比较简单的，基本和sc_fifo的read操作一样。

===== tlm_nonblocking_get_if implementation

<<tlm::1::tlm_nonblocking_get_if, tlm_nonblocking_get_if>>所需要实现的接口函数需要nb_get, nb_can_get和ok_to_get三个接口函数。

其中ok_to_get这个函数最简单，需要返回一个事件，表明可以get，那么只需要返回写事件即可：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_fifo/tlm_fifo.h
[source,cpp]
----
    const sc_core::sc_event &ok_to_get( tlm_tag<T> * = 0 ) const {
      return m_data_written_event;
    }
----

而nb_get和nb_can_get函数的实现则相对不难：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_fifo/tlm_fifo_put_get.h
[source,cpp]
----
// non-blocking read

template <typename T>
inline
bool
tlm_fifo<T>::nb_get( T& val_ )
{

  if( is_empty() ) {
    return false;
  }

  m_num_read ++;
  request_update();

  val_ = buffer.read();

  return true;

}

template <typename T>
inline
bool
tlm_fifo<T>::nb_can_get( tlm_tag<T> * ) const {

  return !is_empty();

}
----

基本上这两个函数的实现和sc_fifo的nb_read和num_available差不多。

===== tlm_blocking_put_if implementation

<<tlm::1::tlm_blocking_put_if, tlm_blocking_put_if>>的接口函数只有一个put：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_fifo/tlm_fifo_put_get.h
[source,cpp]
----
template <typename T>
inline
void
tlm_fifo<T>::put( const T& val_ )
{
    while( is_full() ) {
  wait( m_data_read_event );
    }

    if( buffer.is_full() ) {

      buffer.resize( buffer.size() * 2 );

    }

    m_num_written ++;
    buffer.write( val_ );

    request_update();
}
----

put的实现基本和sc_fifo的write方法一样。

===== tlm_nonblocking_put_if implementation

<<tlm::1::tlm_nonblocking_put_if, tlm_nonblocking_put_if>>的接口函数有nb_put, nb_can_put和ok_to_put。
其中ok_to_put的实现最为简单，只需要将读事件返回即可：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_fifo/tlm_fifo.h
[source,cpp]
----
    const sc_core::sc_event& ok_to_put( tlm_tag<T> * = 0 ) const {
      return m_data_read_event;
    }
----

而nb_put和nb_can_put的实现则是：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_fifo/tlm_fifo_put_get.h
[source,cpp]
----
template <typename T>
inline
bool
tlm_fifo<T>::nb_put( const T& val_ )
{

  if( is_full() ) {
    return false;
  }

  if( buffer.is_full() ) {

    buffer.resize( buffer.size() * 2 );

  }

  m_num_written ++;
  buffer.write( val_ );
  request_update();

  return true;
}

template < typename T >
inline
bool
tlm_fifo<T>::nb_can_put( tlm_tag<T> * ) const {

  return !is_full();

}
----

基本上这两个函数的实现和sc_fifo的nb_write和num_free差不多。

===== tlm_blocking_peek_if implementation

<<tlm::1::tlm_blocking_peek_if, tlm_blocking_peek_if>>的接口函数只有peek一个：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_fifo/tlm_fifo_peek.h
[source,cpp]
----
template < typename T>
inline
T
tlm_fifo<T>::peek( tlm_tag<T> * ) const {

  while( is_empty() ) {

    // call free-standing sc_core::wait(),
    // since sc_prim_channel::wait(.) is not const

    sc_core::wait( m_data_written_event );
  }

  return buffer.read_data();

}
----

注意，阻塞的peek等到有数据可以peek后，调用的是buffer的read_data，这和阻塞的get不一样，get调用的是read。read_data
只读取数据，并不移动读指针。而read则调用read_data之后，移动读指针。所以这里peek调用read_data之后，数据仍然存在fifo内。
这也是为何peek是一个const函数的原因了。

===== tlm_nonblocking_peek_if implementation

<<tlm::1::tlm_nonblocking_peek_if, tlm_nonblocking_peek_if>>的接口函数有nb_peek, nb_can_peek和ok_to_peek三个。

ok_to_peek的实现简单，和ok_to_get的方法一样，返回写事件即可：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_fifo/tlm_fifo.h
[source,cpp]
----
    const sc_core::sc_event &ok_to_peek( tlm_tag<T> * = 0 ) const {
      return m_data_written_event;
    }
----

而nb_peek和nb_can_peek的实现则是：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_fifo/tlm_fifo_peek.h
[source,cpp]
----
template < typename T>
inline
bool
tlm_fifo<T>::nb_peek( T &t , int n ) const {

  if( n >= used() || n < -1 ) {
    return false;
  }

  if( n == -1 ) {
    n = used() - 1;
  }

  t = buffer.peek_data( n );
  return true;

}

template< typename T >
inline
bool
tlm_fifo<T>::nb_can_peek( tlm_tag<T> * ) const
{
  return !is_empty();
}
----

这两个函数的实现相对还是比较简单的。注意nb_can_peek的入参实际上是没有使用到的。

===== tlm fifo resize

tlm_fifo并没有直接或者间接继承自<<tlm::1::tlm_fifo_config_size_if, tlm_fifo_config_size_if>>，但却实现了同样的接口函数。
这是否是TLM 1.0中遗漏的一个bug？tlm_fifo应该直接继承自tlm_fifo_config_size_if的。

tlm_fifo_config_size_if的接口函数有nb_expand, nb_unbound, nb_reduce和nb_bound，注意这些接口函数的前缀nb表明这些调用
都是non-blocking的。对于tlm_fifo，实现了同名的函数如下所示：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_fifo/tlm_fifo_resize.h
[source,cpp]
----
template < typename T>
inline
void
tlm_fifo<T>::nb_expand( unsigned int n ) {

  if( m_size >= 0 ) {
    m_expand = true;
    m_size += n;
    request_update();
  }
}

template < typename T>
inline
void
tlm_fifo<T>::nb_unbound( unsigned int n ) {

  m_expand = true;
  m_size = -n;

  if( buffer.size() < static_cast<int>( n ) ) {
    buffer.resize( n );
  }

  request_update();

}

template < typename T>
inline
bool
tlm_fifo<T>::nb_reduce( unsigned int n ) {

  if( m_size < 0 ) {
    return false;
  }

  return nb_bound( size() - n );

}

template < typename T>
inline
bool
tlm_fifo<T>::nb_bound( unsigned int new_size ) {

  bool ret = true;

  if( static_cast<int>( new_size ) < used() ) {

    new_size = used();
    ret = false;

  }

  m_size = new_size;
  return ret;

}
----

==== tlm_put_get_imp
[[tlm::1::tlm_put_get_imp]]

tlm_put_get_imp是实现tlm req-rsp channel的基础。tlm_put_get_imp直接继承自
<<tlm::1::tlm_put_if, tlm_put_if>>
和<<tlm::1::tlm_get_peek_if, tlm_get_peek_if>>，不过与继承了相同基类的
<<tlm::1::tlm_fifo, tlm_fifo>>相比，tlm_put_get_imp实际上有 两个模板参数，所以
put和get/peek的数据类型是不同的：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_req_rsp_channels/tlm_put_get_imp.h
[source,cpp]
----
template < typename PUT_DATA , typename GET_DATA>
class tlm_put_get_imp :
  public virtual tlm_put_if< PUT_DATA > , <1>
  public virtual tlm_get_peek_if< GET_DATA > <2>
{
public:
  tlm_put_get_imp( tlm_put_if<PUT_DATA> &p ,
       tlm_get_peek_if<GET_DATA> &g ) :
    put_fifo( p ) , get_fifo( g ) {}
    // blabla
private:
  tlm_put_if<PUT_DATA> &put_fifo; <3> 
  tlm_get_peek_if<GET_DATA> &get_fifo; <3>
};
----
<1> tlm_put_get_imp继承自tlm_put_if，put的数据类型是模板参数PUT_DATA
<2> tlm_put_get_imp继承自tlm_get_peek_if，get/peek的数据类型是模板参数GET_DATA
<3> tlm_put_get_imp实际上内部保存了两个interface的引用

tlm_put_get_imp实现相应的接口函数的功能，实际上都是直接调用了成员变量 `put_fifo`
和 `get_fifo` 的相应功能。

==== tlm_master_imp and tlm_slave_imp
[[tlm::1::tlm_master_imp]]

在<<tlm::1::tlm_put_get_imp, tlm_put_get_imp>>的基础上，TLM 1.0实现了tlm_master_imp和
tlm_slave_imp。实际上，tlm_master_imp和tlm_slave_imp只不过是特化了的tlm_put_get_imp而已。
tlm_master_imp是put REQ，get/peek RSP，而tlm_slave_imp则相反，是get/peek REQ，put RSP：
[[tlm::1::tlm_slave_imp]]

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_req_rsp_channels/tlm_put_get_imp.h
[source,cpp]
----
template < typename REQ , typename RSP >
class tlm_master_imp :
  private tlm_put_get_imp< REQ , RSP > , <1>
  public virtual tlm_master_if< REQ , RSP > <2>
{
public:

  tlm_master_imp( tlm_put_if<REQ> &req ,
                  tlm_get_peek_if<RSP> &rsp ) :
    tlm_put_get_imp<REQ,RSP>( req , rsp ) {}

};

template < typename REQ , typename RSP >
class tlm_slave_imp :
  private tlm_put_get_imp< RSP , REQ > , <1>
  public virtual tlm_slave_if< REQ , RSP > <3>
{
public:

  tlm_slave_imp( tlm_get_peek_if<REQ> &req ,
                 tlm_put_if<RSP> &rsp ) :
    tlm_put_get_imp<RSP,REQ>( rsp  , req ) {}

};
----
<1> tlm_master_imp和tlm_slave_imp的模板参数方向不同
<2> tlm_master_imp同时继承自tlm_master_if
<3> tlm_slave_imp同时继承自tlm_slave_if

tlm_master_imp继承自tlm_master_if，对应的接口函数实现在tlm_put_get_imp中实际已经实现了，tlm_slave_imp同理。

==== tlm_req_rsp_channel
[[tlm::1::tlm_req_rsp_channel]]

tlm_req_rsp_channel虽然名字里带一个channel，但实际上并不是一个primitive channel，而是直接继承自sc_module。其实现
主要是一个双向的channel，主要有四个私有类型的成员变量，分别是：

* 传输REQ的通道request_fifo，默认是tlm_fifo<REQ>类型
* 船速RSP的通道response_fifo，默认是tlm_fifo<RSP>类型
* <<tlm::1::tlm_master_imp, tlm_master_imp>>类成员变量master
* <<tlm::1::tlm_slave_imp, tlm_slave_imp>>类型成员变量slave

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_req_rsp_channels/tlm_req_rsp_channels.h
[source,cpp]
----
template < typename REQ , typename RSP ,
     typename REQ_CHANNEL = tlm_fifo<REQ> ,
     typename RSP_CHANNEL = tlm_fifo<RSP> >

class tlm_req_rsp_channel : public sc_core::sc_module
{
public:
  // uni-directional slave interface

  sc_core::sc_export< tlm_fifo_get_if< REQ > > get_request_export;
  sc_core::sc_export< tlm_fifo_put_if< RSP > > put_response_export;

  // uni-directional master interface

  sc_core::sc_export< tlm_fifo_put_if< REQ > > put_request_export;
  sc_core::sc_export< tlm_fifo_get_if< RSP > > get_response_export;

  // master / slave interfaces

  sc_core::sc_export< tlm_master_if< REQ , RSP > > master_export;
  sc_core::sc_export< tlm_slave_if< REQ , RSP > > slave_export;

  // blabla

protected:
  REQ_CHANNEL request_fifo;
  RSP_CHANNEL response_fifo;

  tlm_master_imp< REQ , RSP > master;
  tlm_slave_imp< REQ , RSP > slave;
};
----

在构造函数中，master和slave绑定了相应的FIFO：


.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_req_rsp_channels/tlm_req_rsp_channels.h
[source,cpp]
----
  tlm_req_rsp_channel( int req_size = 1 , int rsp_size = 1 ) :
    sc_core::sc_module( sc_core::sc_module_name( sc_core::sc_gen_unique_name("tlm_req_rsp_channel") ) ) ,
    request_fifo( req_size ) ,
    response_fifo( rsp_size ) ,
    master( request_fifo , response_fifo ) ,
    slave( request_fifo , response_fifo )
  {

    bind_exports();

  }

  tlm_req_rsp_channel( sc_core::sc_module_name module_name ,
           int req_size = 1 , int rsp_size = 1 ) :
    sc_core::sc_module( module_name  ) ,
    request_fifo( req_size ) ,
    response_fifo( rsp_size ) ,
    master( request_fifo , response_fifo ) ,
    slave( request_fifo , response_fifo )
  {

    bind_exports();

  }
----

除了这4个私有类型的成员变量外，tlm_req_rsp_channel还有其他几个公共的export类型的成员变量，分别是:

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_req_rsp_channels/tlm_req_rsp_channels.h
[source,cpp]
----
  sc_core::sc_export< tlm_fifo_get_if< REQ > > get_request_export;
  sc_core::sc_export< tlm_fifo_put_if< RSP > > put_response_export;

  // uni-directional master interface

  sc_core::sc_export< tlm_fifo_put_if< REQ > > put_request_export;
  sc_core::sc_export< tlm_fifo_get_if< RSP > > get_response_export;

  // master / slave interfaces

  sc_core::sc_export< tlm_master_if< REQ , RSP > > master_export;
  sc_core::sc_export< tlm_slave_if< REQ , RSP > > slave_export;

----

* 暴露了 <<tlm::1::tlm_fifo_get_if, tlm_fifo_get_if>>的get_request_export
* 暴露了 <<tlm::1::tlm_fifo_put_if, tlm_fifo_put_if>>的put_response_export
* 暴露了 <<tlm::1::tlm_fifo_put_if, tlm_fifo_put_if>>的put_reqeuest_export
* 暴露了 <<tlm::1::tlm_fifo_get_if, tlm_fifo_get_if>>的get_response_export
* 暴露了 <<tlm::1::tlm_master_if, tlm_master_if>>的master_export
* 暴露了 <<tlm::1::tlm_slave_if, tlm_slave_if>>的slave_export

这六个export的绑定情况如下：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_req_rsp_channels/tlm_req_rsp_channels.h
[source,cpp]
----
private:
  void bind_exports() {

    put_request_export( request_fifo );
    get_request_export( request_fifo );

    put_response_export( response_fifo );
    get_response_export( response_fifo );

    master_export( master );
    slave_export( slave );

  }
----

* put_request_export和get_request_export绑定到request_fifo上
* put_response_export和get_response_export绑定到response_fifo上
* master_export绑定到master上
* slave_export绑定到slave上

tlm_req_rsp_channel的实现核心在于，内部维护了两个FIFO，分别用来传送REQ和传送RESP。同时，tlm_req_rsp_channel
还为双端口访问各暴露出了两对共4个export，可以让绑定到这个channel两侧的使用方法局限于一端只能发送request，获取response，另一端
则只能响应(get)request，返回response. 如果需要使用组合起来的访问方式，则前者可以用master_export代替，而后者则可以用slave_export代替。
因为master_export绑定到了master上，而master则同时实现了put REQ, get/peek RSP的功能。同理，slave_export
绑定到slave上，slave同时实现了get/peek REQ, put RSP的功能。

put_request_export和get_response_export两个组合，与master相比，主要区别在于，前两者分别是tlm_fifo_put_if和tlm_fifo_get_if，而
master则内部包含了两个tlm_put_if和tlm_get_peek_if。虽然tlm_fifo_put_if直接继承自tlm_put_if，tlm_fifo_get_if直接继承自tlm_get_peek_if，但
tlm_fifo_put_if和tlm_fifo_get_if相比而言，增加了<<tlm::1::tlm_fifo_debug_if, tlm_fifo_debug_if>>的能力。换言之，如果使用master
接口的话，那就无法访问underly实现中，FIFO相关的debug能力了。

get_request_export和put_response_export两个组合，与slave相比，有着同样的情况。

tlm_req_rsp_channel是一个拥有双FIFO的数据结构，并且暴露出来了合适的接口，方便其他的port/export进行绑定，来调用内部
两个FIFO对应的能力。双FIFO，一个用来传输request，另一个则用来传输response。

==== tlm_transport_channel
[[tlm::1::tlm_transport_channel]]

tlm_transport_channel，是一个sc_module，用来将一个<<tlm::1::tlm_req_rsp_channel, tlm_req_rsp_channel>>
转成一个transport chnanel:

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_req_rsp_channels/tlm_req_rsp_channels.h
[source,cpp]
----
template < typename REQ , typename RSP ,
     typename REQ_CHANNEL = tlm_fifo<REQ> ,
     typename RSP_CHANNEL = tlm_fifo<RSP> >
class tlm_transport_channel : public sc_core::sc_module
{
public:

  // master transport interface

  sc_core::sc_export< tlm_transport_if< REQ , RSP > > target_export;

  // slave interfaces

  sc_core::sc_export< tlm_fifo_get_if< REQ > > get_request_export;
  sc_core::sc_export< tlm_fifo_put_if< RSP > > put_response_export;

  sc_core::sc_export< tlm_slave_if< REQ , RSP > > slave_export;

private:
  tlm_req_rsp_channel< REQ , RSP , REQ_CHANNEL , RSP_CHANNEL > req_rsp;
  tlm_transport_to_master< REQ , RSP > t2m;

};
----

tlm_transport_channel的公共成员变量包括，一个export，模板类型为tlm_transport_if，一对
export，模板参数分别为tlm_fifo_get_if和tlm_fifo_put_if，一个export，模板参数为
<<tlm::1::tlm_slave_if, tlm_slave_if>>。 而私有成员变量则包括一个
<<tlm::1::tlm_req_rsp_channel, tlm_req_rsp_channel>>实例，以及一个
<<tlm::1::tlm_transport_to_master, tlm_transport_to_master>>.

tlm_transport_channel的构造函数比较简单，除了例行初始化必要的成员变量之外，最为重要的就是调用一个
do_binding的函数：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_req_rsp_channels/tlm_req_rsp_channels.h
[source,cpp]
----
  tlm_transport_channel() :
    sc_core::sc_module( sc_core::sc_module_name( sc_core::sc_gen_unique_name("transport_channel" ) ) ) ,
    target_export("target_export") ,
    req_rsp( "req_rsp" , 1 , 1 ) ,
    t2m("ts2m")
  {
    do_binding();
  }

  tlm_transport_channel( sc_core::sc_module_name nm ) :
    sc_core::sc_module( nm ) ,
    target_export("target_export") ,
    req_rsp( "req_rsp" , 1 , 1 ) ,
    t2m("tsm" )
  {
    do_binding();
  }
----

注意，其中的req_rsp channel默认初始化的fifo深度都是1.

do_binding函数的实现如下：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_req_rsp_channels/tlm_req_rsp_channels.h
[source,cpp]
----
private:
  void do_binding() {

    target_export( t2m.target_export );

    t2m.master_port( req_rsp.master_export );

    get_request_export( req_rsp.get_request_export );
    put_response_export( req_rsp.put_response_export );
    slave_export( req_rsp.slave_export );

  }
----

模板类型为<<tlm::1::tlm_transport_if, tlm_transport_if>>的export类型的成员变量target_export被绑定到了
<<tlm::1::tlm_transport_to_master, tlm_transport_to_master>>的成员变量target_export上，注意，这是一个export
到export的绑定，所以实际上绑定的结果是tlm_transport_to_master的成员变量target_export先转成一个interface类型，再被
tlm_transport_channel的target_export所绑定。

接下来，tlm_transport_to_master的master_port绑定了这里req_rsp的master_export。get_request_export和put_response_export
分贝绑定了req_rsp的对应接口，这两个都是export到export的绑定。

最后，slave_export绑定到了req_rsp channnel的slave_export上，这同样是一个export到export的绑定。

tlm_transport_channel实现的结果是，暴露出一个<<tlm::1::tlm_transport_if, tlm_transport_if>>类型的export，可以被别的对象绑定。当
别的对象绑定了tlm_transport_if模板类型的export target_export之后，就可以调用tlm_transport_if的接口函数transport，将数据送到
内部req_rsp channel的request fifo中，并且最终从req_rsp channel的response fifo返回一个response数据。与此同时，tlm_transport_channel
还暴露出了一对为slave准备的接口，get_request_export和put_response_export，用来帮助下游的slave部分接受request，返回response。如果下游希望
使用一个单一的接口，那么同样可以使用tlm_slave_if类型的slave_export。

tlm_transport_channel实现的目的在于，将数据从一个实现了tlm_transport_if的接口，转到实现get/put协议的接口上去。实现了get/put协议
的接口，实际上已经是一个channel了。channel与接口的区别在于，channel可以实例化之后直接使用，而纯的接口必须绑定到channel上才可以使用。
这种关系类似port和export的绑定，无论怎么绑定，最终都需要绑定到一个fifo上（假设用fifo实现了相关的功能）上。这样一来，tlm_transport_if
最终绑定到了两个tlm_fifo（模板默认参数，可以配置为其他实现了相同接口的数据结构）上。

tlm_transport_channel并没有对称性的相反的实现。从实现了get/put协议的接口，转到tlm_transport_if的接口，只需要使用
<<tlm::1::tlm_slave_to_transport, tlm_slave_to_transport>>即可。从这方面来说，tlm_transport_channel
与随后要介绍的<<tlm::1::tlm_slave_to_transport>>才是一对。

=== TLM 1.0 Adapter

TLM 1.0中设计了两个adapter，分别是tlm_transport_to_master，以及tlm_slave_to_transport。所谓的adapter，指的是需要在
不同的协议之间做桥接。对于TLM 1.0，interface协议的类型分为两种，一种是一个API就完成所有事情的类型，只有一个
<<tlm::1::tlm_transport_if, tlm_transport_if>>。另一种，则是将put/get分开实现的interface类型，包括
之前介绍的除了<<tlm::1::tlm_transport_if, tlm_transport_if>>之外的其他的interface类型。而adapter则需要在这两种
不同设计思想的类型之间做转换。

==== tlm_transport_to_master
[[tlm::1::tlm_transport_to_master]]

tlm_transport_to_master是一个sc_module，同时继承自
<<tlm::1::tlm_transport_if, tlm_transport_if>>，实现了transport方法：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_adapters/tlm_adapters.h
[source,cpp]
----
template< typename REQ , typename RSP >
class tlm_transport_to_master :
  public sc_core::sc_module ,
  public virtual tlm_transport_if< REQ , RSP >
{
public:
  sc_core::sc_export< tlm_transport_if< REQ , RSP > > target_export;
  sc_core::sc_port< tlm_master_if< REQ , RSP > > master_port;

private:
  sc_core::sc_mutex mutex;
  RSP rsp;
};
----

tlm_transport_to_master拥有两个公共的成员变量，一个export类型的target_export，类型参数为
<<tlm::1::tlm_transport_if, tlm_transport_if>>，另一个则是port类型的成员变量master_port，类型参数
为<<tlm::1::tlm_master_if, tlm_master_if>>。tlm_transport_to_master的作用是，使用master_port
的能力，实现target_export的能力（即实现transport函数的能力）。

target_export被绑定到tlm_transport_to_master自己身上：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_adapters/tlm_adapters.h
[source,cpp]
----
  tlm_transport_to_master( sc_core::sc_module_name nm ) :
    sc_core::sc_module( nm ) {

    target_export( *this );

  }

  tlm_transport_to_master() :
    sc_core::sc_module( sc_core::sc_module_name( sc_core::sc_gen_unique_name( "transport_to_master" ) ) ){

    target_export( *this );

  }
----

同时，作为一个tlm_transport_if，tlm_transport_to_master也需要实现 `transport` 接口函数：


.src/tlm_core/tlm_1/tlm_req_resp/tlm_adapters/tlm_adapters.h
[source,cpp]
----
  RSP transport( const REQ &req ) {

    mutex.lock();

    master_port->put( req );
    rsp = master_port->get();

    mutex.unlock();
    return rsp;

  }
----

tranport的实现还是相对比较简单的：将transport的参数put到master_port中，然后从master_port get返回的
response，并作为transport接口函数的返回值返回。额外的一个 `mutex` 的作用是保证多线程场景下的访问安全。

tlm_transport_to_master，从名字来看，这是讲数据从transport接口实现，转到master接口实现。因为tlm_transport_to_master
本身就继承自<<tlm::1::tlm_transport_if, tlm_transport_if>>，所以一个tlm_transport_to_master可以直接作为一个
tlm_transport_if来使用。同时，内部的公共成员变量master_port可以被绑定到实现了<<tlm::1::tlm_master_if, tlm_master_if>>
的对象上。这样一来，当调用tlm_transport_if的接口函数transport之后，数据就可以被送到实现了tlm_master_if的对象上了。注意，
tlm_transport_if的transport是一个阻塞的函数，而tlm_master_if的接口函数虽然也是阻塞函数，但分成了两个实现。这种阻塞函数
到阻塞函数的实现相对还是比较简单的。

==== tlm_slave_to_transport
[[tlm::1::tlm_slave_to_transport]]

与<<tlm::1::tlm_transport_to_master, tlm_transport_to_master>>不同，
tlm_slave_to_transport只是一个sc_module而已：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_adapters/tlm_adapters.h
[source,cpp]
----
template< typename REQ , typename RSP >
class tlm_slave_to_transport : public sc_core::sc_module
{
public:

  SC_HAS_PROCESS( tlm_slave_to_transport );

  sc_core::sc_port< tlm_slave_if< REQ , RSP > > slave_port;
  sc_core::sc_port< tlm_transport_if< REQ , RSP > > initiator_port;
//blabla
};
----

tlm_slave_to_transport需要实现的功能和<<tlm::1::tlm_transport_to_master, tlm_transport_to_master>>
相反。tlm_slave_to_transport是需要将数据从<<tlm::1::tlm_slave_if, tlm_slave_if>>类型的port slave_port
中获取，然后将数据送到 <<tlm::1::tlm_transport_if, tlm_transport_if>>中。为此，tlm_slave_to_transport
设计了一个线程函数run：


.src/tlm_core/tlm_1/tlm_req_resp/tlm_adapters/tlm_adapters.h
[source,cpp]
----
private:
  void run() {

    REQ req;
    RSP rsp;

    while( true ) {

     slave_port->get( req );
     rsp = initiator_port->transport( req );
     slave_port->put( rsp );

    }

  }
----

run的实现还是比较简单的，直接从slave_port中get到request，然后送到transport中后，将transport返回的response数据通过
slave_port的put接口返回回去。这潜在地暗示一件事情，slave_port中，request和response是一一配对的，不存在发了request
不需要response，或者发了request返回多笔response的场景。

奇怪的是，虽然tlm_slave_to_transport设计了线程函数run来完成从slave接口到transport接口的转换，但是
tlm_slave_to_transport的构造函数并没有将这个线程函数run列为自己的线程函数：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_adapters/tlm_adapters.h
[source,cpp]
----
  tlm_slave_to_transport( sc_core::sc_module_name nm ) : sc_core::sc_module( nm )
  {}

  tlm_slave_to_transport() :
    sc_core::sc_module( sc_core::sc_module_name( sc_core::sc_gen_unique_name("slave_to_transport") ) )
  {}
----

=== TLM 1.0 Ports

TLM 1.0的Ports部分主要为三种interface, 
<<tlm::1::tlm_nonblocking_get_if, tlm_nonblocking_get_if>>, 
<<tlm::1::tlm_nonblocking_put_if, tlm_nonblocking_put_if>>以及
<<tlm::1::tlm_nonblocking_peek_if, tlm_nonblocking_peek_if>>所对应的port
做了特殊处理，以应对这些port作为sensitive设置时的应用场景。

==== tlm_event_finder_t
[[tlm::1::tlm_event_finder_t]]

tlm_event_finder_t继承自<<data::sc_event_finder, sc_core::sc_event_finder>>，其主要目的是为了支持TLM 1.0
中的port作为sensitive源的时候，延迟event本身的返回，直到仿真开始之前：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_ports/tlm_event_finder.h
[source,cpp]
----
template <class IF , class T>
class tlm_event_finder_t
  : public sc_core::sc_event_finder
{
public:
    // constructor

    tlm_event_finder_t( const sc_core::sc_port_base& port_,
                        const sc_core::sc_event& (IF::*event_method_) ( tlm_tag<T> * ) const )
        : sc_core::sc_event_finder( port_ ), m_event_method( event_method_ )
        {}
private:

    const sc_core::sc_event& (IF::*m_event_method) ( tlm_tag<T> * ) const; <1>
};
----
<1> 成员函数指针是唯一一个成员变量

作为一个sc_event_finder的子类，tlm_event_finder_t的初始化需要两个变量，一个是<<data::sc_port_base, sc_core::sc_port_base>>，
另一个则是一个IF的成员函数函数指针，这个函数指针接受一个 `tlm_tag<T>*` 座位入参，返回一个sc_event的引用。注意，这个函数指针的原型，是
tlm_event_finder_t区别于拎一个<<data::sc_event_finder_t, sc_core::sc_event_finder_t>>的重要地方，
虽然sc_event_finder_t同样继承自sc_event_finder, 但sc_event_finder_t接受的函数指针的原型是没有入参的。
tlm_event_finder_t构造时候的函数指针也是保存下来的唯一一个成员变量。

作为sc_event_finder的子类，tlm_event_finder_t同样需要实现接口函数find_event:

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_ports/tlm_event_finder.h
[source,cpp]
----
template <class IF , class T>
inline
const sc_core::sc_event&
tlm_event_finder_t<IF,T>::find_event( sc_core::sc_interface* if_p ) const
{
    const IF* iface = ( if_p ) ? dynamic_cast<const IF*>( if_p ) :
                                 dynamic_cast<const IF*>( port().get_interface() );
    if( iface == 0 ) {
        report_error( sc_core::SC_ID_FIND_EVENT_, "port is not bound" );
        return sc_core::sc_event::none;
    }
    return (const_cast<IF*>( iface )->*m_event_method) ( 0 );
}
----

这里的find_event实现比较直观。首先需要获取一个指向interface的指针，指针的来源要么是入参，要么是port的
get_interface返回值，注意find_event调用的时候，已经是所有的port都完成了绑定，即将开始仿真的时刻。如果这个时候
入参为空指针，并且port返回的也是空指针，那么就意味着相应的port没有完成绑定，这时候就需要报错。获取到interface
的指针之后，将其cast，然后调用注册的成员函数指针。注意，这里成员函数指针的调用的时候入参为0. 从这方面来讲，TLM 1.0
中这个 `tlm_tag<T>*` 并没有起到什么实际的作用。

==== tlm_nonblocking_get_port
[[tlm::1::tlm_nonblocking_get_port]]

tlm_nonblocking_get_port是用来绑定实现了<<tlm::1::tlm_nonblocking_get_if, tlm_nonblocking_get_if>>
实例的port：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_ports/tlm_nonblocking_port.h
[source,cpp]
----
template < typename T >
class tlm_nonblocking_get_port :
public sc_core::sc_port< tlm_nonblocking_get_if< T > , 1 >
{
public:
  typedef tlm_nonblocking_get_if<T> get_if_type;

  tlm_nonblocking_get_port( const char *port_name ) :
    sc_core::sc_port< tlm_nonblocking_get_if< T > , 1 >( port_name ) {}

  sc_core::sc_event_finder& ok_to_get() const {

    return *new tlm_event_finder_t< get_if_type , T >(
       *this,
       &get_if_type::ok_to_get );

  }

};
----

tlm_nonblocking_get_port最为重要的是显示一个 ok_to_get的成员函数，这个成员函数返回一个
<<tlm::1::tlm_event_finder_t, tlm_event_finder_t>>，用来延迟返回所绑定的interface上
真正的那个ok_to_get所应该返回的event。

只有nonblocking相关的interface对应的port需要特殊处理，blocking相关的interface没有事件
来设置sensitive，所以相应的port无需做特殊实现。

这样一来，假如我们有以下数据类型：

[source,cpp]
----
tlm_nonblocking_get_port<DATA> m_port;
----

那么如果需要某个线程对此 `m_port` 敏感，这个 `m_port` 有数据可供获取的时候就得到执行，那么就可以使用如下代码：

[source,cpp]
----
SC_THREAD(some_thread);
sensitive << m_port.ok_to_get();
----

在 `some_thread` 内部可以使用一个空的 `wait()` 来等待事件发生，当wait到的时候，就说明对应的port底层绑定到interface
实现中，相应的 `ok_to_get` 事件发生了。注意，当用 `m_port.ok_to_get()` 设置为 `some_thread` 的静态敏感源的时候，
`m_port` 很可能还没有绑定任何interface，所以此时也无法返回event，所以这里需要一个
<<tlm::1::tlm_event_finder_t, tlm_event_finder_t>>作为占位符，推迟获取event的调用，直到仿真即将开始的时刻。

==== tlm_nonblocking_put_port
[[tlm::1::tlm_nonblocking_put_port]]

与<<tlm::1::tlm_nonblocking_get_port, tlm_nonblocking_get_port>>一样，
tlm_nonblocking_put_port同样为<<tlm::1::tlm_nonblocking_put_if, tlm_nonblocking_put_if>>使用的port做了特殊处理：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_ports/tlm_nonblocking_port.h
[source,cpp]
----
template < typename T >
class tlm_nonblocking_put_port :
public sc_core::sc_port< tlm_nonblocking_put_if< T > , 1 >
{
public:
  typedef tlm_nonblocking_put_if<T> put_if_type;

  tlm_nonblocking_put_port( const char *port_name ) :
    sc_core::sc_port< tlm_nonblocking_put_if< T > , 1 >( port_name ) {}

  sc_core::sc_event_finder& ok_to_put() const {

    return *new tlm_event_finder_t< put_if_type , T >(
             *this,
       &put_if_type::ok_to_put );

  }

};
----

最为重要的是实现了一个叫ok_to_put的成员函数，用来作为返回对应event的API，供使用者用来设置sensitive。

==== tlm_nonblocking_peek_port
[[tlm::1::tlm_nonblocking_peek_port]]

与<<tlm::1::tlm_nonblocking_get_port, tlm_nonblocking_get_port>>一样，
tlm_nonblocking_peek_port同样为<<tlm::1::tlm_nonblocking_peek_if, tlm_nonblocking_peek_if>>使用的port做了特殊处理：

.src/tlm_core/tlm_1/tlm_req_resp/tlm_channels/tlm_ports/tlm_nonblocking_port.h
[source,cpp]
----
template < typename T >
class tlm_nonblocking_peek_port :
public sc_core::sc_port< tlm_nonblocking_peek_if< T > , 1 >
{
public:
  typedef tlm_nonblocking_peek_if<T> peek_if_type;

  tlm_nonblocking_peek_port( const char *port_name ) :
    sc_core::sc_port< tlm_nonblocking_peek_if< T > , 1 >( port_name ) {}

  sc_core::sc_event_finder& ok_to_peek() const {

    return *new tlm_event_finder_t< peek_if_type , T >(
       *this,
       &peek_if_type::ok_to_peek );

  }

};
----

这里同样实现一个ok_to_peek的成员函数，来返回一个event_finder，当tlm_nonblocking_peek_port
作为sensitive设置的时候，就可以用这个event_finder延迟event的决议。

=== TLM 1.0 Analysis

TLM 1.0的Analysis部分是一系列小的interface以及fifo的组合，主要用来做辅助性的功能。

相比于TLM 1.0其他的interface, analysis支持多绑定。

==== tlm_write_if and tlm_delayed_write_if
[[tlm::1::tlm_write_if]]

tlm_write_if直接继承自<<data::sc_interface, sc_core::sc_interface>>，定义了一个接口函数
write:

.src/tlm_core/tlm_1/tlm_analysis/tlm_write_if.h
[source,cpp]
----
template <typename T>
class tlm_write_if : public virtual sc_core::sc_interface {
public:
  virtual void write(const T& t) = 0;
};
----

[[tlm::1::tlm_delayed_write_if]]

tlm::delayed_write_if直接继承自<<data::sc_interface, sc_core::sc_interface>>，定义了一个接口
函数write:

.src/tlm_core/tlm_1/tlm_analysis/tlm_write_if.h
[source,cpp]
----
template <typename T>
class tlm_delayed_write_if : public virtual sc_core::sc_interface {
public:
  virtual void write(const T& t, const sc_core::sc_time& time) = 0;
};
----

注意，这个接口函数和 <<tlm::1::tlm_write_if, tlm_write_if>>的接口函数同名，只不过参数不同，多了一个
设定的延迟时间而已。

==== tlm_analysis_if and tlm_delayed_analysis_if

[[tlm::1::tlm_analysis_if]]
tlm_analysis_if是<<tlm::1::tlm_write_if, tlm_write_if>>的别名（基本上，因为直接继承，没有改写任何方法，也没增加
其他的功能。同样的，tlm_delayed_analysis_if是<<tlm::1::tlm_delayed_analysis_if, tlm_delayed_analysis_if>>
的别名：
[[tlm::1::tlm_delayed_analysis_if]]

.src/tlm_core/tlm_1/tlm_analysis/tlm_analysis_if.h
[source,cpp]
----
template < typename T >
class tlm_analysis_if : public virtual tlm_write_if<T>
{
};

template < typename T >
class tlm_delayed_analysis_if : public virtual tlm_delayed_write_if<T>
{
};
----

==== tlm_analysis_triple
[[tlm::1::tlm_analysis_triple]]

tlm_analysis_triple是一种特殊的数据结构，其中名称里的triple表示三，意思是除了本身需要传递的数据结构
外，还额外增加了两个时间戳信息：

.src/tlm_core/tlm_1/tlm_analysis/tlm_analysis_triple.h
[source,cpp]
----
template< typename T>
struct tlm_analysis_triple {

  sc_core::sc_time start_time;
  T transaction;
  sc_core::sc_time end_time;
  // blabla
};
----

两个额外的时间戳信息 `start_time` 和 `end_time` 都是sc_time类型，加上本身的transaction一共有3个成员变量，这就是名字里
triple的由来了。

tlm_analysis_triple可以默认构造（前提是模板参数T本身支持默认构造），也支持拷贝构造，同时也支持只使用一个transaction数据来构造：

.src/tlm_core/tlm_1/tlm_analysis/tlm_analysis_triple.h
[source,cpp]
----
  tlm_analysis_triple() {}

  tlm_analysis_triple( const tlm_analysis_triple &triple ) {
    start_time = triple.start_time;
    transaction = triple.transaction;
    end_time = triple.end_time;
  }

  tlm_analysis_triple( const T &t ) {
    transaction = t;
  }
----

除了构造函数意外，tlm_analysis_triple最为重要的是提供了到模板类型 `T` 转换的operator:

.src/tlm_core/tlm_1/tlm_analysis/tlm_analysis_triple.h
[source,cpp]
----
  operator T() { return transaction; }
  operator const T &() const { return transaction; }
----

这样当需要类型 `T` 的地方，可以使用一个 `tlm_analysis_triple<T>` 来代替，因为编译期会自动调用这里
定义的operator，完成相应的转换。

==== tlm_analysis_fifo
[[tlm::1::tlm_analysis_fifo]]

tlm_analysis_fifo是TLM 1.0 Analysis中最为重要的两个数据结构之一，另一个是相应的port。

tlm_analysis_fifo直接继承自 <<tlm::1::tlm_fifo, tlm_fifo>>，另外还继承了
<<tlm::1::tlm_analysis_if, tlm_analysis_if>>，提供了对应的接口函数实现：

.src/tlm_core/tlm_1/tlm_analysis/tlm_analysis_fifo.h
[source,cpp]
----
template< typename T >
class tlm_analysis_fifo :
  public tlm_fifo< T > ,
  public virtual tlm_analysis_if< T > ,
  public virtual tlm_analysis_if< tlm_analysis_triple< T > > {
    // blabla
};
----

tlm_analysis_fifo的构造函数比较奇特：

.src/tlm_core/tlm_1/tlm_analysis/tlm_analysis_fifo.h
[source,cpp]
----
  tlm_analysis_fifo( const char *nm ) : tlm_fifo<T>( nm , -16 ) {}
  tlm_analysis_fifo() : tlm_fifo<T>( -16 ) {}
----

注意tlm_analysis_fifo构造的时候，调用父类<<tlm::1::tlm_fifo, tlm_fifo>>的构造函数，传入的参数是一个
负的16，而不是正数。这个原因我们稍后解释。

NOTE: 从tlm_fifo的实现来看，负值和正值似乎没有区别，都是使用了绝对值来初始化tlm_fifo中内建的circular buffer。

对应的接口函数实现还是比较简单的，直接调用基类tlm_fifo的nb_put方法即可：

.src/tlm_core/tlm_1/tlm_analysis/tlm_analysis_fifo.h
[source,cpp]
----
  void write( const tlm_analysis_triple<T> &t ) {
    nb_put( t ); <1>
  }

  void write( const T &t ) {
    nb_put( t );
  }
----
<1> 因为tlm_fifo的模板类型是 `T`，所以这里先调用 `tlm_analysis_triple<T>`的operator，转出来一个类型 `T`，再放到fifo中

==== tlm_analysis_port
[[tlm::1::analysis_port]]

tlm_analysis_port和<<tlm::1::tlm_analysis_fifo, tlm_analysis_fifo>>构成了TLM 1.0 Analysis最为重要的两个部分：

.src/tlm_core/tlm_1/tlm_analysis/tlm_analysis_port.h
[source,cpp]
----
template < typename T>
class tlm_analysis_port :
  public sc_core::sc_object ,
  public virtual tlm_analysis_if< T >
{
    //blabla
 private:
  std::deque< tlm_analysis_if<T> * > m_interfaces; <1>
};
----
<1> 唯一一个成员变量是保存 `tlm_analysis_if<T>*` 的deque

值得注意的是，并不像名字一样，tlm_analysis_port并不是一个port，因为没有继承自<<data::sc_port, sc_core::sc_port>>，反而
继承自 <<tlm::1::tlm_analysis_if, tlm_analysis_if>>，这意味着tlm_analysis_port同样需要实现write接口函数：

.src/tlm_core/tlm_1/tlm_analysis/tlm_analysis_port.h
[source,cpp]
----
  void write( const T &t ) {
    typename std::deque< tlm_analysis_if<T> * >::iterator i;

    for( i = m_interfaces.begin();
   i != m_interfaces.end();
   i++ ) {

      (*i)->write( t ); <1>

    }

  }
----
<1> i是一个迭代器，所以(*i) 就是指向 `tlm_analysis_if<T>` 的指针

[[tlm::1::tlm_analysis_port::write]]
write的实现实际上是遍历所有保存的 `tlm_analysis_if<t>*`，调用这些interface的write函数，这里实际上完成了一个广播的工作。

[[tlm::1::tlm_analysis_port::bind]]
tlm_analysis_port虽然不是一个真正的sc_port，但同样提供了和sc_port一样的绑定函数：

.src/tlm_core/tlm_1/tlm_analysis/tlm_analysis_port.h
[source,cpp]
----
  virtual void bind( tlm_analysis_if<T> &_if ) { <1>
    m_interfaces.push_back( &_if );
  }

  void operator() ( tlm_analysis_if<T> &_if ) { bind( _if ); }
----
<1> 虽然bind函数声明为virtual，但由于tlm_analysis_port并没有继承自sc_port/sc_export，所以这个bind的virtual没有override任何基类的方法

这两种形式的绑定函数实际上只是将需要绑定的interface保存到成员变量 `m_interfaces` 内而已。

[[tlm::1::tlm_analysis_port::unbind]]
与传统的sc_port不同，tlm_analysis_port还提供了一个unbind的函数，用来完成解绑定的工作：

tlm_1/tlm_analysis/tlm_analysis_port.h
[source,cpp]
----
  virtual bool unbind( tlm_analysis_if<T> &_if ) {

    typename std::deque< tlm_analysis_if<T> * >::iterator i
      = std::remove( m_interfaces.begin(), m_interfaces.end(), &_if );

    if( i != m_interfaces.end() ) {
      m_interfaces.erase(i, m_interfaces.end() );
      return 1;
    }

    return 0;

  }
----

解绑定实际上就是从dequeue中寻找所需要解绑定的interface，然后去除掉而已。注意unbind函数是一个虚函数，这意味着继承了
tlm_analysis_port的子类可以按需重新实现unbind。

NOTE: 为何tlm_analysis_port名字里带有port，实际上却实现为 tlm_analysis_if的子类呢？这是为了方便使用analysis port
绑定到相关interface上，然后输出做analysis。tlm_analysis_port使用简单的代码，就可以实现绑定任意数目（包括0个）interface
的功能，并在API write处广播所有的write请求。这对于需要实现analysis功能是非常有用的。

=== TLM 1.0的思考

TLM 1.0相比于SystemC，只是一些简单的封装而已。从概念上而言，TLM 1.0所实现的TLM是非常简陋的。这也是为何TLM选择直接推出全新的TLM 2.0
来实现TLM的概念，而不是在TLM 1.0基础上继续演进的原因了。

尽管如此，TLM 1.0仍然反映出来了一些Transaction Level Modeling的思想，典型的就是<<tlm::1::tlm_transport_if, tlm_transport_if>>
的设计，一个接口函数调用可以同时做到接受请求返回响应，这已经初步体现了TLM的思想了。

TLM 1.0虽然设计的比较简单粗略，但仍然具有一些实用意义。比好简单的验证环境下，可以使用TLM 1.0和UVM做桥接来进行混合仿真。

=== Reference

https://eda-playground.readthedocs.io/en/latest/_static/uvm-1.2/files/overviews/tlm1-txt.html