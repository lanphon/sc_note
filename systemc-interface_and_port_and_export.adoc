:source-highlighter: coderay

:toc: left

再谈SystemC中的Interface, Port和Export
[[chap::interface_and_port_and_export]]

== 引言

在<<chap::misc, SystemC中的其他组件和用例分析>>中，我们从源代码层次介绍了
<<data::sc_interface, sc_core::sc_interface>>，并且在
<<chap::port_and_export, SystemC中的Port和Export>>部分花了一章从
源代码层次介绍<<data::sc_port, sc_core::sc_port>>和
<<data::sc_export, sc_core::sc_export>>。这些部分的介绍，主要集中在具体的实现细节上，而缺少
对背后的SystemC的设计思想的思考，在本章，我们将尝试从设计意图等方面，重新审视一下SystemC下的
interface, port和ejuert的关系。

== Interface
[[discuss::sc_interface]]

<<data::sc_interface, sc_core:::sc_interface>>并不简单是一个基类。准确来说，sc_interface
是SystemC设计的interface继承体系种，最底层的实现。SystemC中的任何一种interface类型，都必须
直接或者间接继承自sc_interface类型，这样一来：

* sc_port和sc_export中，保存interface信息的时候，只需要保存一个 `sc_interface*`
即可
* 当sc_port/sc_export需要使用具体的interface类型信息的时候，可以尝试使用 `dynamic_cast` ，将
基类指针提升到派生类指针

从上述可以看出，一般情况下，end-user不应该直接使用sc_interface，因为sc_interface实际上没有实现
任何功能。sc_interface更多的是作为一个设计上的概念约束而存在的，所有在SystemC中的interfaces都需要
继承自sc_interface。

那么，一个interface继承自sc_interface，意味着什么呢？如果设计了一个继承自sc_interface的interface类，
那么这个interface类需要是一个虚基类，这个interface类一定要有纯虚函数的接口函数，用来让其他派生组件
实现这些接口函数。这个interface类可以使一个模板类，但这不影响我们之前的结论。

这个interface类一般会用到两个地方：

* 组件设计中，继承自这个interface类，并实现对应的接口函数
* port/export中，使用这个interface类作为模板参数

这样一来，port/export就可以使用bind，来绑定一个实现了interface类接口函数的组件了。这种绑定的结果是，port/export
获得了一个指向组件的interface类型的指针（实际上保存的只是一个sc_interface类型的指针，只不过在需要的使用cast成为
派生类interface的指针而已），并且限制port/export只能使用这个interface类的接口函数，而不能使用实际被绑定的组件
的其他成员函数。

举个例子。在SystemC内部，设计了一系列继承自sc_interface的类，包括
`sc_fifo_nonblocking_in_if<T>` , `sc_fifo_blocking_in_if<T>`
， `sc_fifo_nonblocking_out_if<T>` 和 `sc_fifo_blocking_out_if<T>`
，每一个派生类都定义了自己的接口函数。这4个sc_interface的直接派生类组合成为
两个派生类 `sc_fifo_in_if<T>` 和 `sc_fifo_out_if<T>` 。而在
<<data::sc_fifo, sc_core::sc_fifo>>定义中，继承了这两个类：

.src/sysc/communication/sc_fifo.h
[source,cpp]
----
template <class T>
class sc_fifo
: public sc_fifo_in_if<T>,
  public sc_fifo_out_if<T>,
  public sc_prim_channel
----

同时在sc_fifo的实现中，将所有的接口函数一一实现（否则实例化一个sc_fifo的时候无法通过编译）。这样一来，一个
`sc_fifo<T>` 就是一个实现了某种约定（约定的细节由各个sc_interface的派生类所决定）的组件。这个组件的这种
约定可以被port/export绑定，并在run-time的时候调用。

=== sc_interface的使用

对于SystemC的用户而言，一般sc_interface是很少直接用到的，大多数情况下，用到的都是sc_interface
的派生类，或者实现了sc_interface派生类接口函数的组件，例如使用的都是 `sc_fifo_in_if<T>`
或者 `sc_fifo<T>` 等。但在一些情况下，可能需要直接用到sc_interface。例如，如果有需求
设计新的interface，那么就需要显式派生自sc_interface。

此外，sc_interface能够代表通用interface
的能力，有些时候也需要用到。比如在设计某个接口函数的时候，需要提供一个能够接受所有interface
能力的数据结构，并在后续具体给定类型后再决定类型。这种用法就和sc_port/sc_export中使用
`sc_interface*` 的方法很类似。这时候就可以使用 `sc_interface*`
或者 `sc_interface&` 作为类型，而在需要具体类型的时候dynamic cast。

== port

port，并不单纯是一个<<data::sc_port, sc_core::sc_port>>，而是SystemC中涉及的一系列与之相关的核心的
数据结构。由于SystemC设计的时候CPP还没有 `std::variant<>` 这样的能够做到类型擦除的组件，因而SystemC自己
不得不实现了一套复杂的继承体系，来达到类似的目的。对于port而言，与之相关的数据结构有：

* <<api::sc_port_base, sc_core::sc_port_base>>
* <<api::sc_port_b, sc_core::sc_port_b<IF> >>
* <<api::sc_port, sc_core::sc_port<IF, N, POL> >>