:source-highlighter: coderay

:toc: left

SystemC中的Event
[[chap::event]]

=== 引言

在之前的介绍中，我们已经看到了sc_event的重要作用。本部分我们对sc_event的设计和相关的API再做一次回顾，
探究其中的设计模式和设计原理。本部分也一并回顾了SystemC的wait/next_trigger API，并进行深入挖掘。

=== sc_event_list以及派生类

多个sc_event可以组成and/or list，这些复杂的sc_event表达式的结果是保存在sc_event_list以及派生类
中的。

IEEE的SystemC规范建议用户不要直接使用sc_event_list以及派生类，而仅仅将他们作为函数的参数
来使用。这些 sc_event_list/sc_event_and_list/sc_event_or_list应当是使用 `operator |`
或者 `operator &` 时候，作为临时变量创建出来，并在使用后销毁的。

==== sc_event_list
[[data::sc_event_list]]

sc_event_list是个基础类，没有继承自其他任何部分。对于一个sc_event_list而言，重要
的成员变量包括：

.src/sysc/kernel/sc_event.h
[source,cpp]
----
    std::vector<const sc_event*> m_events;
    bool                         m_and_list;
    bool                         m_auto_delete;
    mutable unsigned             m_busy;
----

从成员变量可以看出，sc_event_list是一个保存多个sc_event指针的数组结构。sc_event_list
一般是临时创建的，用来为wait/next_trigger服务的对象，因此内部有一个 `m_auto_delete`
的成员变量，表明是否自动回收sc_event_list本身。

sc_event_list采取一种类似于引用计数的方式。每次调用 `sc_event_list::add_dynamic`
成员函数，将一个method/thread process handle设置为**所有**保存的
event的动态敏感handle时候，计数器 `m_busy` 都会自加。而当调用 `auto_delete`
函数的时候，首先将计数器 `m_busy` 自减。
[[api::sc_event_list::add_dynamic]]

.src/sysc/kernel/sc_event.cpp
[source,cpp]
----
void
sc_event_list::add_dynamic( sc_method_handle method_h ) const
{
    m_busy++; <1>
    if ( m_events.size() != 0 ) {
      const sc_event* const * l_events = &m_events[0];
      for( int i = m_events.size() - 1; i >= 0; -- i ) {
          l_events[i]->add_dynamic( method_h ); <2>
      }
  }
}

void
sc_event_list::add_dynamic( sc_thread_handle thread_h ) const
{
    m_busy++; <1>
    if ( m_events.size() != 0 ) {
      const sc_event* const* l_events = &m_events[0];
      for( int i = m_events.size() - 1; i >= 0; -- i ) {
          l_events[i]->add_dynamic( thread_h ); <2>
      }
  }
}
----
<1> 自加计数器 `m_busy`
<2> sc_event_list的add_dynamic，实际上就是对于保存的每个event都调用add_dynamic

从 `sc_event_list::add_dynamic` 的实现代码中，我们也可以看出，对于sc_event_list
保存的每个sc_event对象，他们之间更多的是**或**的关系：只要有一个事件发生，就会调度
相对应的process handle的trigger_dynamic函数。而区分这些event究竟是“与”还是“或”
关系，就取决于thread/method process中的<<sc_process_b::trigger_dynamic, trigger_dynamic>>函数了。

如果自减的结果等于0，并且设置为自动删除，就会
`delete this` 的方式自动删除本身所占用的资源。
[[api::sc_event_list::auto_delete]]

.src/sysc/kernel/sc_event.h
[source,cpp]
----
inline
void
sc_event_list::auto_delete() const
{
    if( m_busy ) {
        --m_busy;
    }
    if( ! m_busy && m_auto_delete ) {
        delete this;
    }
}
----

`sc_event_list::auto_delete` 是sc_event_list的内部函数，只用在 sc_event_list
自己的拷贝构造函数，以及拷贝赋值函数中：

.src/sysc/kernel/sc_event.h
[source,cpp]
----
inline
sc_event_list::sc_event_list( sc_event_list const & that )
  : m_events()
  , m_and_list( that.m_and_list )
  , m_auto_delete( false )
  , m_busy( 0 )
{
    move_from( that );
    that.auto_delete(); // free automatic lists
}

inline
sc_event_list&
sc_event_list::operator=( sc_event_list const & that )
{
    if( m_busy )
        report_invalid_modification();

    if( SC_LIKELY_(this != &that) ) {
        move_from( that );
        that.auto_delete(); // free automatic lists
    }

    return *this;
}
----

在拷贝构造函数和拷贝赋值函数中使用 `sc_event_list::auto_delete` ，更多的作用是实现了
资源管理的自动释放。

[[api::sc_event_list::remove_dynamic]]
sc_event_list还有两个 `remove_dynamic` 函数实现。这个函数就和 `add_dynamic`
类似，调度了每个事件的 `remove_dynamic` 。特殊的一点在于，`remove_dynamic`
可以接受第二个参数，一个指向sc_event的指针。在remove_dynamic的时候，如果
保存的事件指针等于这个设定的指针，就跳过调用事件的remove_dynamic。当这个指针
被设置为0的时候，意味着所有保存的事件都要remove_dynamic。

.src/sysc/kernel/sc_event.cpp
[source,cpp]
----
void
sc_event_list::remove_dynamic( sc_method_handle method_h,
                               const sc_event* e_not ) const
{
    if ( m_events.size() != 0 ) {
      const sc_event* const* l_events = &m_events[0];
      for( int i = m_events.size() - 1; i >= 0; -- i ) {
          const sc_event* e = l_events[i];
          if( e != e_not ) {
              e->remove_dynamic( method_h );
          }
      }
  }
}

void
sc_event_list::remove_dynamic( sc_thread_handle thread_h,
                               const sc_event* e_not ) const
{
    if ( m_events.size() != 0 ) {
      const sc_event* const* l_events = &m_events[0];
      for( int i = m_events.size() - 1; i >= 0; -- i ) {
          const sc_event* e = l_events[i];
          if( e != e_not ) {
              e->remove_dynamic( thread_h );
          }
      }
  }
}
----

[NOTE]
====
sc_event_list，以及其派生类都没有实现 `add_static` 或者 `remove_static`
成员函数，这意味着sc_event_list以及派生类无法作为静态敏感源设置。
====

==== sc_event_expr<T>

在介绍sc_event_list的两个派生类，sc_event_and_list和sc_event_or_list之前，我们先
学习下sc_event_expr<T>。sc_event_expr<T>并不继承自sc_event_list。

sc_event_expr<T>是一个模板类，模板的参数可以是sc_event_and_list，别名是sc_event_and_expr，
或者是sc_event_or_list（别名sc_event_or_expr）：

.src/sysc/kernel/sc_event.h
[source,cpp]
----
typedef sc_event_expr<sc_event_and_list> sc_event_and_expr;

typedef sc_event_expr<sc_event_or_list> sc_event_or_expr;
----

sc_event_expr<T> 内部保存一个指向类型T的指针，并且设计了一些成员函数（尤其是push_back），转发
给内部的T类型成员变量。

sc_event_expr<T> 模板的功能表现的就如同其内部类型T一样。之所以这么设计一个这样的模板，是因为
`&` 和 `|` 作为二元运算符，具有左结合的特点。具体的实现细节有待深究。

==== sc_event_and_list
[[data::sc_event_and_list]]

sc_event_and_list直接继承自sc_event_list:

.src/sysc/kernel/sc_event.h
[source,cpp]
----
class SC_API sc_event_and_list
: public sc_event_list
----

相比于基类sc_event_list, sc_event_and_list并没有增加任何其他的成员变量。sc_event_and_list
更多的是增加了几个成员函数，尤其是 `operator &` ，以方便创建 `sc_event_and_list` :

.src/sysc/kernel/sc_event.h
[source,cpp]
----
    sc_event_and_list& operator &= ( const sc_event& );
    sc_event_and_list& operator &= ( const sc_event_and_list & );

    sc_event_expr<sc_event_and_list>  operator & ( const sc_event& );
    sc_event_expr<sc_event_and_list>  operator & ( const sc_event_and_list& );
----

这四个关于 `operator &=` 和 `operator &` 的重载，才是 `sc_event_and_list` 的核心所在。

注意，在 `operator &` 中，返回值类型不是 `sc_event_and_list` ，而是一个 `sc_event_expr<sc_event_and_list>` ，也就是 `sc_event_and_expr` 类型。
这么设计的原因我暂时还没有想到，希望以后能有所发现。

假设我们有一系列 `sc_event e0, e1, e2, e3` ，那么 `e0 & e1 & e2 & e3`
按照左结合律的特点，应当是 `(((e0 & e1) & e2) & e3)` 。 `e0 & e1` 调用
`sc_event::operator &` ，返回一个 `sc_event_and_expr`。接下来
`& e2` 则调用的是自由函数 `sc_event_and_expr operator &(sc_event_and_expr, sc_event&)`
，同样返回一个 `sc_event_and_expr` ，依次类推。当 `sc_event_and_expr` 用在
wait/next_trigger函数中时，其定义的 `operator T const &()` 可以自动
转换为类型 `sc_event_and_list`

''''


仅仅从sc_event.h头文件来看，sc_event_and_list似乎并没有实现字面意义上的and功能。与之后要介绍的sc_event_or_list
相比，sc_event_and_list唯一的区别是初始化时，将基类sc_event_list中的成员变量 `m_and_list`
设置为true，但sc_event_or_list设置这个成员变量为false. 然而这个成员变量，以及返回这个成员变量
值的成员函数 `sc_event_list::and_list()`，却从未使用过。

实际上， `sc_event_list::m_and_list` 这个成员变量的确没有使用过。在SystemC中，process
动态调度的时候，是直接根据 wait/next_trigger的类型判断的。例如 
<<sc_process_b::trigger_dynamic, `sc_thread_process::trigger_dynamic`>>
代码的片段如下：


.src/sysc/kernel/sc_thread_process.cpp
[source,cpp]
----
    switch( m_trigger_type )
    {
      case EVENT:
	m_event_p = 0;
	m_trigger_type = STATIC;
	break;

      case AND_LIST: <1>
        -- m_event_count;
	if ( m_event_count == 0 )
	{
	    m_event_list_p->auto_delete();
	    m_event_list_p = 0;
	    m_trigger_type = STATIC;
	}
	else
	{
	    return true;
	}
	break;

      case OR_LIST: <1>
	m_event_list_p->remove_dynamic( this, e );
	m_event_list_p->auto_delete();
	m_event_list_p = 0;
	m_trigger_type = STATIC;
	break;
----
<1> 当使用 `sc_event_and_list` 作为 wait(对于thread而言)/next_trigger(对于method而言)
参数是， `m_trigger_type` 设置为 `AND_LIST` 。如果使用 `sc_event_or_list` 则设置
为 `OR_LIST`

在 `m_trigger_type` 为 `AND_LIST` 的时候，如果事件发生，但是 `m_event_count` 不为0，这种
情况下 `trigger_dynamic` 直接返回true，从引发trigger_dynamic的事件的动态process列表中
删除对这个process的引用。这样一来，如果引发trigger_dynamic的事件再次发生，就不会调用 `trigger_dynamic`
了。这保证对于 `AND_LIST` 这种trigger type来讲，必须每个事件都发生一次，才可以最终trigger
调度进程。

==== sc_event_or_list
[[data::sc_event_or_list]]

和sc_event_and_list一样，sc_event_or_list继承自sc_event_list，并且没有
增加任何其他的成员变量：

.src/sysc/kernel/sc_event.h
[source,cpp]
----
class SC_API sc_event_or_list
: public sc_event_list
----

在 `sc_event_or_list` 中，也为 `operator |=` 和 `operator |` 提供了重载的
成员函数：

.src/sysc/kernel/sc_event.h
[source,cpp]
----
    sc_event_or_list& operator |= ( const sc_event& );
    sc_event_or_list& operator |= ( const sc_event_or_list & );
    sc_event_expr<sc_event_or_list>  operator | ( const sc_event& ) const;
    sc_event_expr<sc_event_or_list>  operator | ( const sc_event_or_list& ) const;
----

需要说明的一点是，这些成员函数的实现，除了一些地方的类型不同以外，和 `sc_event_and_list`
相对应的成员函数的实现是一模一样的。
例如， `sc_event_or_list& operator |=(const sc_event_or_list &)`
与 `sc_event_and_list& operator &=(const sc_event_and_list &)`
的实现是一模一样的。
这也是理所应当的，因为无论是sc_event_and_list，还是sc_event_or_list，都只是将
一些sc_event存放起来，并提供相应的资源管理。这两个类的功能体现在
当其中一个sc_event notification时候，调用相对应的method/thread process的
<<sc_process_b::trigger_dynamic, trigger_dynamic>>地方 footnote:[根据
wait/next_trigger调用时候参数类型是sc_event_and_list还是sc_event_or_list决定trigger type]，而不在类本身。
这两个类提供这四个重载的operator，只是为了符合惯用法而已。

[NOTE]
====
在wait/next_trigger时候，`&` 和 `|` 不能混合使用，亦即我们无法创建混合and_list和or_list
类型的复杂list。现实设计中，混合and/or关系list的需求是非常非常罕见的。
====

=== sc_event
[[data::sc_event]]

在<<chap::schedule_model, 调度模型>>一章，我们已经看到了((sc_event))数据结构所扮演的重要角色。本部分
我们会深入系统地汇总下sc_event相关的内容。

sc_event是个基础类，没有继承自其它类。这也就意味着sc_event并没有继承自sc_object，没有
诸如hierarchy结构、框架回调函数等特性。这也是为何，在
API中，已经有了<<api::sc_find_object, sc_find_object>>的前提下，还需要
单独提供<<api::sc_find_event, sc_find_event>>的原因了。

==== 成员变量

对于sc_event而言，成员变量包括：

.src/sysc/kernel/sc_event.h
[source,cpp]
----
    enum notify_t { NONE, DELTA, TIMED };

    std::string     m_name;     // name of object.
    sc_object*      m_parent_p; // parent sc_object for this event.
    sc_simcontext*  m_simc;
    sc_dt::uint64   m_trigger_stamp; // delta of last trigger
    notify_t        m_notify_type;
    int             m_delta_event_index;
    sc_event_timed* m_timed;

    mutable std::vector<sc_method_handle> m_methods_static;
    mutable std::vector<sc_method_handle> m_methods_dynamic;
    mutable std::vector<sc_thread_handle> m_threads_static;
    mutable std::vector<sc_thread_handle> m_threads_dynamic;
----

对于一个sc_event而言，最为核心部分是与之关联的process handle。这些process handle分为四类：
[[data::sc_event::process_handle]]

1. 静态设置本事件为sensitive的method，存储在成员变量 `m_methods_static` 中
2. 使用 `next_trigger` 将本事件设置为动态调度敏感事件的method，存储在成员变量 `m_methods_dynamic` 中
3. 静态设置本事件为sensitive的thread(包括cthread)，存储在成员变量 `m_threads_static` 中
4. 使用 `wait` 降本事件设置为动态调度敏感事件的thread，存储在成员变量 `m_threads_dynamic` 中

一个sc_event，可以是DELTA EVENT，此时 `m_notify_type` 为 `DELTA` 。DELTA EVENT
在<<concept::crunch, simc的crunch>>函数中的NOTIFICATION阶段trigger。
sc_event也可以是TIMED EVENT，即 `m_notify_type` 为 `TIMED` 。 TIMED EVENT
在<<concept::timed_event, simc的simulate>>函数中，crunch运行完之后的仿真时间前进
部分trigger。无论哪种情况下，trigger完的EVENT进入NONE状态，将 `m_notify_type`
标记为 `NONE`.

成员变量 `m_delta_event_index` 用以标记当本sc_event为DELTA EVENT时，
在本次delta cycle中的delta event列表中的索引值。这个成员变量本身只赋值，没有在
其他地方用到。

成员变量 `m_timed` 则用以标记当本sc_event为TIMED EVENT时，notification
的**绝对时间**。这里记录的绝对时间是调用 `notify()` 成员函数设置延迟时间
的时候，将所设置的延迟时间加上当前仿真时间得到的。

`m_trigger_stamp` 成员变量则用以记录sc_event上一次被trigger时候的时间戳。
这个时间戳并不对应仿真时间，而是有着比仿真时间更精细的粒度，记录的是delta cycle
级别的时间戳。在有些场景下，这个时间戳可以用来判断sc_event是否在上个delta cycle
被trigger，已进行相关的动作。

成员变量 `m_name`, `m_simc` 以及 `m_parent_p` 主要用以记录sc_event
相关的场景信息，以提供DEBUG能力。

==== 构造和析构函数

sc_event可以是空构造，也可以给定本事件的名字。对于sc_event而言，名字并非必须，
可以为空。如果构造的时候，没有给event名字，那么SystemC内核会自动给这个event
起一个名字。

除了普通构造和给定名字构造以外，sc_event还有一个PRIVATE的构造函数：
[[concept::event::kernel_event]]

.src/sysc/kernel/sc_event.h
[source,cpp]
----
private:
    static struct kernel_tag {} kernel_event;
    explicit sc_event( kernel_tag, const char* name = NULL );
----

这个构造函数主要用来创建SystemC仿真器内部的事件，以及一些数据结构的内置事件对象。例如
sc_fifo中的write event和read event都属于使用这种方式创建的kernel event。
这个构造函数被标记为PRIVATE，因此只有sc_event的友元类才可以访问这个函数，创建
kernel event，这局限了这种构造函数的使用场景。对于kernel event，我们只需要
了解即可。

在构造函数中，sc_event会调用成员函数 `register_event` 将自己注册到
SystemC的内核中。这个注册动作主要是做一些hierarchy管理行为，例如将sc_event
名字加入到名称管理系统中，将sc_event本身加入所属的父模块的child event列表中等动作。
对于kernel event则不做这些， footnote:[kernel event可以认为是由SystemC内核托管的]
可以认为kernel event游离于SystemC管理普通
sc_event的体系之外，这也是称之为kernel event的原因。
[[api::sc_event::register_event]]

.src/sysc/kernel/sc_event.cpp
[source,cpp]
----
// +----------------------------------------------------------------------------
// |"sc_event::register_event"
// |
// | This method sets the name of this object instance and optionally adds
// | it to the object manager's hierarchy. The object instance will be
// | inserted into the object manager's hierarchy if one of the following is
// | true:
// |   (a) the leaf name is non-null and is_kernel_event == false
// |   (b) the event is being created before the start of simulation.
// |
// | Arguments:
// |     leaf_name = leaf name of the object or NULL.
// +----------------------------------------------------------------------------
void
sc_event::register_event( const char* leaf_name, bool is_kernel_event /* = false */ )
{
    sc_object_manager* object_manager = m_simc->get_object_manager();
    m_parent_p = m_simc->active_object();

    // No name provided, if we are not executing then create a name:

    if( !leaf_name || !leaf_name[0] ) <1>
    {
        if ( sc_is_running( m_simc ) ) return;
        leaf_name = sc_gen_unique_name
            ( is_kernel_event ? SC_KERNEL_EVENT_PREFIX : "event" );
    }

    // prepend kernel events with internal prefix
    else if ( is_kernel_event ) <2>
    {
        m_name = SC_KERNEL_EVENT_PREFIX;
        m_name.append( leaf_name );
        leaf_name = m_name.c_str();
    }

    // Create a hierarchichal name and place it into the object manager if
    // its not a kernel event:

    object_manager->create_name( leaf_name ).swap( m_name );

    if ( !is_kernel_event ) <3>
    {
	object_manager->insert_event(m_name, this);
	if ( m_parent_p )
	    m_parent_p->add_child_event( this ); <4>
	else
	    m_simc->add_child_event( this ); <5>
    }
}
----
<1> 如果给定的名字为空，那么SystemC会自己创建一个名字
<2> 对于kernel event，名字的命名有着特殊的方法
<3> 非kernel event才会加入object manager以及hierarchy结构中
<4> 若父对象不为空，那么就将这个event作为父对象的event
<5> 若父对象为空，则这个event由内核托管，参考<<api::sc_get_top_level_events, sc_get_top_level_events>>的实现


拷贝构造函数和赋值构造函数被标记为PRIVATE，并且未实现，这意味着sc_event不允许拷贝
或者赋值。

sc_event在构造函数中需要注册自己，并分配一些资源，所以sc_event的析构函数
是非空的。

.src/sysc/kernel/sc_event.cpp
[source,cpp]
----
// +----------------------------------------------------------------------------
// |"sc_event::~sc_event"
// |
// | This is the object instance destructor for this class. It cancels any
// | outstanding waits and removes the event from the object manager's
// | instance table if it has a name.
// +----------------------------------------------------------------------------
sc_event::~sc_event()
{
    cancel();
    if ( m_name.length() != 0 )
    {
	sc_object_manager* object_manager_p = m_simc->get_object_manager();
	object_manager_p->remove_event( m_name );
    }

    for(size_t i = 0; i < m_threads_dynamic.size(); ++i ) {
        if( m_threads_dynamic[i]->m_event_p == this )
            m_threads_dynamic[i]->m_event_p = 0;
    }
    for(size_t i = 0; i < m_methods_dynamic.size(); ++i ) {
        if( m_methods_dynamic[i]->m_event_p == this )
            m_methods_dynamic[i]->m_event_p = 0;
    }
}
----

析构函数主要完成了所分配资源的释放。此外，对于动态等待在本事件上的process handle而言，
还需要把内部保存的事件指针 `m_event_p` 置为空。

==== 与process handle交互的成员函数

[[api::sc_event::add_static]]
sc_event提供了8个成员函数，以用来与process handle做交互。这个8个成员函数分为两组，分别为
[[api::sc_event::add_dynamic]]
为本事件添加process handle，以及为本事件删除process handle。sc_event中保存process
[[api::sc_event::remove_static]]
handle的成员变量一共有四个，所以每一组对应的成员函数也有4个:
[[api::sc_event::remove_dynamic]]

.src/sysc/kernel/sc_event.h
[source,cpp]
----
    void add_static( sc_method_handle ) const;
    void add_static( sc_thread_handle ) const;
    void add_dynamic( sc_method_handle ) const;
    void add_dynamic( sc_thread_handle ) const;

    bool remove_static( sc_method_handle ) const;
    bool remove_static( sc_thread_handle ) const;
    bool remove_dynamic( sc_method_handle ) const;
    bool remove_dynamic( sc_thread_handle ) const;
----

这8个成员函数的实现是比较简单的。 `add_*` 只是简单地将函数参数放入对应的成员变量中。
`remove_*` 检索对应的成员变量，如果存在则去除。

这四个函数可以在elaboration阶段，或者simulation阶段被调用。


==== notify, trigger和cancel

一个sc_event，最为重要的就是状态的管理，包括notify（通知事件发生/延迟发生），trigger
（触发事件发生时的作用）以及cancel（取消之前设定的事件发生/延迟发生）。

===== notify
[[api::sc_event::notify]]

(((sc_event, notify)))
首先是notify。sc_event提供了多种notify方式，以满足不同的需求。

第一种notify是不带任何参数的notify。这种notify的语义定义是，事件立刻发生。

.src/sysc/kernel/sc_event.cpp
[source,cpp]
----
void
sc_event::notify()
{
    // immediate notification
    if( !m_simc->evaluation_phase() )
        // coming from
        //  * elaboration
        //  * sc_prim_channel::update
        //  * phase callbacks
    {
        SC_REPORT_ERROR( SC_ID_IMMEDIATE_NOTIFICATION_, "" );
        return;
    }
    cancel();
    trigger();
}
----

这种notify会在调用<<api::sc_event::cancel, cancel>>之后，立刻调用<<api::sc_event::trigger, trigger>>函数，作为事件发生的作用。因此这就带来一个可能的竞争问题：如果
动态敏感的process handle，调度的顺序在这个函数调用之前，那么相对应的process handle
就已经加入到事件保存的process handle中，不带参数的notify可以trigger这些process handle。反之，
如果这些process handle调度顺序在这个函数调用之后，那么相对应的process handle此刻是没有
加入到事件的process handle列表中的，不带参数的notify无法trigger这些process handle。然而，调度
的顺序是无法预测的，我们无法依靠调度的顺序来决定仿真的行为。

为了避免出现这种情况，SystemC建议用户不要在自己的代码中使用不带参数的notify。对于SystemC自己
而言，其内部的实现框架可保证顺序，所以不带参数的notify可以在Systemc内部使用。

NOTE: 用户代码中，替代不带参数的notify是设置时间为SC_ZERO_TIME的 `notify(const sc_time&)`，这个可以保证调度顺序。

第二种是带有时间参数的notify函数：

.src/sysc/kernel/sc_event.h
[source,cpp]
----
    void notify( const sc_time& );
    void notify( double, sc_time_unit );
----

带有延迟时间参数的notify函数，从语义上定义是，在给定的延迟时间之后，事件发生。
一个特殊的延迟时间, `SC_ZERO_TIME` ，可以用来从语义上定义事件**立刻**发生。
对于延迟时间设定为SC_ZERO_TIME的notify，事件将会被标记为delta event，从而
借助 <<concept::crunch, simc的crunch>>函数中的EVALUATE-UPDATE-NOTIFICATION
机制，在下一个delta cycle调度阻塞在本事件上的process handle。

当所设定的延迟时间不是 `SC_ZERO_TIME` 的时候，事件标记为timed event，进入
simc中的timed event列表。在仿真时间走到所标记的时间的时候，事件发生。

sc_event的延迟时间时可以反复设定的，而在sc_event内部，只保存距离当前时间最近的
设定延迟时间。

.src/sysc/kernel/sc_event.cpp
[source,cpp]
----
void
sc_event::notify( const sc_time& t )
{
    if( m_notify_type == DELTA ) {
        return; <1>
    }
    if( t == SC_ZERO_TIME ) {
#       if SC_HAS_PHASE_CALLBACKS_
            if( SC_UNLIKELY_( m_simc->get_status()
                              & (SC_END_OF_UPDATE|SC_BEFORE_TIMESTEP) ) )
            {
                std::stringstream msg;
                msg << m_simc->get_status()
                    << ":\n\t delta notification of `"
                    << name() << "' ignored";
                SC_REPORT_WARNING( SC_ID_PHASE_CALLBACK_FORBIDDEN_
                                 , msg.str().c_str() );
                return;
            }
#       endif
        if( m_notify_type == TIMED ) { <2>
            // remove this event from the timed events set
            sc_assert( m_timed != 0 );
            m_timed->m_event = 0;
            m_timed = 0;
        }
        // add this event to the delta events set
        m_delta_event_index = m_simc->add_delta_event( this );
        m_notify_type = DELTA;
        return;
    }
#   if SC_HAS_PHASE_CALLBACKS_
        if( SC_UNLIKELY_( m_simc->get_status()
                        & (SC_END_OF_UPDATE|SC_BEFORE_TIMESTEP) ) )
        {
            std::stringstream msg;
            msg << m_simc->get_status()
                << ":\n\t timed notification of `"
                << name() << "' ignored";
            SC_REPORT_WARNING( SC_ID_PHASE_CALLBACK_FORBIDDEN_
                             , msg.str().c_str() );
            return;
        }
#   endif
    if( m_notify_type == TIMED ) {
        sc_assert( m_timed != 0 );
        if( m_timed->m_notify_time <= m_simc->time_stamp() + t ) { <3>
            return;
        }
        // remove this event from the timed events set
        m_timed->m_event = 0;
        m_timed = 0;
    }
    // add this event to the timed events set
    sc_event_timed* et = new sc_event_timed( this, m_simc->time_stamp() + t ); <4>
    m_simc->add_timed_event( et );
    m_timed = et;
    m_notify_type = TIMED;
}
----
<1> 如果事件已经是一个delta event，那么无论设置的延迟时间是多少，都无法设置进来，因为delta event
是零延时的，没有比这更短的延时了
<2> 如果事件是一个timed event，延迟时间设定为SC_ZERO_TIME将会导致事件变成delta event，这需要
删除之前创建的成员变量 `m_timed`
<3> 事件是timed event，且设定的延迟时间大于之前设定的时间，直接忽略
<4> 事件是timed event，且设定的延迟时间小于之前设定的时间，重新设置事件发生的绝对时刻

第三种是一系列 `notify_delayed` 函数。这些函数都已经被标记为废弃了，仅仅是为了兼容性目的而继续保留。
这里我们就不再讨论这些deprecated函数。 `notify_delayed` 函数的功能可以被 `notify` 完全取代。


.src/sysc/kernel/sc_event.h
[source,cpp]
----
    void notify_delayed();
    void notify_delayed( const sc_time& );
    void notify_delayed( double, sc_time_unit );
----

带延时时间参数的notify是提供给用户的API,因为无法保证用户的使用方法,实现的时候需要考虑
同一个事件被多次设定延时时间的场景. 在SystemC内部，事件也得到广泛应用。在这种
受控的场景下，SystemC特意设计了两个notify函数，来简化相关代码的处理。

[[api::sc_event::notify_internal]]
`notify_internal` 是SystemC用以在内部设置事件延迟时间的API。这个API由于只在内部使用，
可以保证在事件真正发生之前，延时时间不会被反复设定，因此实现代码非常简单：

.src/sysc/kernel/sc_event.h
[source,cpp]
----
inline
void
sc_event::notify_internal( const sc_time& t )
{
    if( t == SC_ZERO_TIME ) {
        // add this event to the delta events set
        m_delta_event_index = m_simc->add_delta_event( this );
        m_notify_type = DELTA;
    } else {
        sc_event_timed* et =
		new sc_event_timed( this, m_simc->time_stamp() + t );
        m_simc->add_timed_event( et );
        m_timed = et;
        m_notify_type = TIMED;
    }
}
----

基本上就是用户API形式的缩水版，去掉了处理延时时间被多次设定相关的代码。
例如，在
<<api::sc_thread_process::wait::sc_time, sc_thread_process的wait>>一种重载形式
中，就是用了 `notify_internal`.
此外，在SystemC内部，
事件立即发生也是一个非常重要的使用场景，为此，sc_event提供了成员函数 `notify_next_delta`

.src/sysc/kernel/sc_event.h
[source,cpp]
----
inline
void
sc_event::notify_next_delta()
{
    if( m_notify_type != NONE ) {
        SC_REPORT_ERROR( SC_ID_NOTIFY_DELAYED_, 0 );
    }
    // add this event to the delta events set
    m_delta_event_index = m_simc->add_delta_event( this );
    m_notify_type = DELTA;
}
----

[[api::sc_event::notify_next_delta]]
`notify_next_delta` 可以在EVALUATE或者UPDATE PHASE调用，这是保证安全的。

`notify_internal` 和 `notify_next_delta` 是SystemC内部使用的，因此两个函数
都被标记为PRIVATE，只有友元类才能够使用。

==== trigger

[[api::sc_event::trigger]]

(((sc_event, trigger)))
sc_event的trigger函数一般在<<phase::notification, NOTIFICATION>>阶段被调用，或者
在一个crunch结束之后，下一个crunch开始之前被调用。

trigger函数可以将调用wait阻塞在本事件上的动态thread/cthread，调用next_trigger设置下次
动态调度时机的method，以及将本事件作为静态敏感事件注册的method/thread/cthread，放入
<<concept::runnable, simc的runnable>>列表中。并不是所有存在<<data::sc_event::process_handle, process handle列表>>
中的method/thread/cthread都会被放入runnable列表中。trigger函数只是直接调用这些
保存的process handle的trigger_static/trigger_dynamic方法，由这些process handle
自行判断是否满足条件。

.src/sysc/kernel/sc_event.cpp
[source,cpp]
----
// +----------------------------------------------------------------------------
// |"sc_event::trigger"
// |
// | This method "triggers" this object instance. This consists of scheduling
// | for execution all the processes that are schedulable and waiting on this
// | event.
// +----------------------------------------------------------------------------
void
sc_event::trigger()
{
    m_trigger_stamp = m_simc->change_stamp(); <1>
    m_notify_type = NONE; <2>
    m_delta_event_index = -1;
    m_timed = 0;

    int       last_i; // index of last element in vector now accessing.
    int       size;   // size of vector now accessing.


    // trigger the static sensitive methods

    if( ( size = m_methods_static.size() ) != 0 )
    {
        sc_method_handle* l_methods_static = &m_methods_static[0];
        int i = size - 1;
        do {
            sc_method_handle method_h = l_methods_static[i];
            method_h->trigger_static(); <3>
        } while( -- i >= 0 );
    }

    // trigger the dynamic sensitive methods


    if( ( size = m_methods_dynamic.size() ) != 0 )
    {
	last_i = size - 1;
	sc_method_handle* l_methods_dynamic = &m_methods_dynamic[0];
	for ( int i = 0; i <= last_i; i++ )
	{
	    sc_method_handle method_h = l_methods_dynamic[i];
	    if ( method_h->trigger_dynamic( this ) ) <4>
	    {
		l_methods_dynamic[i] = l_methods_dynamic[last_i];
		last_i--;
		i--;
	    }
	}
        m_methods_dynamic.resize(last_i+1);
    }


    // trigger the static sensitive threads

    if( ( size = m_threads_static.size() ) != 0 )
    {
        sc_thread_handle* l_threads_static = &m_threads_static[0];
        int i = size - 1;
        do {
            sc_thread_handle thread_h = l_threads_static[i];
            thread_h->trigger_static(); <3>
        } while( -- i >= 0 );
    }

    // trigger the dynamic sensitive threads

    if( ( size = m_threads_dynamic.size() ) != 0 )
    {
	last_i = size - 1;
	sc_thread_handle* l_threads_dynamic = &m_threads_dynamic[0];
	for ( int i = 0; i <= last_i; i++ )
	{
	    sc_thread_handle thread_h = l_threads_dynamic[i];
	    if ( thread_h->trigger_dynamic( this ) ) <4>
	    {
		l_threads_dynamic[i] = l_threads_dynamic[last_i];
		i--;
		last_i--;
	    }
	}
        m_threads_dynamic.resize(last_i+1);
    }
}
----
<1> 每次sc_event的trigger被调用的时候，都会保存下当前的delta cycle stamp
<2> sc_event的trigger被调用后，本sc_event变为一个NONE类型的sc_event
<3> 将本事件设置为静态敏感事件的method/thread process，调用其trigger_static成员函数
<4> 降本事件设置为东太敏感的method/thread process，调用trigger_dynamic，如果dynamic
trigger成功，则从本sc_event的process handle列表中移除此process

一个process handle可以同时存在于静态和动态列表中。这个时候需要此process自己判断情况。一般而言，
此时process handle的trigger_static只会简单返回，不作任何动作，而由trigger_dynamic来做
判断动作。

还有一个比较有趣的地方在于，如果一个process handle将sc_event设置为静态敏感事件，且没有动态
阻塞在这个事件上，那么当这个事件发生的时候，process handle的trigger_static会将这个
process加入到runnable列表中（thread/cthread可能设置多个cycle之后）。然而在使用的时候，
一个process handle可以设置多个静态敏感事件。所以，静态敏感事件之间是**或**的关系。一个可能的
想法是使用 `sc_event_and_list` 为process设置静态敏感事件，然而这种做法比较丑陋且不推荐。

==== cancel and reset
[[api::sc_event::cancel]]

(((sc_event, cancel)))
sc_event还提供了一个cancel的成员函数，这个成员函数可以在一个delta事件发生的之后，被调用
trigger起作用之前，或者timed事件到达设定时间之前，将sc_event clear掉状态。

.src/sysc/kernel/sc_event.cpp
[source,cpp]
----
void
sc_event::cancel()
{
    // cancel a delta or timed notification
    switch( m_notify_type ) {
    case DELTA: {
        // remove this event from the delta events set
        m_simc->remove_delta_event( this ); <1>
        m_notify_type = NONE;
        break;
    }
    case TIMED: {
        // remove this event from the timed events set
        sc_assert( m_timed != 0 );
        m_timed->m_event = 0; <2>
        m_timed = 0;
        m_notify_type = NONE;
        break;
    }
    default:
        ;
    }
}
----
<1> 对于delta event，需要将其从simc的delta event列表中移除
<2> 对于timed event，只需要将延迟时间清除掉，标记为NONE即可

[[api::sc_event::reset]]
sc_event提供了一个reset成员函数，将本sc_event的数据结构清除掉:

.src/sysc/kernel/sc_event.cpp
[source,cpp]
----
sc_event::reset()
{
    m_notify_type = NONE;
    m_delta_event_index = -1;
    m_timed = 0;
    // clear the dynamic sensitive methods
    m_methods_dynamic.resize(0);
    // clear the dynamic sensitive threads
    m_threads_dynamic.resize(0);
}
----

注意reset()只清除动态敏感的method和thread process handle。静态敏感的process列表
仍然保留。

=== wait
[[concept::wait]]

((wait))是Thread/CThread线程用以同步的一个API调用。SystemC中定义了多种形式的wait。例如，sc_module
定义了具有多种重载形式的成员函数wait:
[[api::wait]]

.src/sysc/kernel/sc_module.h
[source,cpp]
----
    // static sensitivity for SC_THREADs and SC_CTHREADs

    void wait()
        { ::sc_core::wait( simcontext() ); }

    // dynamic sensitivity for SC_THREADs and SC_CTHREADs

    void wait( const sc_event& e )
        { ::sc_core::wait( e, simcontext() ); }

    void wait( const sc_event_or_list& el )
	{ ::sc_core::wait( el, simcontext() ); }

    void wait( const sc_event_and_list& el )
	{ ::sc_core::wait( el, simcontext() ); }

    void wait( const sc_time& t )
        { ::sc_core::wait( t, simcontext() ); }

    void wait( double v, sc_time_unit tu )
        { ::sc_core::wait( sc_time( v, tu, simcontext() ), simcontext() ); }

    void wait( const sc_time& t, const sc_event& e )
        { ::sc_core::wait( t, e, simcontext() ); }

    void wait( double v, sc_time_unit tu, const sc_event& e )
        { ::sc_core::wait( 
		sc_time( v, tu, simcontext() ), e, simcontext() ); }

    void wait( const sc_time& t, const sc_event_or_list& el )
        { ::sc_core::wait( t, el, simcontext() ); }

    void wait( double v, sc_time_unit tu, const sc_event_or_list& el )
        { ::sc_core::wait( sc_time( v, tu, simcontext() ), el, simcontext() ); }

    void wait( const sc_time& t, const sc_event_and_list& el )
        { ::sc_core::wait( t, el, simcontext() ); }

    void wait( double v, sc_time_unit tu, const sc_event_and_list& el )
        { ::sc_core::wait( sc_time( v, tu, simcontext() ), el, simcontext() ); }
----

这些成员函数的本质，还是调用自由函数 `::sc_core::wait` 。这些wait函数调用可以分成几种：

* 静态敏感的wait，即不带任何参数的wait
* wait一个或者几个事件，多个事件可以是and关系，也可以是or关系
* wait一段特定的时间
* wait一个或者几个事件，带超时设定

而自由函数wait，一般会最终调用到 `sc_thread_process` 的wait成员函数上去，有一些
会调用到 `sc_thread_process` 的wait_cycles成员函数上。

==== 静态的wait

不带任何参数的wait，也就是 `wait()` 调用，调用的是如下自由函数：

.src/sysc/kernel/sc_wait.cpp
[source,cpp]
----
SC_API void
wait( sc_simcontext* simc )
{
    sc_curr_proc_handle cpi = simc->get_curr_proc_info();
    switch( cpi->kind ) {
    case SC_THREAD_PROC_:
    case SC_CTHREAD_PROC_: {
        reinterpret_cast<sc_thread_handle>( cpi->process_handle )->wait_cycles();
        break;
    }
    default:
	SC_REPORT_ERROR( SC_ID_WAIT_NOT_ALLOWED_, "\n        "
			 "in SC_METHODs use next_trigger() instead" );
        break;
    }
}
----

实际上调用的是proces的wait_cycles成员函数。

不带任何参数的 `wait` 会阻塞当前线程的执行，直到所设置的静态敏感事件中的一个发生，才会重新调度
执行当前线程。((wait_cycles))实际上并不是等待一个时钟周期，而是等待一个静态事件而已。
[[api::sc_thread_process::wait_cycles]]

对于Thread/Cthread而言，wait_cycles只是将所设定的数 `n` 减一之后赋给 `m_wait_cycle_n`
成员变量，然后调用 <<api::sc_thread_process::suspend_me, `suspend_me`> 让渡出执行权。

.src/sysc/kernel/sc_thread_process.h
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_thread_process::wait_cycles"
//
// This method suspends this object instance for the specified number of cycles.
// A cycle is defined as the event the thread is set up to staticly wait on.
// The field m_wait_cycle_n is set to one less than the number of cycles to
// be waited for, since the value is tested before being decremented in
// the simulation kernel.
//------------------------------------------------------------------------------
inline
void
sc_thread_process::wait_cycles( int n )
{
    if( m_unwinding )
        SC_REPORT_ERROR( SC_ID_WAIT_DURING_UNWINDING_, name() );

    if( n <= 0 )
        SC_REPORT_ERROR( SC_ID_WAIT_NEGATIVE_CYCLES_, name() );

    m_wait_cycle_n = n-1;
    suspend_me();
}
----

例如，如果wait_cycles设定等待一个clock cycle，那么 `n=1`，所设定的 `m_wait_cycle_n`
就是0. 在下次<<api::sc_thread_process::trigger_static, thread process的trigger_static>>成员函数被调用的时候，m_wait_cycle_n的检查
就会直接跳过。所以实际等待的clock cycle数目等于 `m_wait_cycle_n + 1` 。

==== wait一个或者多个事件

wait也可以带一个或者多个事件。例如，带一个事件时候，所调用的自由函数是：

.src/sysc/kernel/sc_wait.cpp
[source,cpp]
----
SC_API void
wait( const sc_event& e, sc_simcontext* simc )
{
    sc_curr_proc_handle cpi = simc->get_curr_proc_info();
    switch( cpi->kind ) {
    case SC_THREAD_PROC_: {
	reinterpret_cast<sc_thread_handle>( cpi->process_handle )->wait( e );
	break;
    }
    case SC_CTHREAD_PROC_: {
        warn_cthread_wait();
	sc_cthread_handle cthread_h =
            reinterpret_cast<sc_cthread_handle>( cpi->process_handle );
	cthread_h->wait( e );
	cthread_h->wait_cycles();
	break;
    }
    default:
	SC_REPORT_ERROR( SC_ID_WAIT_NOT_ALLOWED_, "\n        "
			 "in SC_METHODs use next_trigger() instead" );
        break;
    }
}
----

从这个函数也可以看出，CTHREAD不能使用wait一个或者多个事件，因为相应的API中已经将
这种用法标记为废弃了。

这种形式的wait，包括事件的and list或者or_list，都是调用了thread process handle
的同名
<<api::sc_thread_process::wait::sc_event, wait>>成员函数。

==== wait一段特定时间

根据延时时间设置的不同方式，这种wait也有不同的形式，其中都转发给了自由函数wait。一个
例子是：

.src/sysc/kernel/sc_wait.cpp
[source,cpp]
----
SC_API void
wait( const sc_time& t, sc_simcontext* simc )
{
    sc_curr_proc_handle cpi = simc->get_curr_proc_info();
    switch( cpi->kind ) {
    case SC_THREAD_PROC_: {
	reinterpret_cast<sc_thread_handle>( cpi->process_handle )->wait( t );
	break;
    }
    case SC_CTHREAD_PROC_: {
        warn_cthread_wait();
	sc_cthread_handle cthread_h =
            reinterpret_cast<sc_cthread_handle>( cpi->process_handle );
	cthread_h->wait( t );
	cthread_h->wait_cycles();
	break;
    }
    default:
	SC_REPORT_ERROR( SC_ID_WAIT_NOT_ALLOWED_, "\n        "
			 "in SC_METHODs use next_trigger() instead" );
        break;
    }
}
----

就像wait在一个或者多个事件一样，CTHREAD同样不能使用这种wait方式。这种的wait方式同样是
转发给了thread process的wait成员函数。

对于thread process而言，等待一段时间，等同于内部的一个 `m_timeout_event_p`
事件调用 <<api::sc_event::notify_internal, `notify_internal`>> 设定超时时间：

[[api::sc_thread_process::wait::sc_time]]
.src/sysc/kernel/sc_thread_process.h
[source,cpp]
----
inline
void
sc_thread_process::wait( const sc_time& t )
{
    if( m_unwinding )
        SC_REPORT_ERROR( SC_ID_WAIT_DURING_UNWINDING_, name() );

    m_timeout_event_p->notify_internal( t );
    m_timeout_event_p->add_dynamic( this );
    m_trigger_type = TIMEOUT;
    suspend_me();
}
----

因为在thread process自己的 `m_timeout_event_p` 调用 `notify_internal` 
后，调度了 `suspend_me` ，当前thread process让渡出执行权限，因此是不可能再次调用
一个 `wait(const sc_time&)` 来重新设置延时时间的。这样是为何这里
可以用 `notify_internal` 的重要原因了。

==== wait一个或者多个事件，带超时设定

wait也可以等待一个或者多个事件，设定一个超时时间。如果所设定的超时时间到了，事件没有满足要求，
wait仍然会返回。sc_module的wait是转发给自由函数wait的，例如：

.src/sysc/kernel/sc_wait.cpp
[source,cpp]
----
SC_API void
wait( const sc_time& t, const sc_event_and_list& el, sc_simcontext* simc )
{
    if( el.empty() ) {
        SC_REPORT_ERROR( SC_ID_EVENT_LIST_FAILED_,
                         "wait() on empty event list not allowed" );
        // may continue, if suppressed
    }

    sc_curr_proc_handle cpi = simc->get_curr_proc_info();
    switch( cpi->kind ) {
    case SC_THREAD_PROC_: {
	reinterpret_cast<sc_thread_handle>( cpi->process_handle )->wait( t, el );
	break;
    }
    case SC_CTHREAD_PROC_: {
        warn_cthread_wait();
	sc_cthread_handle cthread_h =
            reinterpret_cast<sc_cthread_handle>( cpi->process_handle );
	cthread_h->wait( t, el );
	cthread_h->wait_cycles();
	break;
    }
    default:
	SC_REPORT_ERROR( SC_ID_WAIT_NOT_ALLOWED_, "\n        "
			 "in SC_METHODs use next_trigger() instead" );
        break;
    }
}
----

同样，CTHREAD不能使用这种wait方式。这种wait同样是将请求转发给thread process的wait。

对于thread process而言，带超时设定的事件wait，等于分别设置两个event对象，例如
当使用多个事件的or list wait时：

[[api::sc_thread_process::wait::sc_time_with_event]]
.src/sysc/kernel/sc_thread_process.h
[source,cpp]
----
inline
void
sc_thread_process::wait( const sc_time& t, const sc_event_or_list& el )
{
    if( m_unwinding )
        SC_REPORT_ERROR( SC_ID_WAIT_DURING_UNWINDING_, name() );

    m_timeout_event_p->notify_internal( t );
    m_timeout_event_p->add_dynamic( this ); <1>
    el.add_dynamic( this ); <2>
    m_event_list_p = &el;
    m_trigger_type = OR_LIST_TIMEOUT;
    suspend_me();
}
----
<1> 设置超时事件
<2> 设置event事件

在thread process被<<sc_process_b::trigger_dynamic, trigger_dynamic>>
的时候，可以判断哪个事件首先发生。如果两个事件中的一个发生，则另一个被
<<api::sc_event::cancel, cancel>>掉.

==== CTHREAD特殊设计的wait

对于CTHREAD而言，之前介绍的wait方式，只有不带任何参数的wait()才可以在CTHREAD中使用。
为了扩展这项能力，sc_module的成员函数特意设计了一个 `wait(int)` ，可以指定
等待的clock cycle数：

.src/sysc/kernel/sc_module.h
[source,cpp]
----
    void wait( int n )
        { ::sc_core::wait( n, simcontext() ); }
----

对于CThread而言，还可以用 `wait(int)` 这种API调用，显式要求等待几个clock cycle。
这个自由函数wait的实现不再sc_wait.cpp，而是在sc_cthread_wait.cpp中：

.src/sysc/kernel/sc_cthread_wait.cpp
[source,cpp]
----
void
wait( int n, sc_simcontext* simc )
{
    sc_curr_proc_handle cpi = simc->get_curr_proc_info();
    if( n <= 0 ) {
        std::stringstream msg;
        msg << "n = " << n;
        SC_REPORT_ERROR( SC_ID_WAIT_N_INVALID_, msg.str().c_str() );
    }
    switch( cpi->kind ) {
      case SC_THREAD_PROC_:
      case SC_CTHREAD_PROC_:
        reinterpret_cast<sc_thread_handle>( cpi->process_handle )->wait_cycles( n );
        break;
      default:
        SC_REPORT_ERROR( SC_ID_WAIT_NOT_ALLOWED_, "\n        "
	                 "in SC_METHODs use next_trigger() instead" );
        break;
    }
}
----

可以看出实际上就是调用了process handle的<<api::sc_thread_process::wait_cycles, wait_cycles>>，给定了等待的clock cycle数目而已。

==== 小结

一般在sc_module设计中所调用的wait，会调用自由函数wait，进而调用到thread process
的wait成员函数。这样一种设计保证我们在sc_module中使用wait的时候无需指定process handle，
而是由SystemC自行检索。footnote:[实际是在自由函数中，通过simc的get_curr_proc_info查询到的]

无论哪种形式的wait，调用wait的thread/cthread process一定会被阻塞住，
在本次delta cycle中不再执行，而是将执行权让渡出去。

=== next_trigger
[[concept::next_trigger]]
类似于wait, ((next_trigger))也在多个地方有定义。sc_module中的next_trigger定义有：

.src/sysc/kernel/sc_module.h
[source,cpp]
----
    // static sensitivity for SC_METHODs

    void next_trigger()
	{ ::sc_core::next_trigger( simcontext() ); }


    // dynamic sensitivty for SC_METHODs

    void next_trigger( const sc_event& e )
        { ::sc_core::next_trigger( e, simcontext() ); }

    void next_trigger( const sc_event_or_list& el )
        { ::sc_core::next_trigger( el, simcontext() ); }

    void next_trigger( const sc_event_and_list& el )
        { ::sc_core::next_trigger( el, simcontext() ); }

    void next_trigger( const sc_time& t )
        { ::sc_core::next_trigger( t, simcontext() ); }

    void next_trigger( double v, sc_time_unit tu )
        { ::sc_core::next_trigger( 
	    sc_time( v, tu, simcontext() ), simcontext() ); }

    void next_trigger( const sc_time& t, const sc_event& e )
        { ::sc_core::next_trigger( t, e, simcontext() ); }

    void next_trigger( double v, sc_time_unit tu, const sc_event& e )
        { ::sc_core::next_trigger( 
		sc_time( v, tu, simcontext() ), e, simcontext() ); }

    void next_trigger( const sc_time& t, const sc_event_or_list& el )
        { ::sc_core::next_trigger( t, el, simcontext() ); }

    void next_trigger( double v, sc_time_unit tu, const sc_event_or_list& el )
        { ::sc_core::next_trigger( 
	    sc_time( v, tu, simcontext() ), el, simcontext() ); }

    void next_trigger( const sc_time& t, const sc_event_and_list& el )
        { ::sc_core::next_trigger( t, el, simcontext() ); }

    void next_trigger( double v, sc_time_unit tu, const sc_event_and_list& el )
        { ::sc_core::next_trigger( 
	    sc_time( v, tu, simcontext() ), el, simcontext() ); }
----

同样可以分为如下四种

* 静态敏感的next_trigger，即不带任何参数的next_trigger
* next_trigger一个或者几个事件，多个事件可以是and关系，也可以是or关系
* next_trigger一段特定的时间
* next_trigger一个或者几个事件，带超时设定

在<<api::next_trigger, schedule model的next_trigger>>部分，我们初步介绍了几种基础的
next_trigger使用，主要是next_trigger无参数，或者参数为一个event时候的场景。

==== next_trigger一段时间

对于设定了一段特定时间的next_trigger，自由函数next_trigger的实现则是：

.src/sysc/kernel/sc_wait.cpp
[source,cpp]
----
SC_API void
next_trigger( const sc_time& t, sc_simcontext* simc )
{
    sc_curr_proc_handle cpi = simc->get_curr_proc_info();
    if( cpi->kind == SC_METHOD_PROC_ ) {
	reinterpret_cast<sc_method_handle>( cpi->process_handle )->next_trigger( t );
    } else {
	SC_REPORT_ERROR( SC_ID_NEXT_TRIGGER_NOT_ALLOWED_, "\n        "
			 "in SC_THREADs and SC_CTHREADs use wait() instead" );
    }
}
----

这里其实调用了method process的next_trigger成员函数：

.src/sysc/kernel/sc_method_process.h
[source,cpp]
----
inline
void
sc_method_process::next_trigger( const sc_time& t )
{
    clear_trigger();
    m_timeout_event_p->notify_internal( t );
    m_timeout_event_p->add_dynamic( this );
    m_trigger_type = TIMEOUT;
}
----

类似于带设定时间的wait, next_trigger也是借助内部的一个事件 `m_timeout_event_p`
来设置的。然而，这里需要注意都是，不同于wait，带延时设定的next_trigger是可以被
反复设定的，这也就意味着这里的 `notify_internal` 可能被多次调用。
为了避免出现问题，这里在next_trigger最开始，调用了<<api::sc_method_process::clear_trigger, `clear_trigger`>>
将这些变量重置到初始状态。

在method process中，多次调用next_trigger设定不同的trigger条件并不是一个良好的设计模式。

==== next_trigger一个或几个事件，带超时设定

对于设定了一个或几个事件的带超时的next_trigger，自由函数next_trigger的实现例子是：

.src/sysc/kernel/sc_wait.cpp
[source,cpp]
----
SC_API void
next_trigger(const sc_time& t, const sc_event_and_list& el, sc_simcontext* simc)
{
    if( el.empty() ) {
        SC_REPORT_ERROR( SC_ID_EVENT_LIST_FAILED_,
                         "next_trigger() on empty event list not allowed" );
        // may continue, if suppressed
    }

    sc_curr_proc_handle cpi = simc->get_curr_proc_info();
    if( cpi->kind == SC_METHOD_PROC_ ) {
	reinterpret_cast<sc_method_handle>( cpi->process_handle )->next_trigger( t, el );
    } else {
	SC_REPORT_ERROR( SC_ID_NEXT_TRIGGER_NOT_ALLOWED_, "\n        "
			 "in SC_THREADs and SC_CTHREADs use wait() instead" );
    }
}
----

这里其实调用了method process的next_trigger成员函数：

.src/sysc/kernel/sc_method_process.h
[source,cpp]
----
inline
void
sc_method_process::next_trigger( const sc_time& t, const sc_event_and_list& el )
{
    clear_trigger();
    m_timeout_event_p->notify_internal( t );
    m_timeout_event_p->add_dynamic( this );
    el.add_dynamic( this );
    m_event_list_p = &el;
    m_event_count = el.size();
    m_trigger_type = AND_LIST_TIMEOUT;
}
----

类似于wait的操作，这里也是保存了两个事件，而在
<<sc_process_b::trigger_dynamic, trigger_dynamic>>
中判断事件的发生顺序，将另一个cancel和reset掉。

==== clear_trigger

clear_trigger用以在之前已经使用next_trigger设置过trigger条件的情况下，再次调用
next_trigger时候的状态清除动作：

.src/sysc/kernel/sc_method_process.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_method_process::clear_trigger"
//
// This method clears any pending trigger for this object instance.
//------------------------------------------------------------------------------
void sc_method_process::clear_trigger()
{
    switch( m_trigger_type ) {
      case STATIC:
        return;
      case EVENT:
        m_event_p->remove_dynamic( this );
        m_event_p = 0;
        break;
      case OR_LIST:
        m_event_list_p->remove_dynamic( this, 0 );
        m_event_list_p->auto_delete();
        m_event_list_p = 0;
        break;
      case AND_LIST:
        m_event_list_p->remove_dynamic( this, 0 );
        m_event_list_p->auto_delete();
        m_event_list_p = 0;
        m_event_count = 0;
        break;
      case TIMEOUT:
        m_timeout_event_p->cancel();
        m_timeout_event_p->reset();
        break;
      case EVENT_TIMEOUT:
        m_timeout_event_p->cancel();
        m_timeout_event_p->reset();
        m_event_p->remove_dynamic( this );
        m_event_p = 0;
        break;
      case OR_LIST_TIMEOUT:
        m_timeout_event_p->cancel();
        m_timeout_event_p->reset();
        m_event_list_p->remove_dynamic( this, 0 );
        m_event_list_p->auto_delete();
        m_event_list_p = 0;
      break;
      case AND_LIST_TIMEOUT:
        m_timeout_event_p->cancel();
        m_timeout_event_p->reset();
        m_event_list_p->remove_dynamic( this, 0 );
        m_event_list_p->auto_delete();
        m_event_list_p = 0;
        m_event_count = 0;
        break;
    }
    m_trigger_type = STATIC; <1>
}
----
<1> clear_trigger的结果一定是重置本method process为静态敏感

clear_trigger的代码需要结合不同的trigger type来看。

如果之前使用next_trigger，使用一个sc_event作为trigger，那么trigger type设置为 `EVENT` 。
调用clear_trigger的时候，需要从这个sc_event的动态列表中移除这个method handle，然后
将method handle中的m_event_p指针置为空。

如果之前使用next_trigger，使用一个event的or list作为trigger，那么trigger type
设置为 `OR_LIST` 。使用clear_trigger的时候，首先调用m_event_list_p的
<<api::sc_event_list::remove_dynamic, remove_dynamic>>成员函数，并将
第二个参数设置为0，以此从or list中所有事件中的dynamic method列表中移除当前method
process handle。接下来调用m_event_list_p的auto_delete，完成资源回收，并将指针置为空。

如果之前使用next_trigger，使用一个event的and list作为trigger，那么trigger type
设置为 `AND_LIST`。使用clear_trigger的时候，所需要的动作和 `OR_LIST`
基本一致，多出来的一步是将m_event_count清除为0. 这个计数器是用来数有多少事件发生的，这是因为
and_list需要每个事件发生才算完成。

如果之前使用next_trigger，设置了延时时间，那么trigger type设置为 `TIMEOUT`。
使用clear_trigger的时候，首先调用内部事件对象m_timeout_event_p
的<<api::sc_event::cancel, cancel>>，然后调用
<<api::sc_event::reset, reset>>重置这个事件对象。

其他几种trigger type，例如 `EVENT_TIMEOUT`, `OR_LIST_TIMEOUT`, `AND_LIST_TIMEOUT` ，
调用clear_trigger的时候所需的动作等于两种类型的组合，这里就不再分析了。

==== 小结

next_trigger并不会阻塞method process的执行。如果在一次method process中，多次
执行next_trigger，则以最后一次next_trigger调用为准。这意味着我们如果next_trigger
设定多个延时时间，那么结果是以最后一次设定的延时时间为准，而不像sc_event的notify一样
以离此刻最近的时间为准，这是需要注意的一点。