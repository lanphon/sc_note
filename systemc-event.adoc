:source-highlighter: coderay

:toc: left

SystemC中的Event
[[chap::event]]

== 引言

在之前的介绍中，我们已经看到了sc_event的重要作用。本部分我们对sc_event的设计和相关的API再做一次回顾，
探究其中的设计模式和设计原理。本部分也一并回顾了SystemC的wait/next_trigger API，并进行深入挖掘。

== sc_event_list以及派生类

多个sc_event可以组成and/or list，这些复杂的sc_event表达式的结果是保存在sc_event_list以及派生类
中的。

IEEE的SystemC规范建议用户不要直接使用sc_event_list以及派生类，而仅仅将他们作为函数的参数
来使用。这些 sc_event_list/sc_event_and_list/sc_event_or_list应当是使用 `operator |`
或者 `operator &` 时候，作为临时变量创建出来，并在使用后销毁的。

=== sc_event_list
[[data::sc_event_list]]

sc_event_list是个基础类，没有继承自其他任何部分。对于一个sc_event_list而言，重要
的成员变量包括：

.src/sysc/kernel/sc_event.h
[source,cpp]
----
    std::vector<const sc_event*> m_events;
    bool                         m_and_list;
    bool                         m_auto_delete;
    mutable unsigned             m_busy;
----

从成员变量可以看出，sc_event_list是一个保存多个sc_event指针的数组结构。sc_event_list
一般是临时创建的，用来为wait/next_trigger服务的对象，因此内部有一个 `m_auto_delete`
的成员变量，表明是否自动回收sc_event_list本身。

sc_event_list采取一种类似于引用计数的方式。每次调用 `sc_event_list::add_dynamic`
成员函数，将一个method/thread process handle设置为**所有**保存的
event的动态敏感handle时候，计数器 `m_busy` 都会自加。而当调用 `auto_delete`
函数的时候，首先将计数器 `m_busy` 自减。
[[api::sc_event_list::add_dynamic]]

.src/sysc/kernel/sc_event.cpp
[source,cpp]
----
void
sc_event_list::add_dynamic( sc_method_handle method_h ) const
{
    m_busy++; <1>
    if ( m_events.size() != 0 ) {
      const sc_event* const * l_events = &m_events[0];
      for( int i = m_events.size() - 1; i >= 0; -- i ) {
          l_events[i]->add_dynamic( method_h ); <2>
      }
  }
}

void
sc_event_list::add_dynamic( sc_thread_handle thread_h ) const
{
    m_busy++; <1>
    if ( m_events.size() != 0 ) {
      const sc_event* const* l_events = &m_events[0];
      for( int i = m_events.size() - 1; i >= 0; -- i ) {
          l_events[i]->add_dynamic( thread_h ); <2>
      }
  }
}
----
<1> 自加计数器 `m_busy`
<2> sc_event_list的add_dynamic，实际上就是对于保存的每个event都调用add_dynamic

从 `sc_event_list::add_dynamic` 的实现代码中，我们也可以看出，对于sc_event_list
保存的每个sc_event对象，他们之间更多的是**或**的关系：只要有一个事件发生，就会调度
相对应的process handle的trigger_dynamic函数。而区分这些event究竟是“与”还是“或”
关系，就取决于thread/method process中的<<sc_process_b::trigger_dynamic, trigger_dynamic>>函数了。
u

如果自减的结果等于0，并且设置为自动删除，就会
`delete this` 的方式自动删除本身所占用的资源。
[[api::sc_event_list::auto_delete]]

.src/sysc/kernel/sc_event.h
[source,cpp]
----
inline
void
sc_event_list::auto_delete() const
{
    if( m_busy ) {
        --m_busy;
    }
    if( ! m_busy && m_auto_delete ) {
        delete this;
    }
}
----

`sc_event_list::auto_delete` 是sc_event_list的内部函数，只用在 sc_event_list
自己的拷贝构造函数，以及拷贝赋值函数中：

.src/sysc/kernel/sc_event.h
[source,cpp]
----
inline
sc_event_list::sc_event_list( sc_event_list const & that )
  : m_events()
  , m_and_list( that.m_and_list )
  , m_auto_delete( false )
  , m_busy( 0 )
{
    move_from( that );
    that.auto_delete(); // free automatic lists
}

inline
sc_event_list&
sc_event_list::operator=( sc_event_list const & that )
{
    if( m_busy )
        report_invalid_modification();

    if( SC_LIKELY_(this != &that) ) {
        move_from( that );
        that.auto_delete(); // free automatic lists
    }

    return *this;
}
----

在拷贝构造函数和拷贝赋值函数中使用 `sc_event_list::auto_delete` ，更多的作用是实现了
资源管理的自动释放。

=== sc_event_expr<T>

在介绍sc_event_list的两个派生类，sc_event_and_list和sc_event_or_list之前，我们先
学习下sc_event_expr<T>。sc_event_expr<T>并不继承自sc_event_list。

sc_event_expr<T>是一个模板类，模板的参数可以是sc_event_and_list，别名是sc_event_and_expr，
或者是sc_event_or_list（别名sc_event_or_expr）：

.src/sysc/kernel/sc_event.h
[source,cpp]
----
typedef sc_event_expr<sc_event_and_list> sc_event_and_expr;

typedef sc_event_expr<sc_event_or_list> sc_event_or_expr;
----

sc_event_expr<T> 内部保存一个指向类型T的指针，并且设计了一些成员函数（尤其是push_back），转发
给内部的T类型成员变量。

sc_event_expr<T> 模板的功能表现的就如同其内部类型T一样。之所以这么设计一个这样的模板，是因为
`&` 和 `|` 作为二元运算符，具有左结合的特点。具体的实现细节有待深究。

=== sc_event_and_list
[[data::sc_event_and_list]]

sc_event_and_list直接继承自sc_event_list:

.src/sysc/kernel/sc_event.h
[source,cpp]
----
class SC_API sc_event_and_list
: public sc_event_list
----

相比于基类sc_event_list, sc_event_and_list并没有增加任何其他的成员变量。sc_event_and_list
更多的是增加了几个成员函数，尤其是 `operator &` ，以方便创建 `sc_event_and_list` :

.src/sysc/kernel/sc_event.h
[source,cpp]
----
    sc_event_and_list& operator &= ( const sc_event& );
    sc_event_and_list& operator &= ( const sc_event_and_list & );

    sc_event_expr<sc_event_and_list>  operator & ( const sc_event& );
    sc_event_expr<sc_event_and_list>  operator & ( const sc_event_and_list& );
----

这四个关于 `operator &=` 和 `operator &` 的重载，才是 `sc_event_and_list` 的核心所在。

注意，在 `operator &` 中，返回值类型不是 `sc_event_and_list` ，而是一个 `sc_event_expr<sc_event_and_list>` ，也就是 `sc_event_and_expr` 类型。
这么设计的原因我暂时还没有想到，希望以后能有所发现。

假设我们有一系列 `sc_event e0, e1, e2, e3` ，那么 `e0 & e1 & e2 & e3`
按照左结合律的特点，应当是 `(((e0 & e1) & e2) & e3)` 。 `e0 & e1` 调用
`sc_event::operator &` ，返回一个 `sc_event_and_expr`。接下来
`& e2` 则调用的是自由函数 `sc_event_and_expr operator &(sc_event_and_expr, sc_event&)`
，同样返回一个 `sc_event_and_expr` ，依次类推。当 `sc_event_and_expr` 用在
wait/next_trigger函数中时，其定义的 `operator T const &()` 可以自动
转换为类型 `sc_event_and_list`

''''


仅仅从sc_event.h头文件来看，sc_event_and_list似乎并没有实现字面意义上的and功能。与之后要介绍的sc_event_or_list
相比，sc_event_and_list唯一的区别是初始化时，将基类sc_event_list中的成员变量 `m_and_list`
设置为true，但sc_event_or_list设置这个成员变量为false. 然而这个成员变量，以及返回这个成员变量
值的成员函数 `sc_event_list::and_list()`，却从未使用过。

实际上， `sc_event_list::m_and_list` 这个成员变量的确没有使用过。在SystemC中，process
动态调度的时候，是直接根据 wait/next_trigger的类型判断的。例如 
<<sc_process_b::trigger_dynamic, `sc_thread_process::trigger_dynamic`>>
代码的片段如下：


.src/sysc/kernel/sc_thread_process.cpp
[source,cpp]
----
    switch( m_trigger_type )
    {
      case EVENT:
	m_event_p = 0;
	m_trigger_type = STATIC;
	break;

      case AND_LIST: <1>
        -- m_event_count;
	if ( m_event_count == 0 )
	{
	    m_event_list_p->auto_delete();
	    m_event_list_p = 0;
	    m_trigger_type = STATIC;
	}
	else
	{
	    return true;
	}
	break;

      case OR_LIST: <1>
	m_event_list_p->remove_dynamic( this, e );
	m_event_list_p->auto_delete();
	m_event_list_p = 0;
	m_trigger_type = STATIC;
	break;
----
<1> 当使用 `sc_event_and_list` 作为 wait(对于thread而言)/next_trigger(对于method而言)
参数是， `m_trigger_type` 设置为 `AND_LIST` 。如果使用 `sc_event_or_list` 则设置
为 `OR_LIST`

=== sc_event_or_list
[[data::sc_event_or_list]]

和sc_event_and_list一样，sc_event_or_list继承自sc_event_list，并且没有
增加任何其他的成员变量：

.src/sysc/kernel/sc_event.h
[source,cpp]
----
class SC_API sc_event_or_list
: public sc_event_list
----

在 `sc_event_or_list` 中，也为 `operator |=` 和 `operator |` 提供了重载的
成员函数：

.src/sysc/kernel/sc_event.h
[source,cpp]
----
    sc_event_or_list& operator |= ( const sc_event& );
    sc_event_or_list& operator |= ( const sc_event_or_list & );
    sc_event_expr<sc_event_or_list>  operator | ( const sc_event& ) const;
    sc_event_expr<sc_event_or_list>  operator | ( const sc_event_or_list& ) const;
----

需要说明的一点是，这些成员函数的实现，除了一些地方的类型不同以外，和 `sc_event_and_list`
相对应的成员函数的实现是一模一样的。
例如， `sc_event_or_list& operator |=(const sc_event_or_list &)`
与 `sc_event_and_list& operator &=(const sc_event_and_list &)`
的实现是一模一样的。
这也是理所应当的，因为无论是sc_event_and_list，还是sc_event_or_list，都只是将
一些sc_event存放起来，并提供相应的资源管理。这两个类的功能体现在
当其中一个sc_event notification时候，调用相对应的method/thread process的
<<sc_process_b::trigger_dynamic, trigger_dynamic>>地方 footnote:[根据
wait/next_trigger调用时候参数类型是sc_event_and_list还是sc_event_or_list决定trigger type]，而不在类本身。
这两个类提供这四个重载的operator，只是为了符合惯用法而已。

[NOTE]
====
在wait/next_trigger时候，`&` 和 `|` 不能混合使用，亦即我们无法创建混合and_list和or_list
类型的复杂list。现实设计中，混合and/or关系list的需求是非常非常罕见的。
====

== sc_event
[[data::sc_event]]

在<<chap::schedule_mode, 调度模型>>一章，我们已经看到了sc_event数据结构所扮演的重要角色。本部分
我们会深入系统地汇总下sc_event相关的内容。

sc_event是个基础类，没有继承自其它类。这也就意味着sc_event并没有继承自sc_object，没有
诸如hierarchy结构、框架回调函数等特性。

=== 成员变量

对于sc_event而言，成员变量包括：

.src/sysc/kernel/sc_event.h
[source,cpp]
----
    enum notify_t { NONE, DELTA, TIMED };

    std::string     m_name;     // name of object.
    sc_object*      m_parent_p; // parent sc_object for this event.
    sc_simcontext*  m_simc;
    sc_dt::uint64   m_trigger_stamp; // delta of last trigger
    notify_t        m_notify_type;
    int             m_delta_event_index;
    sc_event_timed* m_timed;

    mutable std::vector<sc_method_handle> m_methods_static;
    mutable std::vector<sc_method_handle> m_methods_dynamic;
    mutable std::vector<sc_thread_handle> m_threads_static;
    mutable std::vector<sc_thread_handle> m_threads_dynamic;
----

对于一个sc_event而言，最为核心的是与之关联的process handle。这些process handle分为四类：
[[data::sc_event::process_handle]]

1. 静态设置本事件为sensitive的method，存储在成员变量 `m_methods_static` 中
2. 使用 `next_trigger` 将本事件设置为动态调度敏感事件的method，存储在成员变量 `m_methods_dynamic` 中
3. 静态设置本事件为sensitive的thread(包括cthread)，存储在成员变量 `m_threads_static` 中
4. 使用 `wait` 降本事件设置为动态调度敏感事件的thread，存储在成员变量 `m_threads_dynamic` 中

一个sc_event，可以是DELTA EVENT，此时 `m_notify_type` 为 `DELTA` 。DELTA EVENT
在<<concept::crunch, simc的crunch>>函数中的NOTIFICATION阶段trigger。
sc_event也可以是TIMED EVENT，即 `m_notify_type` 为 `TIMED` 。 TIMED EVENT
在<<concept::timed_event, simc的simulate>>函数中，crunch运行完之后的仿真时间前进
部分trigger。无论哪种情况下，trigger完的EVENT进入NONE状态，将 `m_notify_type`
标记为 `NONE`.

成员变量 `m_delta_event_index` 用以标记当本sc_event为DELTA EVENT时，
在本次delta cycle中的delta event列表中的索引值。这个成员变量本身只赋值，没有在
其他地方用到。

成员变量 `m_timed` 则用以标记当本sc_event为TIMED EVENT时，notification
的**绝对时间**。这里记录的绝对时间是调用 `notify()` 成员函数设置延迟时间
的时候，将所设置的延迟时间加上当前仿真时间得到的。

`m_trigger_stamp` 成员变量则用以记录sc_event上一次被trigger时候的时间戳。
这个时间戳并不对应仿真时间，而是有着比仿真时间更精细的粒度，记录的是delta cycle
级别的时间戳。在有些场景下，这个时间戳可以用来判断sc_event是否在上个delta cycle
被trigger，已进行相关的动作。

成员变量 `m_name`, `m_simc` 以及 `m_parent_p` 主要用以记录sc_event
相关的场景信息，以提供DEBUG能力。

=== 构造和析构函数

sc_event可以是空构造，也可以给定本事件的名字。对于sc_event而言，名字并非必须，
可以为空。

除了普通构造和给定名字构造以外，sc_event还有一个PRIVATE的构造函数：
[[concept::event::kernel_event]]

.src/sysc/kernel/sc_event.h
[source,cpp]
----
private:
    static struct kernel_tag {} kernel_event;
    explicit sc_event( kernel_tag, const char* name = NULL );
----

这个构造函数主要用来创建SystemC仿真器内部的事件，以及一些数据结构的内置事件对象。例如
sc_fifo中的write event和read event都属于使用这种方式创建的kernel event。
这个构造函数被标记为PRIVATE，因此只有sc_event的友元类才可以访问这个函数，创建
kernel event，这局限了这种构造函数的使用场景。对于kernel event，我们只需要
了解即可。

在构造函数中，sc_event会调用成员函数 `register_event` 将自己注册都
SystemC的内核中。这个注册动作主要是做一些hierarchy管理行为，例如将sc_event
名字加入到名城管理系统中，将sc_event本身加入所属的父模块的child event列表中等动作。
对于kernel event则不做这些，可以认为kernel event游离于SystemC管理普通
sc_event的体系之外，这也是称之为kernel event的原因。
[[api::sc_event::register_event]]

.src/sysc/kernel/sc_event.cpp
[source,cpp]
----
// +----------------------------------------------------------------------------
// |"sc_event::register_event"
// |
// | This method sets the name of this object instance and optionally adds
// | it to the object manager's hierarchy. The object instance will be
// | inserted into the object manager's hierarchy if one of the following is
// | true:
// |   (a) the leaf name is non-null and is_kernel_event == false
// |   (b) the event is being created before the start of simulation.
// |
// | Arguments:
// |     leaf_name = leaf name of the object or NULL.
// +----------------------------------------------------------------------------
void
sc_event::register_event( const char* leaf_name, bool is_kernel_event /* = false */ )
{
    sc_object_manager* object_manager = m_simc->get_object_manager();
    m_parent_p = m_simc->active_object();

    // No name provided, if we are not executing then create a name:

    if( !leaf_name || !leaf_name[0] ) <1>
    {
        if ( sc_is_running( m_simc ) ) return;
        leaf_name = sc_gen_unique_name
            ( is_kernel_event ? SC_KERNEL_EVENT_PREFIX : "event" );
    }

    // prepend kernel events with internal prefix
    else if ( is_kernel_event ) <2>
    {
        m_name = SC_KERNEL_EVENT_PREFIX;
        m_name.append( leaf_name );
        leaf_name = m_name.c_str();
    }

    // Create a hierarchichal name and place it into the object manager if
    // its not a kernel event:

    object_manager->create_name( leaf_name ).swap( m_name );

    if ( !is_kernel_event ) <3>
    {
	object_manager->insert_event(m_name, this);
	if ( m_parent_p )
	    m_parent_p->add_child_event( this );
	else
	    m_simc->add_child_event( this );
    }
}
----
<1> 如果给定的名字为空，那么SystemC会自己创建一个名字
<2> 对于kernel event，名字的命名有着特殊的方法
<3> 非kernel event才会加入object manager以及hierarchy结构中


拷贝构造函数和赋值构造函数被标记为PRIVATE，并且未实现，这意味着sc_event不允许拷贝
或者赋值。

sc_event在构造函数中需要注册自己，并分配一些资源，所以sc_event的析构函数
是非空的。

.src/sysc/kernel/sc_event.cpp
[source,cpp]
----
// +----------------------------------------------------------------------------
// |"sc_event::~sc_event"
// |
// | This is the object instance destructor for this class. It cancels any
// | outstanding waits and removes the event from the object manager's
// | instance table if it has a name.
// +----------------------------------------------------------------------------
sc_event::~sc_event()
{
    cancel();
    if ( m_name.length() != 0 )
    {
	sc_object_manager* object_manager_p = m_simc->get_object_manager();
	object_manager_p->remove_event( m_name );
    }

    for(size_t i = 0; i < m_threads_dynamic.size(); ++i ) {
        if( m_threads_dynamic[i]->m_event_p == this )
            m_threads_dynamic[i]->m_event_p = 0;
    }
    for(size_t i = 0; i < m_methods_dynamic.size(); ++i ) {
        if( m_methods_dynamic[i]->m_event_p == this )
            m_methods_dynamic[i]->m_event_p = 0;
    }
}
----

析构函数主要完成了分配资源的释放。此外，对于动态等待在本事件上的process handle而言，
还需要把内部保存的事件指针 `m_event_p` 置为空。

=== 与process handle交互的成员函数

sc_event提供了8个成员函数，以用来与process handle做交互。这个8个成员函数分为两组，分别为
为本事件添加process handle，以及为本事件删除process handle。sc_event中保存process
handle的成员变量一共有四个，所以每一组对应的成员函数也有4个:

.src/sysc/kernel/sc_event.h
[source,cpp]
----
    void add_static( sc_method_handle ) const;
    void add_static( sc_thread_handle ) const;
    void add_dynamic( sc_method_handle ) const;
    void add_dynamic( sc_thread_handle ) const;

    bool remove_static( sc_method_handle ) const;
    bool remove_static( sc_thread_handle ) const;
    bool remove_dynamic( sc_method_handle ) const;
    bool remove_dynamic( sc_thread_handle ) const;
----

这8个成员函数的实现是比较简单的。 `add_*` 只是简单地将函数参数放入对应的成员变量中。
`remove_*` 检索对应的成员边来那个，如果存在则去除。

这四个函数可以在elaboration阶段，或者simulation阶段被调用。


=== notify, trigger和cancel

一个sc_event，最为重要的就是状态的管理，包括notify（通知事件发生/延迟发生），trigger
（触发事件发生时的作用）以及cancel（取消之前设定的事件发生/延迟发生）。

==== notify
[[api::sc_event::notify]]

首先是notify。sc_event提供了多种notify方式，以满足不同的需求。

第一种notify是不带任何参数的notify。这种notify的语义定义是，事件立刻发生。

.src/sysc/kernel/sc_event.cpp
[source,cpp]
----
void
sc_event::notify()
{
    // immediate notification
    if( !m_simc->evaluation_phase() )
        // coming from
        //  * elaboration
        //  * sc_prim_channel::update
        //  * phase callbacks
    {
        SC_REPORT_ERROR( SC_ID_IMMEDIATE_NOTIFICATION_, "" );
        return;
    }
    cancel();
    trigger();
}
----

这种notify会在调用<<api::sc_event::cancel, cancel>>之后，立刻调用<<api::sc_event::trigger, trigger>>函数，作为事件发生的作用。因此这就带来一个可能的竞争问题：如果
动态敏感的process handle，调度的顺序在这个函数调用之前，那么相对应的process handle
就已经加入到事件保存的process handle中，不带参数的notify可以trigger这些process handle。反之，
如果这些process handle调度顺序在这个函数调用之后，那么相对应的process handle此刻是没有
加入到事件的process handle列表中的，不带参数的notify无法trigger这些process handle。然而，调度
的顺序是无法预测的，我们无法依靠调度的顺序来决定仿真的行为。

为了避免出现这种情况，SystemC建议用户不要在自己的代码中使用不带参数的notify。对于SystemC自己
而言，其内部的实现框架可保证顺序，所以不带参数的notify可以在Systemc内部使用。

第二种是带有时间参数的notify函数：

.src/sysc/kernel/sc_event.h
[source,cpp]
----
    void notify( const sc_time& );
    void notify( double, sc_time_unit );
----

带有延迟时间参数的notify函数，从语义上定义是，在给定的延迟时间之后，事件发生。
一个特殊的延迟时间, `SC_ZERO_TIME` ，可以用来从语义上定义事件**立刻**发生。
对于延迟时间设定为SC_ZERO_TIME的notify，事件将会被标记为delta event，从而
借助 <<concept::crunch, simc的crunch>>函数中的EVALUATE-UPDATE-NOTIFICATION
机制，在下一个delta cycle调度阻塞在本事件上的process handle。

当所设定的延迟时间不是 `SC_ZERO_TIME` 的时候，事件标记为timed event，进入
simc中的timed event列表。在仿真时间走到所标记的时间的时候，事件发生。

sc_event的延迟时间时可以反复设定的，而在sc_event内部，只保存距离当前时间最近的
设定延迟时间。

.src/sysc/kernel/sc_event.cpp
[source,cpp]
----
void
sc_event::notify( const sc_time& t )
{
    if( m_notify_type == DELTA ) {
        return; <1>
    }
    if( t == SC_ZERO_TIME ) {
#       if SC_HAS_PHASE_CALLBACKS_
            if( SC_UNLIKELY_( m_simc->get_status()
                              & (SC_END_OF_UPDATE|SC_BEFORE_TIMESTEP) ) )
            {
                std::stringstream msg;
                msg << m_simc->get_status()
                    << ":\n\t delta notification of `"
                    << name() << "' ignored";
                SC_REPORT_WARNING( SC_ID_PHASE_CALLBACK_FORBIDDEN_
                                 , msg.str().c_str() );
                return;
            }
#       endif
        if( m_notify_type == TIMED ) { <2>
            // remove this event from the timed events set
            sc_assert( m_timed != 0 );
            m_timed->m_event = 0;
            m_timed = 0;
        }
        // add this event to the delta events set
        m_delta_event_index = m_simc->add_delta_event( this );
        m_notify_type = DELTA;
        return;
    }
#   if SC_HAS_PHASE_CALLBACKS_
        if( SC_UNLIKELY_( m_simc->get_status()
                        & (SC_END_OF_UPDATE|SC_BEFORE_TIMESTEP) ) )
        {
            std::stringstream msg;
            msg << m_simc->get_status()
                << ":\n\t timed notification of `"
                << name() << "' ignored";
            SC_REPORT_WARNING( SC_ID_PHASE_CALLBACK_FORBIDDEN_
                             , msg.str().c_str() );
            return;
        }
#   endif
    if( m_notify_type == TIMED ) {
        sc_assert( m_timed != 0 );
        if( m_timed->m_notify_time <= m_simc->time_stamp() + t ) { <3>
            return;
        }
        // remove this event from the timed events set
        m_timed->m_event = 0;
        m_timed = 0;
    }
    // add this event to the timed events set
    sc_event_timed* et = new sc_event_timed( this, m_simc->time_stamp() + t ); <4>
    m_simc->add_timed_event( et );
    m_timed = et;
    m_notify_type = TIMED;
}
----
<1> 如果事件已经是一个delta event，那么无论设置的延迟时间是多少，都无法设置进来，因为delta event
是零延时的，没有比这更短的延时了
<2> 如果事件是一个timed event，延迟时间设定为SC_ZERO_TIME将会导致事件变成delta event，这需要
删除之前创建的成员变量 `m_timed`
<3> 事件是timed event，且设定的延迟时间大于之前设定的时间，直接忽略
<4> 事件是timed event，且设定的延迟时间小于之前设定的时间，重新设置事件发生的绝对时刻

第三种是一系列 `notify_delayed` 函数。这些函数都已经被标记为废弃了，仅仅是为了兼容性目的而继续保留。
这里我们就不再讨论这些deprecated函数。 `notify_delayed` 函数的功能可以被 `notify` 完全取代。


.src/sysc/kernel/sc_event.h
[source,cpp]
----
    void notify_delayed();
    void notify_delayed( const sc_time& );
    void notify_delayed( double, sc_time_unit );
----

带延时时间参数的notify是提供给用户的API,因为无法保证用户的使用方法,实现的时候需要考虑
同一个事件被多次设定延时时间的场景.在SystemC内部，事件也得到广泛应用。在这种
受控的长江下，SystemC特意设计了两个notify函数，来简化相关代码的处理。

[[api::sc_event::notify_internal]]
`notify_internal` 是SystemC用以在内部设置事件延迟时间的API。这个API由于只在内部使用，
可以保证在事件真正发生之前，延时时间不会被反复设定，因此实现代码非常简单：

.src/sysc/kernel/sc_event.h
[source,cpp]
----
inline
void
sc_event::notify_internal( const sc_time& t )
{
    if( t == SC_ZERO_TIME ) {
        // add this event to the delta events set
        m_delta_event_index = m_simc->add_delta_event( this );
        m_notify_type = DELTA;
    } else {
        sc_event_timed* et =
		new sc_event_timed( this, m_simc->time_stamp() + t );
        m_simc->add_timed_event( et );
        m_timed = et;
        m_notify_type = TIMED;
    }
}
----

基本上就是用户API形式的缩水版，去掉了处理延时时间被多次设定相关的代码。此外，在SystemC内部，
事件立即发生也是一个非常重要的使用场景，为此，sc_event提供了成员函数 `notify_next_delta`

.src/sysc/kernel/sc_event.h
[source,cpp]
----
inline
void
sc_event::notify_next_delta()
{
    if( m_notify_type != NONE ) {
        SC_REPORT_ERROR( SC_ID_NOTIFY_DELAYED_, 0 );
    }
    // add this event to the delta events set
    m_delta_event_index = m_simc->add_delta_event( this );
    m_notify_type = DELTA;
}
----

[[api::sc_event::notify_next_delta]]
`notify_next_delta` 可以在EVALUATE或者UPDATE PHASE调用，这是保证安全的。

`notify_internal` 和 `notify_next_delta` 是SystemC内部使用的，因此两个函数
都被标记为PRIVATE，只有友元类才能够使用。

=== trigger

[[api::sc_event::trigger]]

sc_event的trigger函数一般在<<phase::notification, NOTIFICATION>>阶段被调用，或者
在一个crunch结束之后，下一个crunch开始之前被调用。

trigger函数可以将调用wait阻塞在本事件上的动态thread/cthread，调用next_trigger设置下次
动态调度时机的method，以及将本事件作为静态敏感事件注册的method/thread/cthread，放入
<<concept::runnable, simc的runnable>>列表中。并不是所有存在<<data::sc_event::process_handle, process handle列表>>
中的method/thread/cthread都会被放入runnable列表中。trigger函数只是直接调用这些
保存的process handle的trigger_static/trigger_dynamic方法，由这些process handle
自行判断是否满足条件。

.src/sysc/kernel/sc_event.cpp
[source,cpp]
----
// +----------------------------------------------------------------------------
// |"sc_event::trigger"
// |
// | This method "triggers" this object instance. This consists of scheduling
// | for execution all the processes that are schedulable and waiting on this
// | event.
// +----------------------------------------------------------------------------
void
sc_event::trigger()
{
    m_trigger_stamp = m_simc->change_stamp(); <1>
    m_notify_type = NONE; <2>
    m_delta_event_index = -1;
    m_timed = 0;

    int       last_i; // index of last element in vector now accessing.
    int       size;   // size of vector now accessing.


    // trigger the static sensitive methods

    if( ( size = m_methods_static.size() ) != 0 )
    {
        sc_method_handle* l_methods_static = &m_methods_static[0];
        int i = size - 1;
        do {
            sc_method_handle method_h = l_methods_static[i];
            method_h->trigger_static(); <3>
        } while( -- i >= 0 );
    }

    // trigger the dynamic sensitive methods


    if( ( size = m_methods_dynamic.size() ) != 0 )
    {
	last_i = size - 1;
	sc_method_handle* l_methods_dynamic = &m_methods_dynamic[0];
	for ( int i = 0; i <= last_i; i++ )
	{
	    sc_method_handle method_h = l_methods_dynamic[i];
	    if ( method_h->trigger_dynamic( this ) ) <4>
	    {
		l_methods_dynamic[i] = l_methods_dynamic[last_i];
		last_i--;
		i--;
	    }
	}
        m_methods_dynamic.resize(last_i+1);
    }


    // trigger the static sensitive threads

    if( ( size = m_threads_static.size() ) != 0 )
    {
        sc_thread_handle* l_threads_static = &m_threads_static[0];
        int i = size - 1;
        do {
            sc_thread_handle thread_h = l_threads_static[i];
            thread_h->trigger_static(); <3>
        } while( -- i >= 0 );
    }

    // trigger the dynamic sensitive threads

    if( ( size = m_threads_dynamic.size() ) != 0 )
    {
	last_i = size - 1;
	sc_thread_handle* l_threads_dynamic = &m_threads_dynamic[0];
	for ( int i = 0; i <= last_i; i++ )
	{
	    sc_thread_handle thread_h = l_threads_dynamic[i];
	    if ( thread_h->trigger_dynamic( this ) ) <4>
	    {
		l_threads_dynamic[i] = l_threads_dynamic[last_i];
		i--;
		last_i--;
	    }
	}
        m_threads_dynamic.resize(last_i+1);
    }
}
----
<1> 每次sc_event的trigger被调用的时候，都会保存下当前的delta cycle stamp
<2> sc_event的trigger被调用后，本sc_event变为一个NONE类型的sc_event
<3> 将本事件设置为静态敏感事件的method/thread process，调用其trigger_static成员函数
<4> 降本事件设置为东太敏感的method/thread process，调用trigger_dynamic，如果dynamic
trigger成功，则从本sc_event的process handle列表中移除此process

一个process handle可以同时存在于静态和动态列表中。这个时候需要此process自己判断情况。一般而言，
此时process handle的trigger_static只会简单返回，不作任何动作，而由trigger_dynamic来做
判断动作。

还有一个比较有趣的地方在于，如果一个process handle将sc_event设置为静态敏感事件，且没有动态
阻塞在这个事件上，那么当这个事件发生的时候，process handle的trigger_static会将这个
process加入到runnable列表中（thread/cthread可能设置多个cycle之后）。然而在使用的时候，
一个process handle可以设置多个静态敏感事件。所以，静态敏感事件之间是**或**的关系。一个可能的
想法是使用 `sc_event_and_list` 为process设置静态敏感事件，然而这种做法比较丑陋且不推荐。

=== cancel and reset
[[api::sc_event::cancel]]

sc_event还提供了一个cancel的成员函数，这个成员函数可以在一个delta事件发生的之后，被调用
trigger起作用之前，或者timed事件到达设定时间之前，将sc_event clear掉状态。

.src/sysc/kernel/sc_event.cpp
[source,cpp]
----
void
sc_event::cancel()
{
    // cancel a delta or timed notification
    switch( m_notify_type ) {
    case DELTA: {
        // remove this event from the delta events set
        m_simc->remove_delta_event( this ); <1>
        m_notify_type = NONE;
        break;
    }
    case TIMED: {
        // remove this event from the timed events set
        sc_assert( m_timed != 0 );
        m_timed->m_event = 0; <2>
        m_timed = 0;
        m_notify_type = NONE;
        break;
    }
    default:
        ;
    }
}
----
<1> 对于delta event，需要将其从simc的delta event列表中移除
<2> 对于timed event，只需要将延迟时间清除掉，标记为NONE即可

[[api::sc_event::reset]]
sc_event提供了一个reset成员函数，将本sc_event的数据结构清除掉:

.src/sysc/kernel/sc_event.cpp
[source,cpp]
----
sc_event::reset()
{
    m_notify_type = NONE;
    m_delta_event_index = -1;
    m_timed = 0;
    // clear the dynamic sensitive methods
    m_methods_dynamic.resize(0);
    // clear the dynamic sensitive threads
    m_threads_dynamic.resize(0);
}
----

注意reset()只清除动态敏感的method和thread process handle。静态敏感的process列表
仍然保留。