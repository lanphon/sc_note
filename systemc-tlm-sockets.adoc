:source-highlighter: coderay

:toc: left

SystemC中的TLM 2.0 Sockets
[[chap::tlm_sockets]]

== 引言

在<<chap::tlm_intro, SystemC中的TLM介绍>>部分，我们简单介绍了TLM中常用的
一些数据结构，包括initiator socket和target socket的定义，但这些仍然不足以支持
我们建立一个可运行的仿真环境，我们还缺少具体的实现细节。为此，TLM 2.0种设计了三种类型
的socket，来方便使用者直接使用。这三种类型的soekct分别是

* simple socket
* passthrough socket
* multi socket

而在本部分，我们将逐个介绍者三种socket的实现细节。

== convenience_socket_base

convenience_socket_base是一个纯虚的基类，用来实现一些辅助函数：
[[data::convenience_socket_base]]

.src/tlm_utils/convenience_socket_bases.h
[source,cpp]
----
// implementation-defined base class helper for convenience sockets
class SC_API convenience_socket_base
{
public:
  void display_warning(const char* msg) const; <1>
  void display_error(const char* msg) const; <1>
protected:
  virtual ~convenience_socket_base(){}
private:
  virtual const char* get_report_type() const = 0; <2>
  virtual const sc_core::sc_object* get_socket() const = 0; <2>
};
----
<1> convenience_socket_base实现了display_warning和display_error两个辅助函数
<2> convenience_socket_base要求继承类实现接口函数get_report_type和get_socket

convenience_socket_base两个辅助函数display_warning和display_error的实现如下所示：

.src/tlm_utils/convenience_socket_bases.cpp
[source,cpp]
----
void
convenience_socket_base::display_warning(const char* text) const
{
  std::stringstream s;
  s << get_socket()->name() << ": " << text;
  SC_REPORT_WARNING(get_report_type(), s.str().c_str());
}

void
convenience_socket_base::display_error(const char* text) const
{
  std::stringstream s;
  s << get_socket()->name() << ": " << text;
  SC_REPORT_ERROR(get_report_type(), s.str().c_str());
}
----

注意，其中用到了接口函数get_report_type和get_socket。所以继承自convenience_socket_base
的派生类只要实现了两个接口函数，就可以方便地调用display_warning和display_error，来打印
warning和error信息了。这也是convenience_socket_base设计的初衷所在。

===  convenience_socket_cb_holder

convenience_socket_cb_holder是一个非常简单的用来持有convenience_socket_base指针
的类，这也是为何名字叫call-back holder的原因了:
[[data::convenience_socket_cb_holder]]

.src/tlm_utils/convenience_socket_bases.cpp
[source,cpp]
----
// implementation-defined base class for callback helpers
class SC_API convenience_socket_cb_holder
{
public:
  void display_warning(const char* msg) const;
  void display_error(const char* msg) const;

protected:
  explicit convenience_socket_cb_holder(convenience_socket_base* owner) <1>
    : m_owner(owner) {}

private:
  convenience_socket_base* m_owner;
};
----
<1> 构造函数只接受一个convenience_socket_base指针，然后将指针保存下来

== simple socket

=== simple_socket_base

simple_socket_base直接继承自convenience_socket_base，且只实现了一个接口函数
get_report_type，所以simple_socket_base还是一个抽象虚基类：
[[data::simple_socket_base]]

.src/tlm_utils/convenience_socket_bases.h
[source,cpp]
----
// implementation-defined base class helper for simple sockets
class SC_API simple_socket_base : public convenience_socket_base
{
  virtual const char* get_report_type() const; <1>
protected:
  void elaboration_check(const char* action) const; <2>
};
----
<1> 只实现了接口函数get_report_type，没有实现get_socket
<2> 添加了一个额外的elaboration_check的函数

simple_socket_base所实现的接口函数get_report_type，实际上只是简单返回一个字符串，标识
这是一个TLM 2.0定义的simple socket:

.src/tlm_utils/convenience_socket_bases.h
[source,cpp]
----
const char*
simple_socket_base::get_report_type() const {
  return "/OSCI_TLM-2/simple_socket";
}

void
simple_socket_base::elaboration_check(const char* action) const
{
  if (sc_core::sc_get_curr_simcontext()->elaboration_done()) {
    std::stringstream s;
    s << " elaboration completed, " << action << " not allowed";
    display_error(s.str().c_str());
  }
}
----

[[api::simple_socket_base::elaboration_check]]
此外，simple_socket_base还实现了一个elaboration_check的函数。当elaboration_check
函数被调用的时候，就会打印一个elaboration阶段的报错信息。如果elaboration_check没有
在elaboration done之后调用，则没有其他作用。这个函数主要是为了确保一些执行过程需要在elaboration
done之前发生。

=== simple_initiator_socket

simple_initiator_socket包括一系列sockets定义，同样有着一套复杂的继承关系：

* simple_initiator_socket_b继承自tlm_initiator_socket和simple_socket_base
* 从simple_initiator_socket_b，派生出
- simple_initiator_socket
- simple_initiator_socket_optional
* simple_initiator_socket_tagged_b继承自tlm_initiator_socket和simple_socket_base
* 从simple_initiator_socket_tagged_b，派生出
- simple_initiator_socket_tagged
- simple_initiator_socket_tagged_optional

我们将按照继承体系的顺序，逐步探索这些类的实现细节。

==== simple_initiator_socket_b::process

simple_initiator_socket_b::process是定义在simple_initiator_socket_b模板类
内部的一个辅助的模板类。process直接继承自<<api::tlm_bw_transport_if, tlm_bw_transport_if>>
，所以process需要实现接口函数nb_transport_bw和invalidate_direct_mem_ptr。process
类同时也继承自<<data::convenience_socket_cb_holder, convenience_socket_cb_holder>>，
其唯一的作用就是用来持有simple_initiator_socket_b本身指针。定义如下：
[[data::simple_initiator_socket_b::process]]

.src/tlm_utils/simple_initiator_socket.h
[source,cpp]
----
  class process
    : public tlm::tlm_bw_transport_if<TYPES>
    , protected convenience_socket_cb_holder
  {
  public:
    typedef sync_enum_type (MODULE::*TransportPtr)(transaction_type&,
                                                   phase_type&,
                                                   sc_core::sc_time&);
    typedef void (MODULE::*InvalidateDirectMemPtr)(sc_dt::uint64,
                                                   sc_dt::uint64);

    explicit process(simple_socket_base* owner)
      : convenience_socket_cb_holder(owner), m_mod(0)
      , m_transport_ptr(0)
      , m_invalidate_direct_mem_ptr(0)
    {
    }
    //blabla
    private:
    MODULE* m_mod;
    TransportPtr m_transport_ptr;
    InvalidateDirectMemPtr m_invalidate_direct_mem_ptr;
  };
----

为方便起见，process内部定义了两个类指针类型，分别是 `TransportPtr`
和 `InvalidateDirectMempTR`。注意，这两个类指针的类都是MODULE，这实际上是
simple_initiator_socket_b的模板参数。 构造函数中，会将传入的simple_socket_base指针
保存到convenience_socket_cb_holder父类中。构造的时候，3个成员变量都是0，即指向
MODULE的指针，以及两个成员函数指针均为空。这三个成员变量需要使用额外的
函数来进行注册才能使用，参考下边：

.src/tlm_utils/simple_initiator_socket.h
[source,cpp]
----
    void set_transport_ptr(MODULE* mod, TransportPtr p)
    {
      if (m_transport_ptr) {
        display_warning("non-blocking callback already registered");
        return;
      }
      sc_assert(!m_mod || m_mod == mod);
      m_mod = mod;
      m_transport_ptr = p;
    }

    void set_invalidate_direct_mem_ptr(MODULE* mod, InvalidateDirectMemPtr p)
    {
      if (m_invalidate_direct_mem_ptr) {
        display_warning("invalidate DMI callback already registered");
        return;
      }
      sc_assert(!m_mod || m_mod == mod);
      m_mod = mod;
      m_invalidate_direct_mem_ptr = p;
    }
----

函数 `set_transport_ptr` 和 `set_invalidate_direct_mem_ptr` 分别用来注册两个
成员函数，并且MODULE的指针也需要保持一致。这样一来，实现tlm_bw_transport_if<>接口
函数的代码也就非常简单了，基本上就是转发给注册的成员函数而已：

.src/tlm_utils/simple_initiator_socket.h
[source,cpp]
----
    sync_enum_type nb_transport_bw(transaction_type& trans, phase_type& phase, sc_core::sc_time& t)
    {
      if (m_transport_ptr) {
        // forward call
        sc_assert(m_mod);
        return (m_mod->*m_transport_ptr)(trans, phase, t);
      }
      display_error("no transport callback registered"); <1>
      return tlm::TLM_COMPLETED; <2>
    }

    void invalidate_direct_mem_ptr(sc_dt::uint64 start_range,
                                   sc_dt::uint64 end_range)
    {
      if (m_invalidate_direct_mem_ptr) {
        // forward call
        sc_assert(m_mod);
        (m_mod->*m_invalidate_direct_mem_ptr)(start_range, end_range);
      }
    }
----
<1> 调用的display_error实际调用的是基类convenience_socket_cb_holder的display_error，在实现中转发给了
持有的simple_socket_base对象的display_error函数
<2> 这里返回TLM_COMPLETED是不会走到的，如果走到就意味着系统出现错误

==== simple_initiator_socket_b

simple_initiator_socket_b是一个模板类，需要4个模板参数:

1. 对象的类型，这个对象是拥有兼容tlm_bw_transport_if接口函数为成员函数的类
2. 位宽
3. 类型，即拥有两个成员类型tlm_payload_type和tlm_phase_type的类，默认是<<api:;tlm_base_protocol_types, tlm_base_protocol_types>>
4. 作为一个sc_port时候的绑定策略
[[data::simple_initiator_socket_b]]

.src/tlm_utils/simple_initiator_socket.h
[source,cpp]
----
template< typename MODULE, unsigned int BUSWIDTH, typename TYPES
        , sc_core::sc_port_policy POL = sc_core::SC_ONE_OR_MORE_BOUND >
class simple_initiator_socket_b
  : public tlm::tlm_initiator_socket<BUSWIDTH, TYPES, 1, POL> <1>
  , protected simple_socket_base <2>
{
public:
  typedef typename TYPES::tlm_payload_type                transaction_type;
  typedef typename TYPES::tlm_phase_type                  phase_type;
  typedef tlm::tlm_sync_enum                              sync_enum_type;
  typedef tlm::tlm_fw_transport_if<TYPES>                 fw_interface_type;
  typedef tlm::tlm_bw_transport_if<TYPES>                 bw_interface_type;
  typedef tlm::tlm_initiator_socket<BUSWIDTH,TYPES,1,POL> base_type;
  // blabla
private:
  const sc_core::sc_object* get_socket() const { return this; } <3>
private:
  process m_process; <4>
};
----
<1> simple_initiator_socket_b继承自<<api::tlm_initiator_socket, tlm_initiator_socket>>, 最后两个参数1和POL用来给<<api::sc_port, sc_port>>提供参数，因为tlm_initiator_socket本身也是一个sc_port，1的含义是，如果绑定策略是SC_ALL_BOUND，那么就只能精确绑定一个。对于不是SC_ALL_BOUND绑定策略的情况，1这个数字无意义
<2> simple_initiator_socket_b同时也继承自<<data::simple_socket_base, simple_socket_base>>，注意是protected继承
<3> get_socket实现了simple_socket_base所需要的接口函数定义
<4> 唯一一个成员变量就是<<data::simple_initiator_socket_b::process, process>>了


simple_initiator_socket_b之所以需要继承simple_socket_base，是为了提供display_warning和display_error
两个用来辅助显示warning和error信息的API函数。

simple_initiator_socket_b的唯一一个成员变量是<<data::simple_initiator_socket_b::process, process>>，是一个
<<api::tlm_bw_transport_if, tlm_bw_transport_if>>的实现。

simple_initiator_socket_b的构造函数比较简单：

.src/tlm_utils/simple_initiator_socket.h
[source,cpp]
----
  static const char* default_name()
    { return sc_core::sc_gen_unique_name("simple_initiator_socket"); }

  explicit simple_initiator_socket_b(const char* n = default_name())
    : base_type(n)
    , m_process(this)
  {
    this->m_export.bind(m_process); <1>
  }
----
<1> 这个绑定是这个构造函数最为重要的一个功能

构造函数除了构造基类之外，最重要的是构造m_process成员变量，以及将本类作为一个
<<api::tlm_initiator_socket, tlm_initiator_socket>>，其m_export成员变量绑定
到m_process成员变量上。回想一下，对于tlm_initiator_socket，其成员变量m_export
是一个BW_IF的sc_export:

.tlm_base_initiator_socket的数据结构
image::tlm_base_initiator_socket.png[]

所以这样的绑定结果是，本类的基类tlm_initiator_socket的成员变量 m_export
内部持有了一个指向成员变量 m_process的指针，指针类型为 `sc_interface*`，可以被
cast成为 `tlm_bw_transport_if*` 类型，进而调用tlm_bw_transport_if所定义的
接口函数nb_transport_bw和invalidate_direct_mem_ptr。

接下来只剩下两个API函数，用来将process注册回调函数的部分同样导出来，即
register_nb_transport_bw和register_invalidate_direct_mem_ptr两个
成员函数，注意这两个成员函数的类型和prcess的同名成员函数是一样的，所以函数本身的实现
只是一个转发而已：
[[data::simple_initiator_socket_b::register_nb_transport_bw]]
[[data::simple_initiator_socket_b::register_invalidate_direct_mem_ptr]]

.src/tlm_utils/simple_initiator_socket.h
[source,cpp]
----
  void register_nb_transport_bw(MODULE* mod,
                                sync_enum_type (MODULE::*cb)(transaction_type&,
                                                             phase_type&,
                                                             sc_core::sc_time&))
  {
    m_process.set_transport_ptr(mod, cb);
  }

  void register_invalidate_direct_mem_ptr(MODULE* mod,
                                          void (MODULE::*cb)(sc_dt::uint64, sc_dt::uint64))
  {
    m_process.set_invalidate_direct_mem_ptr(mod, cb);
  }
----

---

目前为止，我们已经simple_initiator_socket_b模板代码的学习了。总的来说，
simple_initiator_socket_b本身是一个tlm_initiator_socket，其tlm_initiator_socket
的m_export绑定到内部唯一一个成员变量m_process上，而m_process则是一个
tlm_bw_transport_if的实现，所需要实现的接口函数可以通过
simple_initiator_socket_b的register_nb_transport_bw
和register_invalidate_direct_mem_ptr两个成员函数进行注册。

这样一来，对于simple_initiator_socket_b本身，作为一个tlm_initiator_socket，
get_base_interface/get_base_export所返回的BW_IF指针或者sc_export<BW_IF>，都可以
用来调用所注册的两个函数（即nb_transport_bw和invalidate_direct_mem_ptr）。这两个
函数实际保存在simple_initiator_socket_b唯一的成员变量m_process中，实际上是保存了
一个对象（对象的类型就是simple_initiator_socket_b的第一个模板参数）的指针和两个成员函数指针。

==== simple_initiator_socket

simple_initiator_socket的实现非常简单，直接继承自<<data::simple_initiator_socket_b, simple_initiator_socket_b>>。
对于基类simple_initiator_socket_b，提供了可选的模板参数BUSWIDTH和TYPES，这样POL模板参数就使用了
simple_initiator_socket_b的默认值 `sc_core::SC_ONE_OR_MORE_BOUND` ，即sc_port至少要绑定一个interface
，这部分的内容参考<<api::sc_port::bind::policy, sc_port的绑定策略>>部分:
[[data::simple_initiator_socket]]

.src/tlm_utils/simple_initiator_socket.h
[source,cpp]
----
template< typename MODULE, unsigned int BUSWIDTH = 32
        , typename TYPES = tlm::tlm_base_protocol_types >
class simple_initiator_socket
  : public simple_initiator_socket_b<MODULE,BUSWIDTH,TYPES>
{
  typedef simple_initiator_socket_b<MODULE,BUSWIDTH,TYPES> socket_b;
public:
  simple_initiator_socket() : socket_b() {}
  explicit simple_initiator_socket(const char* name) : socket_b(name) {}
};
----

==== simple_initiator_socket_optional

simple_initiator_socket_optional的实现和simple_initiator_socket一样，也非常简单，直接继承
自simple_initiator_socket_b，提供了可选的模板参数BUSWIDTH和TYPES。而在基类继承的时候，为模板
参数POL提供了不同于默认值的值 `sc_core::SC_ZERO_OR_MORE_BOUND` ，这就允许simple_initiator_socket_optional
作为一个sc_port，可以绑定任意数目（包括0个）interface:
[[data::simple_initiator_socket_optional]]

.src/tlm_utils/simple_initiator_socket.h
[source,cpp]
----
template< typename MODULE, unsigned int BUSWIDTH = 32
        , typename TYPES = tlm::tlm_base_protocol_types >
class simple_initiator_socket_optional
  : public simple_initiator_socket_b<MODULE,BUSWIDTH,TYPES,sc_core::SC_ZERO_OR_MORE_BOUND>
{
  typedef simple_initiator_socket_b<MODULE,BUSWIDTH,TYPES,sc_core::SC_ZERO_OR_MORE_BOUND> socket_b;
public:
  simple_initiator_socket_optional() : socket_b() {}
  explicit simple_initiator_socket_optional(const char* name) : socket_b(name) {}
};
----

==== simple_initiator_socket_tagged_b::process

simple_initiator_socket_tagged_b内部有一个类process，实现了和
<<data::simple_initiator_socket_b::process, simple_initiator_socket_b中的process类>>
同样的功能：
[[data::simple_initiator_socket_tagged_b::process]]

.src/tlm_utils/simple_initiator_socket.h
[source,cpp]
----
  class process
    : public tlm::tlm_bw_transport_if<TYPES>
    , protected convenience_socket_cb_holder
  {
  public:
    typedef sync_enum_type (MODULE::*TransportPtr)(int, <1>
                                                   transaction_type&,
                                                   phase_type&,
                                                   sc_core::sc_time&);
    typedef void (MODULE::*InvalidateDirectMemPtr)(int, <1>
                                                   sc_dt::uint64,
                                                   sc_dt::uint64);
  // blabla
  private:
    MODULE* m_mod;
    TransportPtr m_transport_ptr;
    InvalidateDirectMemPtr m_invalidate_direct_mem_ptr;
    int m_transport_user_id; <2>
    int m_invalidate_direct_mem_user_id; <2>
  };
----
<1> 注意，成员函数指针的类型中，函数参数相比于<<data::simple_initiator_socket_b::process, simple_initiator_socket_b中的process类>>
多了第一个 `int` 型的参数
<2> 成员变量也增加了两个 `int` 型变量

process类同样继承自<<api::tlm_bw_transport_if, tlm_bw_transport_if>>和
<<data::convenience_socket_cb_holder, convenience_socket_cb_holder>>。继承自前者，意味着
需要实现接口函数nb_transport_bw和invalidate_direct_mem_ptr。继承自后者，主要是为了实现
在process内部调用display_warning和display_error函数的功能。

注意，这里的成员函数指针的类型TransportPtr和InvalidateDirectMmePtr，与
<<data::simple_initiator_socket_b::process, simple_initiator_socket_b中的process类>>
的成员函数指针类型不一样：这里的函数指针类型，都增加了第一个 `int` 型的参数。此外，成员变量
也多了两个 `int` 型的 m_transport_user_id和m_invalidate_direct_mem_user_id。

在实现tlm_bw_transport_if的时候，这两个id被用来作为相应成员函数调用时候的第一个参数：

.src/tlm_utils/simple_initiator_socket.h
[source,cpp]
----
    sync_enum_type nb_transport_bw(transaction_type& trans, phase_type& phase, sc_core::sc_time& t)
    {
      if (m_transport_ptr) {
        // forward call
        sc_assert(m_mod);
        return (m_mod->*m_transport_ptr)(m_transport_user_id, trans, phase, t); <1>
      }
      display_error("no transport callback registered");
      return tlm::TLM_COMPLETED;
    }

    void invalidate_direct_mem_ptr(sc_dt::uint64 start_range,
                                   sc_dt::uint64 end_range)
    {
      if (m_invalidate_direct_mem_ptr) {
        // forward call
        sc_assert(m_mod);
        (m_mod->*m_invalidate_direct_mem_ptr)(m_invalidate_direct_mem_user_id, start_range, end_range); <2>
      }
    }
----
<1> 调用注册的成员函数m_transport_ptr时候，传入第一个参数时保存的 `int` 型成员变量m_transport_user_id
<2> 调用注册的成员函数m_invalidate_direct_mem_ptr的时候，传入第一个参数是保存的 `int` 型成员变量m_invalidate_direct_mem_user_id

而process提供四个额外的函数，用来注册成员函数指针，以及为两个 `int` 型成员变量（也就是tag值）提供值：
[[data::simple_initiator_socket_tagged_b::process::set_transport_user_id]]
[[data::simple_initiator_socket_tagged_b::process::set_invalidate_dmi_user_id]]
[[data::simple_initiator_socket_tagged_b::process::set_transport_ptr]]
[[data::simple_initiator_socket_tagged_b::process::set_invalidate_direct_mem_ptr]]

.src/tlm_utils/simple_initiator_socket.h
[source,cpp]
----
    void set_transport_user_id(int id) { m_transport_user_id = id; }
    void set_invalidate_dmi_user_id(int id) { m_invalidate_direct_mem_user_id = id; }

    void set_transport_ptr(MODULE* mod, TransportPtr p)
    {
      if (m_transport_ptr) {
        display_warning("non-blocking callback already registered");
        return;
      }
      sc_assert(!m_mod || m_mod == mod);
      m_mod = mod;
      m_transport_ptr = p;
    }

    void set_invalidate_direct_mem_ptr(MODULE* mod, InvalidateDirectMemPtr p)
    {
      if (m_invalidate_direct_mem_ptr) {
        display_warning("invalidate DMI callback already registered");
        return;
      }
      sc_assert(!m_mod || m_mod == mod);
      m_mod = mod;
      m_invalidate_direct_mem_ptr = p;
    }
----

这四个成员函数会在
<<data::simple_initiator_socket_tagged_b::register_nb_transport_bw, simple_initiator_socket_tagged_b的register_nb_transport_bw>>
和
<<data::simple_initiator_socket_tagged_b::register_invalidate_direct_mem_ptr, simple_initiator_socket_tagged_b的register_invalidate_direct_mem_ptr>>

==== simple_initiator_socket_tagged_b

simple_initiator_socket_tagged_b，是实现带tagged功能的simple initiator socket的基础。
这个所谓的tag，实际上就是在
<<data::simple_initiator_socket_tagged_b::process, simple_initiator_socket_tagged_b::process>>
里，我们展示的那个额外的integer值。
[[data::simple_initiator_socket_tagged_b]]

simple_initiator_socket_tagged_b，和<<data::simple_initiator_socket_b, simple_initiator_socket_b>>
一样，也是继承自tlm_initiator_socket和simple_socket_base

.src/tlm_utils/simple_initiator_socket.h
[source,cpp]
----
template< typename MODULE, unsigned int BUSWIDTH, typename TYPES
        , sc_core::sc_port_policy POL = sc_core::SC_ONE_OR_MORE_BOUND >
class simple_initiator_socket_tagged_b
  : public tlm::tlm_initiator_socket<BUSWIDTH, TYPES, 1, POL> <1>
  , protected simple_socket_base <2>
{
public:
  typedef typename TYPES::tlm_payload_type                transaction_type;
  typedef typename TYPES::tlm_phase_type                  phase_type;
  typedef tlm::tlm_sync_enum                              sync_enum_type;
  typedef tlm::tlm_fw_transport_if<TYPES>                 fw_interface_type;
  typedef tlm::tlm_bw_transport_if<TYPES>                 bw_interface_type;
  typedef tlm::tlm_initiator_socket<BUSWIDTH,TYPES,1,POL> base_type;
  // blabla
private:
  const sc_core::sc_object* get_socket() const { return this; } <3>
private:
  process m_process; <4>
};
----
<1> 继承自tlm_initiator_socket
<2> 继承自simple_socket_base，主要是提供了display_warning和display_error函数的使用能力
<3> get_socket实现了simple_socket_base所定义的接口函数
<4> 拥有唯一一个成员变量，就是<<data::simple_initiator_socket_tagged_b::process, simple_initiator_socket_tagged_b::process>>

simple_initiator_socket_tagged_b的构造非常简单：

.src/tlm_utils/simple_initiator_socket.h
[source,cpp]
----
  static const char* default_name()
    { return sc_core::sc_gen_unique_name("simple_initiator_socket_tagged"); }

  explicit simple_initiator_socket_tagged_b(const char* n = default_name())
    : base_type(n)
    , m_process(this)
  {
    this->m_export.bind(m_process); <1>
  }
----
<1> 将tlm_initiator_socket的m_export绑定到m_process上

这里的绑定和<<data::simple_initiator_socket_b, simple_initiator_socket_b>>基本一样。simple_initiator_socket_tagged_b
同样提供了注册函数register_nb_trasnport_bw和register_invalidate_direct_mem_ptr，用来为m_process的成员变量提供值：

[[data::simple_initiator_socket_tagged_b::register_nb_transport_bw]]
[[data::simple_initiator_socket_tagged_b::register_invalidate_direct_mem_ptr]]

.src/tlm_utils/simple_initiator_socket.h
[source,cpp]
----
  void register_nb_transport_bw(MODULE* mod,
                                sync_enum_type (MODULE::*cb)(int,
                                                             transaction_type&,
                                                             phase_type&,
                                                             sc_core::sc_time&),
                                int id)
  {
    m_process.set_transport_ptr(mod, cb);
    m_process.set_transport_user_id(id);
  }

  void register_invalidate_direct_mem_ptr(MODULE* mod,
                                          void (MODULE::*cb)(int, sc_dt::uint64, sc_dt::uint64),
                                           int id)
  {
    m_process.set_invalidate_direct_mem_ptr(mod, cb);
    m_process.set_invalidate_dmi_user_id(id);
  }
----

只是需要注意，register_nb_transport_bw和register_invalidate_direct_mem_ptr在调用的时候就需要
提供一个 `int` 型的数据，来设置m_process中的相应的值。这个值就是所谓的tagged了。

==== simple_initiator_socket_tagged

simple_initiator_socket_tagged和
<<data::simple_initiator_socket_tagged_b, simple_initiator_socket_tagged_b>>的关系，就和
<<data::simple_initiator_socket, simple_initiator_socket>>
与 <<data::simple_initiator_socket_b, simple_initiator_socket_b>>的关系一样，只是
为模板参数提供默认值，以及为POL模板参数提供一个值SC_ONE_OR_MORE_BOUND而已：
[[data::simple_initiator_socket_tagged]]

.src/tlm_utils/simple_initiator_socket.h
[source,cpp]
----
template< typename MODULE, unsigned int BUSWIDTH = 32
        , typename TYPES = tlm::tlm_base_protocol_types >
class simple_initiator_socket_tagged
  : public simple_initiator_socket_tagged_b<MODULE,BUSWIDTH,TYPES> <1>
{
  typedef simple_initiator_socket_tagged_b<MODULE,BUSWIDTH,TYPES> socket_b;
public:
  simple_initiator_socket_tagged() : socket_b() {}
  explicit simple_initiator_socket_tagged(const char* name) : socket_b(name) {}
};
----
<1> 这里并没有指定POL，意味着使用<<data::simple_initiator_socket_tagged_b, simple_initiator_socket_tagged_b>>
默认的POL模板参数值 `sc_core::SC_ONE_OR_MORE_BOUND`

==== simple_initiator_socket_tagged_optional

simple_initiator_socket_tagged_optional和
<<data::simple_initiator_socket_tagged_b, simple_initiator_socket_tagged_b>>的关系，就和
<<data::simple_initiator_socket_optional, simple_initiator_socket_optional>>
与 <<data::simple_initiator_socket_b, simple_initiator_socket_b>>的关系一样，只是
为模板参数提供默认值，以及为POL模板参数提供一个值SC_ZERO_OR_MORE_BOUND而已：
[[data::simple_initiator_socket_tagged_optional]]

.src/tlm_utils/simple_initiator_socket.h
[source,cpp]
----
template< typename MODULE, unsigned int BUSWIDTH = 32
        , typename TYPES = tlm::tlm_base_protocol_types >
class simple_initiator_socket_tagged_optional
  : public simple_initiator_socket_tagged_b<MODULE,BUSWIDTH,TYPES,sc_core::SC_ZERO_OR_MORE_BOUND>
{
  typedef simple_initiator_socket_tagged_b<MODULE,BUSWIDTH,TYPES,sc_core::SC_ZERO_OR_MORE_BOUND> socket_b;
public:
  simple_initiator_socket_tagged_optional() : socket_b() {}
  explicit simple_initiator_socket_tagged_optional(const char* name) : socket_b(name) {}
};
----

==== simple initiator socket summary

simple initiator socket，指包括
<<data::simple_initiator_socket, simple_initiator_socket>>, 
<<data::simple_initiator_socket_optional, simple_initiator_socket_optional>>, 
<<data::simple_initiator_socket_tagged, simple_initiator_socket_tagged>>以及
<<data::simple_initiator_socket_tagged_optional, simple_initiator_socket_tagged_optional>>
这四种常用的模板类型。这些simple initiator socket都是一个<<api::tlm_initiator_socket, tlm_initiator_socket>>
，意味着这些socket本身就是一个 `sc_port<FW_IF>` ，同时也提供了一些注册回调函数的功能，来实现
BW_IF的接口函数注册。

对于simple initiator socket，使用FW_IF的接口函数时，只需要将socket本身作为 `sc_port`
看待，或者 `get_base_port`。而使用BW_IF的接口函数时，则只需要 `get_base_interface` 或者 `get_base_export`
就可以了。

simple initiator socket在使用的时候需要绑定到FW_IF上，但不再需要绑定到BW_IF上，这是因为
这些socket在内部实现了BW_IF的类。外部只需要将接口函数注册进来即可。这样一来，即使实现了
BW_IF接口函数的类不属于SystemC的对象体系，也可以通过注册回调函数的方式，参与到TLM中来，极大
扩展了SystemC的适用范围。

=== simple_target_socket

simple_target_socket，类似于simple_initiator_socket，同样由多种类型的socket组成：

* simple_target_socket_b继承自tlm_target_socket和simple_socket_base
* 从simple_target_socket_b，派生出
- simple_target_socket
- simple_target_socket_optional
* simple_target_socket_tagged_b继承自tlm_target_socket和simple_socket_base
* 从simple_target_socket_tagged_b，派生出
- simple_target_socket_tagged
- simple_target_socket_tagged_optional

但与simple_initiator_socket不同，simple_target_socket的实现更为复杂。

==== simple_target_socket_b::bw_process

bw_process是定义在模板类型simple_target_socket_b中的一个辅助类，用来处理后向通路的调用：

[[data::simple_target_socket_b::bw_process]]

.src/tlm_utils/simple_target_socket.h
[source,cpp]
----
  //Helper class to handle bw path calls
  // Needed to detect transaction end when called from b_transport.
  class bw_process : public tlm::tlm_bw_transport_if<TYPES>
  {
  public:
    bw_process(simple_target_socket_b *p_own) : m_owner(p_own)
    {
    }

  // blabla
    private:
    simple_target_socket_b *m_owner;
  };
----

bw_process直接继承自 <<api::tlm_bw_transport_if, tlm_bw_transport_if>>，有唯一一个成员变量就是
指向simple_target_socket_b的指针m_owner。

bw_process实现tlm_bw_transport_if的接口函数invalidate_direct_mem_ptr的
方式很简单，那就是直接调用simple_target_socket_b提供的接口函数
<<data::simple_target_process_b::bw_invalidate_direct_mem_ptr, simple_target_process_b::bw_invalidate_direct_mem_ptr>>:
[[data::simple_target_process_b::bw_process::invalidate_direct_mem_ptr]]

.src/tlm_utils/simple_target_socket.h
[source,cpp]
----
    void invalidate_direct_mem_ptr(sc_dt::uint64 s,sc_dt::uint64 e)
    {
      return m_owner->bw_invalidate_direct_mem_ptr(s, e);
    }
----

[[data::simple_target_process_b::bw_process::nb_transport_bw]]
然而，tlm_bw_transport_if的接口函数nb_transport_bw的实现相对而言比较复杂，虽然
也主要是借用了simple_target_socket_b的成员函数
<<data::simple_target_process_b::bw_nb_transport, bw_nb_transport>>来实现的：

.src/tlm_utils/simple_target_socket.h
[source,cpp]
----
    sync_enum_type nb_transport_bw(transaction_type &trans, phase_type &phase, sc_core::sc_time &t)
    {
      typename std::map<transaction_type*, sc_core::sc_event *>::iterator it =
        m_owner->m_pending_trans.find(&trans);

      if(it == m_owner->m_pending_trans.end()) {
        // Not a blocking call, forward.
        return m_owner->bw_nb_transport(trans, phase, t);

      }

      if (phase == tlm::END_REQ) {
        m_owner->m_end_request.notify(sc_core::SC_ZERO_TIME);
        return tlm::TLM_ACCEPTED;
      }
      if (phase == tlm::BEGIN_RESP) {
        if (m_owner->m_current_transaction == &trans) {
          m_owner->m_end_request.notify(sc_core::SC_ZERO_TIME);
        }
        //TODO: add response-accept delay?
        it->second->notify(t);
        m_owner->m_pending_trans.erase(it);
        return tlm::TLM_COMPLETED;
      }
      m_owner->display_error("invalid phase received");
      return tlm::TLM_COMPLETED;
    }
----

==== simple_target_socket_b::fw_process

[[data::simple_target_socket_b::fw_process]]

==== simple_target_socket_b

simple_target_socket_b有两个基类，一个是<<api::tlm_target_socket, tlm_target_socket>>，
另一个则是simple_socket_base，后者主要为了实现display_warning和display_error信息。
simple_target_socket_b主要继承的是tlm_target_socket的能力，从这方面审视，simple_target_socket_b
本质上是一个 <<api::sc_export, `sc_core::sc_export` >>:
[[data::simple_target_socket_b]]

.src/tlm_utils/simple_target_socket.h
[source,cpp]
----
template< typename MODULE, unsigned int BUSWIDTH, typename TYPES
        , sc_core::sc_port_policy POL = sc_core::SC_ONE_OR_MORE_BOUND >
class simple_target_socket_b
  : public tlm::tlm_target_socket<BUSWIDTH, TYPES, 1, POL> <1>
  , protected simple_socket_base <2>
{
  friend class fw_process;
  friend class bw_process;
public:
  typedef typename TYPES::tlm_payload_type              transaction_type;
  typedef typename TYPES::tlm_phase_type                phase_type;
  typedef tlm::tlm_sync_enum                            sync_enum_type;
  typedef tlm::tlm_fw_transport_if<TYPES>               fw_interface_type;
  typedef tlm::tlm_bw_transport_if<TYPES>               bw_interface_type;
  typedef tlm::tlm_target_socket<BUSWIDTH,TYPES,1,POL>  base_type;

  // blabla

private:
  const sc_core::sc_object* get_socket() const { return this; } <3>
private:
  fw_process m_fw_process;
  bw_process m_bw_process;
  std::map<transaction_type*, sc_core::sc_event *> m_pending_trans;
  sc_core::sc_event m_end_request;
  transaction_type* m_current_transaction;
};
----
<1> simple_target_socket_b主要继承自tlm_target_socket
<2> simple_target_socket_b同样继承自simple_socket_base
<3> 实现了get_socket接口函数，为基类<<data::convenience_socket_base, convenience_socket_base>>的display_warning和display_error提供获取组件名称的能力

相比于对应的 <<data::simple_initiator_socket_b, simple_initiator_socket_b>>, simple_target_socket_b的
成员变量更为复杂，这是因为simple_target_socket_b不仅要实现fw_process，还需要实现bw_process。由于需要在fw_process
中实现可能的阻塞调用和非阻塞调用之间的切换，所以simple_initiator_socket_b不得不保存非常多的数据结构，包括当前的
transaction，排队的transactions队列，以及结束请求时候发起的事件。

---

simple_target_socket_b的构造函数非常简单，可以是空的，也可以显示给定一个字符串名字：

.src/tlm_utils/simple_target_socket.h
[source,cpp]
----
public:
  static const char* default_name()
    { return sc_core::sc_gen_unique_name("simple_target_socket"); }

  explicit simple_target_socket_b(const char* n = default_name())
    : base_type(n) <1>
    , m_fw_process(this) <2>
    , m_bw_process(this) <3>
  {
    bind(m_fw_process); <4>
  }

  using base_type::bind;

  // bw transport must come thru us.
  tlm::tlm_bw_transport_if<TYPES> * operator ->() {return &m_bw_process;} <5>
----
<1> 名字用来构造基类tlm_target_socket
<2> 将this指针用来构造成员变量m_fw_process
<3> 将this指针用来构造成员变量m_bw_process
<4> 调用bind，将m_fw_process绑定到自己身上，这里的bind调用的是tlm_target_socket的bind，所以这里是讲一个实现了tlm_fw_transport_if
的类绑定到一个作为 `sc_export<FW_IF>` 的tlm_base_socket上
<5> 重载了 `operator->()` 实现，返回的是m_bw_process指针

---

simple_target_socket_b提供了两个private的成员函数，供自己的友元类fw_process和bw_process使用(
主要是bw_process实现
<<data::simple_target_process_b::bw_process::nb_transport_bw, bw_process::nb_transport_bw>>
以及
<<data::simple_target_process_b::bw_process::invalidate_direct_mem_ptr, bw_process::invalidate_direct_mem_ptr>>
这两个tlm_bw_transport_if函数的时候使用
)：
[[data::simple_target_process_b::bw_nb_transport]]
[[data::simple_target_process_b::bw_invalidate_direct_mem_ptr]]

.src/tlm_utils/simple_target_socket.h
[source,cpp]
----
private:
  //make call on bw path.
  sync_enum_type bw_nb_transport(transaction_type &trans, phase_type &phase, sc_core::sc_time &t)
  {
    return base_type::operator ->()->nb_transport_bw(trans, phase, t);
  }

  void bw_invalidate_direct_mem_ptr(sc_dt::uint64 s,sc_dt::uint64 e)
  {
    base_type::operator ->()->invalidate_direct_mem_ptr(s, e);
  }
----

注意这里的 `base_type` 指的是基类 tlm_target_socket（因为simple_target_socket_b自己也实现了
`operator->()`，所以这里如果不显示指定base_type，调用的则是simple_target_socket_b自己所实现的
`operator->()`，返回m_bw_process的指针，这样就无法达到所需要的目的了），所以 `base_type::operator ->()`
实际上调用的是基类tlm_target_socket的 `operator->()`，根据以下的定义，调用的则是tlm_target_socket
中的类型为sc_port类型的成员变量m_port的 `operator->()`:

.src/tlm_core/tlm_2/tlm_sockets/tlm_target_socket.h
[source,cpp]
----
  //
  // Forward to 'operator->()' of port class
  //
  bw_interface_type* operator->()
  {
    return m_port.operator->();
  }
----

故而，最后的结果是，调用的是tlm_target_socket中，所绑定的BW_IF（可以是多个）的接口函数
nb_transport_bw和invalidate_direct_mem_ptr。
而tlm_target_socket所绑定的BW_IF，在定义simple_target_socket_b的时候并没有提供，这就需要
应用者自己将simple_target_socket_b作为一个tlm_target_socket，绑定BW_IF。而tlm_target_socket
的 m_port成员只有在双向绑定（绑定一个tlm_initiator_socket或者一个tlm_target_socket）时候才能
被绑定。

---


==== simple_target_socket

==== simple_target_socket_optional