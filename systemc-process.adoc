:source-highlighter: coderay

:toc: left

SystemC中的process
[[chap::process]]

== 引言

在<<chap::schedule_model, SystemC调度模型>>
一章中，我们已经可以了解SystemC是如何创建和使用Process的。
本部分是对SystemC中Method/Thread/CThread的总结。

在开始之前，我们需要厘清以下几个数据结构的关系：

* sc_process_b 是所有method/thread/cthread的基础类，直接继承自 `sc_object`
* sc_thread_process直接继承自sc_process_b，是表示thread线程的数据结构
* sc_method_process直接继承自sc_process_b，是表示method线程的数据结构
* sc_cthread_process直接继承自sc_thread_process，是表示cthread线程的数据结构
* sc_thread_handle是 `sc_thread_process*` 的别名
* sc_method_handle是 `sc_method_process*` 的别名
* sc_cthread_handle是 `sc_cthread_process*` 的别名
* sc_process_handle是基础类，不继承任何其他类，内部保存一个指向sc_process_b的指针，因此可以认为是一个包装类

== sc_process_b
[[data::sc_process_b]]

=== 成员变量

sc_process_b 继承自 `sc_object` ，除了继承得到的成员变量以外，sc_process_b还
增加了非常丰富的成员变量，以支持process这一概念：

.src/sysc/kernel/sc_process.h
[source,cpp]
----
    // debugging stuff:

  public:
    const char*                 file;
    int                         lineno;
    int                         proc_id;

  protected:
    int                          m_active_areset_n; // number of aresets active.
    int                          m_active_reset_n;  // number of resets active.
    bool                         m_dont_init;       // true: no initialize call.
    spawn_t                      m_dynamic_proc;    // SPAWN_ELAB, SPAWN_START, SPAWN_SIM
    const sc_event*              m_event_p;         // Dynamic event waiting on.
    int                          m_event_count;     // number of events.
    const sc_event_list*         m_event_list_p;    // event list waiting on.
    sc_process_b*                m_exist_p;         // process existence link.
    bool                         m_free_host;       // free sc_semantic_host_p.
    bool                         m_has_reset_signal;  // has reset_signal_is.
    bool                         m_has_stack;       // true is stack present.
    bool                         m_is_thread;       // true if this is thread.
    sc_report*                   m_last_report_p;   // last report this process.
    sc_name_gen*                 m_name_gen_p;      // subprocess name generator
    sc_curr_proc_kind            m_process_kind;    // type of process.
    int                          m_references_n;    // outstanding handles.
    std::vector<sc_reset*>       m_resets;          // resets for process.
    sc_event*                    m_reset_event_p;   // reset event.
    sc_event*                    m_resume_event_p;  // resume event.
    sc_process_b*                m_runnable_p;      // sc_runnable link
    sc_process_host*             m_semantics_host_p;   // host for semantics.
    SC_ENTRY_FUNC                m_semantics_method_p; // method for semantics.
    int                          m_state;           // process state.
    std::vector<const sc_event*> m_static_events;   // static events waiting on.
    bool                         m_sticky_reset;    // see note 3 above.
    sc_event*                    m_term_event_p;    // terminated event.
    sc_throw_it_helper*          m_throw_helper_p;  // what to throw.
    process_throw_type           m_throw_status;    // exception throwing status
    bool                         m_timed_out;       // true if we timed out.
    sc_event*                    m_timeout_event_p; // timeout event.
    trigger_t                    m_trigger_type;    // type of trigger using.
    bool                         m_unwinding;       // true if unwinding stack.
----

sc_process_b的成员变量比较复杂，这里我们按照这些成员变量的作用一个一个说。

第一组是用来做debug目的的三个成员变量：

----
    const char*                 file;
    int                         lineno;
    int                         proc_id;
----

然后是做reset处理的两个成员变量：

----
    int                          m_active_areset_n; // number of aresets active.
    int                          m_active_reset_n;  // number of resets active.
----

单独的 `m_dont_init` 是用来表示process是否需要在最初执行一遍，参考
<<api::dont_initialize, 控制METHOD线程是否初始化>>部分的使用：

----
    bool                         m_dont_init;       // true: no initialize call.
----

成员变量 `m_dynamic_proc` 与动态线程有关：

----
    spawn_t                      m_dynamic_proc;    // SPAWN_ELAB, SPAWN_START, SPAWN_SIM
----

而接下来的三个变量则是处理动态敏感的。如果wait/next_trigger在一个单独的event上，就使用
成员变量 `m_event_p` 保存这个事件的指针。如果wait/next_trigger在多个事件上，就使用
成员变量 `m_event_list_p` 保存创建出来的sc_event_list派生类的指针。对于AND LIST类型
的多个事件， `m_event_count` 保存着事件的个数，以方便事件发生的时候进行计数：

----
    const sc_event*              m_event_p;         // Dynamic event waiting on.
    int                          m_event_count;     // number of events.
    const sc_event_list*         m_event_list_p;    // event list waiting on.
----

成员变量 `m_exist_p` 构成了一条process之间的链表。这个成员变量在sc_process_b中没有
使用，在sc_method_process和sc_thread_process中，分别用一对set_next_exist和next_exist
API使用了这个成员变量，而set_next_exist API在创建线程的时候被调用，将新建的
process handle放入simc的 `m_process_table` 中：

----
    sc_process_b*                m_exist_p;         // process existence link.
----

接下来这四个bool成员变量都是创建时候设定的，其中 `m_is_thread` 在SystemC中没有得到使用。
`m_last_report_p` 是sc_report类型，目前还不清楚作用。 `m_name_gen_p` 是用来
辅助产生hierarchy命名的部分。而 `m_process_kind` 则是用来表示派生类的类型，可选的有
METHOD，THREAD和CTHREAD：

----
    bool                         m_free_host;       // free sc_semantic_host_p.
    bool                         m_has_reset_signal;  // has reset_signal_is.
    bool                         m_has_stack;       // true is stack present.
    bool                         m_is_thread;       // true if this is thread.
    sc_report*                   m_last_report_p;   // last report this process.
    sc_name_gen*                 m_name_gen_p;      // subprocess name generator
    sc_curr_proc_kind            m_process_kind;    // type of process.
----

成员变量 `m_references_n` 是用来做引用计数中，计数器角色的。这个看起来和动态线程
中的资源自动释放机制有关：

----
    int                          m_references_n;    // outstanding handles.
----

这一组成员变量和reset/resume机制有关：

----
    std::vector<sc_reset*>       m_resets;          // resets for process.
    sc_event*                    m_reset_event_p;   // reset event.
    sc_event*                    m_resume_event_p;  // resume event.
----

`m_runnable_p` 成员变量使得sc_process_b能够形成一个链表，链表中的每个节点
都是一个进入runnable状态的线程：

----
    sc_process_b*                m_runnable_p;      // sc_runnable link
----

这一组成员变量就是sc_process_b所代表的线程的入口函数，以及基类指针：

----
    sc_process_host*             m_semantics_host_p;   // host for semantics.
    SC_ENTRY_FUNC                m_semantics_method_p; // method for semantics.
----

[[data::sc_process_b::m_state]]
`m_state` 表示的是当前线程的状态，这个integer类型采用了位掩码的方式，来表示各种
不同的状态的组合：

----
    int                          m_state;           // process state.
----

目前定义的状态位有：

.src/sysc/kernel/sc_process.h
[source,cpp]
----
    enum process_state {
	ps_bit_disabled = 1,      // process is disabled.
	ps_bit_ready_to_run = 2,  // process is ready to run.
        ps_bit_suspended = 4,     // process is suspended.
	ps_bit_zombie = 8,        // process is a zombie.
        ps_normal = 0             // must be zero.
    };
----

sc_process_b构造的时候， `m_state`的值为 `ps_normal` 。ps_normal是个特殊的值，它
并不是一个位掩码，而是一个全0的值。这意味着当没有任何一个位掩码置位的时候，就是ps_normal。
所以在使用的时候，ps_normal可以不需要显式赋值，只需要将原先状态位的位掩码一个一个去掉，全部
清除之后，状态自然变成了ps_normal了。


`m_static_events` 则是本process所设置的静态事件对象列表，这些事件之间是或的关系，只要有一个
事件发生，就可能唤醒此线程：

----
    std::vector<const sc_event*> m_static_events;   // static events waiting on.
----

这四个成员变量和sticky_reset以及异常机制有关：

----
    bool                         m_sticky_reset;    // see note 3 above.
    sc_event*                    m_term_event_p;    // terminated event. <1>
    sc_throw_it_helper*          m_throw_helper_p;  // what to throw.
    process_throw_type           m_throw_status;    // exception throwing status
----
<1> 当sc_process_b的 `disconnect_process` 被调用的时候，m_term_event_p被notify

`m_timed_out` 表示process是否超时，目前没看到与之相关的代码：

----
    bool                         m_timed_out;       // true if we timed out.
----

`m_timeout_event_p` 则保存了当process动态敏感时候，带延时时间时，延时时间对象的指针：

----
    sc_event*                    m_timeout_event_p; // timeout event.
----

`m_trigger_type` 表明了当前的trigger类型，动态和静态trigger有不同的处理流程：

----
    trigger_t                    m_trigger_type;    // type of trigger using.
----

最后一个成员变量 `m_unwinding` 与异常处理的时候，堆栈展开有关：

----
    bool                         m_unwinding;       // true if unwinding stack.
----

==== 静态/动态事件

Process的成员变量中，有多个与sc_event相关的部分，这些是process静态或者动态调度时所依赖
的时间对象。Process使用哪些对象，要根据 `m_trigger_type` 判断：

* trigger type为 `STATIC` ，使用 m_static_events 里所保存的事件对象
* trigger type为 `EVENT` ，使用 m_event_p 所保存的事件对象
* trigger type为 `OR_LIST` ，使用 m_event_list_p 所保存的事件列表对象
* trigger type为 `AND_LIST` ，使用 m_event_list_p 所保存的事件列表对象，并辅助使用 m_event_count 记录事件发生的数目
* trigger type为 `TIMEOUT` ，使用 m_timeout_event_p 所保存的事件对象
* trigger type为 `EVENT_TIMEOUT` ，使用 m_event_p 和 m_timeout_event_p 两个事件对象
* trigger type为 `OR_LIST_TIMEOUT` ，使用 m_event_list_p 和 m_timeout_event_p 两个对象
* trigger type为 `AND_LIST_TIMEOUT` ，使用 m_event_list_p 和 m_timeout_event_p 两个对象，并辅助使用 m_event_count

一种特定trigger type下，不使用的动态部分需要清空。

=== 重要成员函数

[[api::sc_process_b::add_static_event]]
`add_static_event` 将一个事件加入到 `m_static_events` 列表中，同时也将
本process cast为合适的派生类，调用事件的
<<api::sc_event::add_static, `add_static`>>成员函数，设置到事件中：

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_process_b::add_static_event"
//
// This method adds an event to the list of static events, and sets the
// event up to call back this process when it fires.
//------------------------------------------------------------------------------
void sc_process_b::add_static_event( const sc_event& e )
{
    sc_method_handle method_h; // This process as a method.
    sc_thread_handle thread_h; // This process as a thread.


    // CHECK TO SEE IF WE ARE ALREADY REGISTERED WITH THE EVENT:

    for( int i = m_static_events.size() - 1; i >= 0; -- i ) {
        if( &e == m_static_events[i] ) {
            return;
        }
    }

    // REMEMBER THE EVENT AND THEN REGISTER OUR OBJECT INSTANCE WITH IT:

    m_static_events.push_back( &e );

    switch ( m_process_kind )
    {
      case SC_THREAD_PROC_:
      case SC_CTHREAD_PROC_:
        thread_h = static_cast<sc_thread_handle>( this );
        e.add_static( thread_h );
        break;
      case SC_METHOD_PROC_:
        method_h = static_cast<sc_method_handle>( this );
        e.add_static( method_h );
        break;
      default:
        sc_assert( false );
        break;
    }
}
----

注意，sc_process_b并没有定义与add_static_event相对应的
add_dynamic_event，这是因为static的event是在process 创建的时候指定的。而
dynamic event则是在<<concept::wait, wait>>或者<<concept::next_trigger, next_trigger>>
时候设置的。对于事件，将一个sc_process_b通过add_dynamic列入本事件所关联的动态
事件，也是在wait/next_trigger中**动态**完成的。

[[api::sc_process_b::remove_static_events]]
与add_static_event功能相反的是remove_static_events:

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_process_b::remove_static_events"
//
// This method removes this object instance from the events in its static
// event list.
//------------------------------------------------------------------------------
void
sc_process_b::remove_static_events()
{
    sc_method_handle method_h; // This process as a method.
    sc_thread_handle thread_h; // This process as a thread.

    switch ( m_process_kind )
    {
      case SC_THREAD_PROC_:
      case SC_CTHREAD_PROC_:
        thread_h = static_cast<sc_thread_handle>( this );
        for( int i = m_static_events.size() - 1; i >= 0; -- i ) {
            m_static_events[i]->remove_static( thread_h );
        }
        m_static_events.resize(0);
        break;
      case SC_METHOD_PROC_:
        method_h = static_cast<sc_method_handle>( this );
        for( int i = m_static_events.size() - 1; i >= 0; -- i ) {
            m_static_events[i]->remove_static( method_h );
        }
        m_static_events.resize(0);
        break;
      default: // Some other type, it needs to clean up itself.
        // std::cout << "Check " << __FILE__ << ":" << __LINE__ << std::endl;
        break;
    }
}
----

这里的过程和 `add_static_event` 相反。对于每一个 `m_static_events`
的事件，调用其 <<api::sc_event::remove_static, `remove_static`>> 将本process handle从sc_event的
static process列表中移除。最后将 `m_static_events` 清零。

一般来说，很少需要将process的static events列表清除，因为在process的生命周期中，process
都需要依赖这些静态事件的发生来被调度。只有当process的生命周期显式地被要求结束（在disconnect_process中），才需要调用remove_static_events。

[[api::sc_process_b::remove_dynamic_events]]
在process生命周期显式杯结束的时候，还需要清除动态敏感事件，因此有一个 `remove_dynamic_events`
的成员函数：

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_process_b::remove_dynamic_events"
//
// This method removes this object instance from the events in its dynamic
// event lists.
//
// Arguments:
//     skip_timeout = skip cleaning up the timeout event, it will be done
//                    by sc_event_notify().
//------------------------------------------------------------------------------
void
sc_process_b::remove_dynamic_events( bool skip_timeout )
{
    sc_method_handle  method_h;   // This process as a method.
    sc_thread_handle  thread_h;   // This process as a thread.

    m_trigger_type = STATIC;
    switch ( m_process_kind )
    {
      case SC_THREAD_PROC_:
      case SC_CTHREAD_PROC_:
        thread_h = static_cast<sc_thread_handle>(this);
	if ( thread_h->m_timeout_event_p && !skip_timeout ) {
	    thread_h->m_timeout_event_p->remove_dynamic(thread_h);
	    thread_h->m_timeout_event_p->cancel();
	}
        if ( m_event_p )
        {
            m_event_p->remove_dynamic( thread_h );
            m_event_p = 0;
        }
        if ( m_event_list_p )
        {
            m_event_list_p->remove_dynamic( thread_h, 0 );
            m_event_list_p->auto_delete();
	    m_event_list_p = 0;
        }
        break;
      case SC_METHOD_PROC_:
        method_h = static_cast<sc_method_handle>(this);
	if ( method_h->m_timeout_event_p && !skip_timeout ) {
	    method_h->m_timeout_event_p->remove_dynamic(method_h);
	    method_h->m_timeout_event_p->cancel();
	}
        if ( m_event_p )
        {
            m_event_p->remove_dynamic( method_h );
            m_event_p = 0;
        }
        if ( m_event_list_p )
        {
            m_event_list_p->remove_dynamic( method_h, 0 );
            m_event_list_p->auto_delete();
	    m_event_list_p = 0;
        }
        break;
      default: // Some other type, it needs to clean up itself.
        // std::cout << "Check " << __FILE__ << ":" << __LINE__ << std::endl;
        break;
    }
}
----

对于sc_process_b而言，静态事件都保存在 `m_static_events` 列表中，然而动态事件：

* 单一的动态事件，指针保存在 m_event_p 中
* 组合的动态事件列表，指针保存在 m_event_list_p 中
* 定时的内部创建的事件（wait/next_trigger中带延时功能），保存在 m_timed_event_p 中

因此在 `remove_dynamic_events` 的时候，需要一个一个检查是否有效，并移除。

需要注意的是， `remove_dynamic_events` 可以接受一个布尔参数，表明是否跳过timeout event
的移除。默认情况下会将所有动态事件移除，如果设置跳过timed event，则移除除了timeout
event以外所有的动态事件（其实只有单一事件和多个事件列表）。只有在trigger_dynamic的时候，
process被disable，才会传入一个参数要求保留timeout event，但这么设计的原因目前未知。

== sc_process_handle
[[data::sc_process_handle]]

=== 成员变量

sc_process_handle内部只保存了一个指向基类sc_process_b指针的成员变量 `m_target_p`:

.src/sysc/kernel/sc_process_handle.h
[source,cpp]
----
  protected:
    sc_process_b* m_target_p;   // Target for this object instance.

  protected:
    static std::vector<sc_event*>  empty_event_vector;  // If m_target_p == 0.
    static std::vector<sc_object*> empty_object_vector; // If m_target_p == 0.
    static sc_event                non_event;           // If m_target_p == 0.
----

另外三个静态成员变量，是为了在 `m_target_p` 为空的情况下，某些需要返回
对象引用的成员函数能够正确返回引用而添加的。

== sc_thread_process
[[data::sc_thread_process]]

=== 成员变量

除了基类 `sc_process_b` 的成员变量以外，sc_thread_process为支持协程
能力，增加了如下几个成员变量：

.src/sysc/kernel/sc_thread_process.h
[source,cpp]
----
  protected:
    sc_cor*                          m_cor_p;        // Thread's coroutine.
    std::vector<sc_process_monitor*> m_monitor_q;    // Thread monitors.
    std::size_t                      m_stack_size;   // Thread stack size.
    int                              m_wait_cycle_n; // # of waits to be done.
----

`m_cor_p` 以及 `m_stack_size` 是为支持协程而添加的。
`m_cor_p` 就是代表本thread的协程参数，用以启动、挂起和恢复协程时使用。
`m_stack_size` 则是有栈协程的协程栈的大小。

`m_monitor_q` 是thread monitor，后续我们再介绍。

最后一个m_wait_cycle_n，主要用在
<<api::sc_thread_process::wait_cycles, wait_cycles>>成员函数中，用以支持设定
特定等待时钟周期的场景。

== sc_method_process
[[data::sc_method_process]]

=== 成员变量

sc_method_process在基类 `sc_process_b` 的基础上增加了如下几个成员变量：

.src/sysc/kernel/sc_thread_process.h
[source,cpp]
----
    sc_cor*                          m_cor;        // Thread's coroutine.
    std::size_t                      m_stack_size; // Thread stack size.
    std::vector<sc_process_monitor*> m_monitor_q;  // Thread monitors.
----

然而这三个成员变量在sc_method_process中并没有得到使用。

== sc_cthread_process
[[data::sc_cthread_process]]

=== 成员变量

sc_cthread_process在基类 `sc_thread_process` 基础上，没有新增加其他的
成员变量。

== reset逻辑

== process状态的迁移变化

在sc_process_b中，有一个记录当前线程状态的位掩码 <<data::sc_process_b::m_state, `m_state`>> 。
sc_process_b可能有如下几种状态：

* disable
* ready to run
* suspend
* zombie
* normal

前四种分别为位的掩码，意味着process可以同时处于前四种状态中的多种。

在使用过程中，应当调用自由函数 `sc_get_current_process_handle` ，获取一个
<<data::sc_process_handle, sc_process_handle>>的对象，然后通过这个对象的
如下成员函数，调度这些管理process状态的部分：

* suspend，调用所保管的process handle的 `suspend_process` 成员函数
* resume，调用所保管的process handle的 `resume_process` 成员函数
* enable，调用所保管的process handle的 `enable_process` 成员函数
* disable，调用所保管的process handle的 `disable_process` 成员函数
* kill，调用所保管的process handle的 `kill_process` 成员函数
* reset，调用所保管的process handle的 `reset_process` 成员函数

IEEE 1666对于SystemC在如下几种process状态切换时的行为，交给实现自行定义：

* 当一个disabled, suspended的process上调用resume()时的行为
* 当一个suspended的process上调用sync_reset_on()和sync_reset_off()时的行为
* 当一个suspended的process上的由reset_signal_is()所指定的signal值发生变化时的行为

Proof of Concept实现在默认情况下，对这三种情况都当做错误处理。此外，在设置
一个变量 `sc_allow_process_control_corners` 为true的时候，实现可以转而采用
一种不报错的方式：

* 如果一个disabled, suspended的process上调用了resume()，则这个process被标记为
不再suspend。如果这么处理后的process是可以调度执行的（没有阻塞在任何事件上），那么这个
process将会被放入runnable列表中
* sync_reset_on()和sync_reset_off()只会将相关的标志位置位或者复位。process是否处于
reset状态，取决于当process得到执行时候，相关标志位的状态。
* 如果一个suspended的process有由reset_signal_is()所制定的reset signal，则这个reset
signal的值只有在这个process下次执行的时候，才会被采样，采样的结果决定process是否reset

[[data::sc_allow_process_control_corners]]
`sc_allow_process_control_corners` 在SystemC中默认值是false:

.src/sysc/kernel/sc_simcontext.h
[source,cpp]
----
bool sc_allow_process_control_corners = false;

// The state transition diagram for the interaction of disable and suspend
// when sc_allow_process_control_corners is true is shown below:
//
// ......................................................................
// .         ENABLED                    .           DISABLED            .
// .                                    .                               .
// .                 +----------+    disable      +----------+          .
// .   +------------>|          |-------.-------->|          |          .
// .   |             | runnable |       .         | runnable |          .
// .   |     +-------|          |<------.---------|          |------+   .
// .   |     |       +----------+     enable      +----------+      |   .
// .   |     |          |    ^          .            |    ^         |   .
// .   |     |  suspend |    | resume   .    suspend |    | resume  |   .
// .   |     |          V    |          .            V    |         |   .
// .   |     |       +----------+    disable      +----------+      |   .
// .   |     |       | suspend  |-------.-------->| suspend  |      |   .
// . t |   r |       |          |       .         |          |      | r .
// . r |   u |       |  ready   |<------.---------|  ready   |      | u .
// . i |   n |       +----------+     enable      +----------+      | n .
// . g |   / |         ^                .                           | / .
// . g |   w |  trigger|                .                           | w .
// . e |   a |         |                .                           | a .
// . r |   i |       +----------+    disable      +----------+      | i .
// .   |   t |       | suspend  |-------.-------->| suspend  |      | t .
// .   |     |       |          |       .         |          |      |   .
// .   |     |       | waiting  |<------.---------| waiting  |      |   .
// .   |     |       +----------+     enable      +----------+      |   .
// .   |     |          |    ^          .            |    ^         |   .
// .   |     |  suspend |    | resume   .    suspend |    | resume  |   .
// .   |     |          V    |          .            V    |         |   .
// .   |     |       +----------+    disable      +----------+      |   .
// .   |     +------>|          |-------.-------->|          |      |   .
// .   |             | waiting  |       .         | waiting  |      |   .
// .   +-------------|          |<------.---------|          |<-----+   .
// .                 +----------+     enable      +----------+          .
// .                                    .                               .
// ......................................................................

----

如果需要支持不出错的处理，可以编译代码的时候将这个更改为true，或者在sc_main()中，第一行
加入：

[source,cpp]
----
sc_core::sc_allow_process_control_corners = true;
----

=== disable and enable
[[concept::process::control::disable_enable]]

sc_process_handle的enable/disable调用，如前所述，调用的其实是内部sc_process_b
的enable_process/disable_process接口函数：

.src/sysc/kernel/sc_process_handle.h
[source,cpp]
----
// enable this object instance's target.

inline void sc_process_handle::enable(sc_descendant_inclusion_info descendants)
{
    if ( m_target_p )
        m_target_p->enable_process(descendants);
    else
        SC_REPORT_WARNING( SC_ID_EMPTY_PROCESS_HANDLE_, "enable()");
}

// disable this object instance's target.

inline void sc_process_handle::disable(sc_descendant_inclusion_info descendants)
{
    if ( m_target_p )
        m_target_p->disable_process(descendants);
    else
        SC_REPORT_WARNING( SC_ID_EMPTY_PROCESS_HANDLE_, "disable()");
}
----

enable_process/disable_process是sc_process_b的接口函数，是纯虚函数。对于Thread和Method
有着不同的实现。

==== Thread/CThread

[[concept::process::control::disable::thread]]
首先我们来看Thread/CThread是如何实现disable的：

.src/sysc/kernel/sc_thread_process.cpp
[source,cpp]
----
void sc_thread_process::disable_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE DISABLE REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->disable_process(descendants);
        }
    }

    // DON'T ALLOW CORNER CASE BY DEFAULT:

    if ( !sc_allow_process_control_corners )
    {
        switch( m_trigger_type )
        {
          case AND_LIST_TIMEOUT:
          case EVENT_TIMEOUT:
          case OR_LIST_TIMEOUT:
          case TIMEOUT:
            report_error(SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                   "attempt to disable a thread with timeout wait");
            // may continue, if suppressed
            break;
          default:
            break;
        }
    }

    // DISABLE OUR OBJECT INSTANCE:

    m_state = m_state | ps_bit_disabled;

    // IF THIS CALL IS BEFORE THE SIMULATION DON'T RUN THE THREAD:

    if ( !sc_is_running() )
    {
	m_state = m_state | ps_bit_ready_to_run;
        simcontext()->remove_runnable_thread(this);
    }
}
----

所有的这些状态转移函数，都会带一个 `descendants` 参数，表示是否需要将动作
传播给子对象。这部分的内容基本就是检索所有的子对象，并使用dynamic_cast来
检查这鞋子对象是否是process对象，如果是，就将请求转发过去。后续类似这部分的内容
我们就不再多解析了。

默认情况下，disable一个process的时候回检查process的状态。如果process设置了
超时状态（延时执行），那么就报错。如果我们将 `sc_allow_process_control_corners`
置为true，就会跳过这一步的检查，允许在设置有超时（延时）状态的process上执行disable动作。

接下来，
<<data::sc_process_b::m_state, m_state>>的ps_bit_disabled位被置位。如果disable process
发生在仿真开始之前，同时会把m_state的ps_bit_ready_to_run置位，从simc中准备runnable
的列表中移除这个process。如果disalbe process发生在仿真过程中，就无需其他动作，只需要继续执行下去。
如果disable_process的请求来自线程本身，disable_process并不会立即生效，而是会继续执行，直到
此线程被阻塞朱，然后让渡出CPU执行权为止。

这么设计的原因还暂时不清楚。

[[concept::process::control::enable::thread]]
Thread/CThrad的enable_process实现则是：

.src/sysc/kernel/sc_thread_process.cpp
[source,cpp]
----
void sc_thread_process::enable_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE ENABLE REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->enable_process(descendants);
        }
    }

    // ENABLE THIS OBJECT INSTANCE:
    //
    // If it was disabled and ready to run then put it on the run queue.

    m_state = m_state & ~ps_bit_disabled;
    if ( m_state == ps_bit_ready_to_run && sc_allow_process_control_corners )
    {
        m_state = ps_normal;
	if ( next_runnable() == 0 )
	    simcontext()->push_runnable_thread(this);
    }
}
----

首先是将m_state的ps_bit_disabled位复位。接下来如果状态是ps_bit_ready_to_run，并且
设置了 sc_allow_process_control_corners为true的话，将m_state置为ps_normal。如果
next_runnable()为空，即这个process不在runnable列表中，就将这个thread加入到runnable
列表中去。

由此可见：

* 如果仿真前disable process，在仿真过程中enable process，process会被放入runnable列表中执行，在下一个delta cycle立马开始执行。如果不这样做，这个process只能等到与之关联的静态敏感事件发生才会被
放入调度列表中得到执行了，因为process disable发生在仿真之前，process根本没得到执行，无法动态
等待事件。
* 如果仿真中disable process，之后再enable process，除非之前process已经执行且处于ready to run状态，否则enable_process不会将这个process放入列表中执行。仿真已经开始，说明这个process handle要么可能被静态敏感事件注册为关联线程，要么动态等待在一个事件上，都会有机会被调度重新放入可执行列表的

==== Method

[[concept::process::control::disable::method]]
Method的disable_process实现如下：

.src/sysc/kernel/sc_method_process.cpp
[source,cpp]
----
void sc_method_process::disable_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE SUSPEND REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->disable_process(descendants);
        }
    }

    // DON'T ALLOW CORNER CASE BY DEFAULT:

    if ( !sc_allow_process_control_corners )
    {
        switch( m_trigger_type )
        {
          case AND_LIST_TIMEOUT:
          case EVENT_TIMEOUT:
          case OR_LIST_TIMEOUT:
          case TIMEOUT:
            report_error( SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                          "attempt to disable a method with timeout wait" );
            // may continue, if suppressed
            break;
          default:
            break;
        }
    }

    // DISABLE OUR OBJECT INSTANCE:

    m_state = m_state | ps_bit_disabled;

    // IF THIS CALL IS BEFORE THE SIMULATION DON'T RUN THE METHOD:

    if ( !sc_is_running() )
    {
        sc_get_curr_simcontext()->remove_runnable_method(this);
    }
}
----

Method的disable process处理基本和Thread的差不多，最大的区别在于，如果disable
发生在仿真开始之前，没有将状态位ready_to_run置位的。
这么做的原因还不是很清楚。

[[concept::process::control::enable::method]]
Method的enable_process实现则是：

.src/sysc/kernel/sc_method_process.cpp
[source,cpp]
----
void sc_method_process::enable_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE RESUME REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->enable_process(descendants);
        }
    }

    // ENABLE THIS OBJECT INSTANCE:
    //
    // If it was disabled and ready to run then put it on the run queue.

    m_state = m_state & ~ps_bit_disabled;
    if ( m_state == ps_bit_ready_to_run )
    {
        m_state = ps_normal;
	if ( next_runnable() == 0 )
	    simcontext()->push_runnable_method(this);
    }
}
----

这里的处理基本和Thread一致，除了检查状态时候，无须sc_allow_process_control_corners
为true。我个人猜测，这应该是因为Method每次都会完整执行一遍，不像Thread那样存在死循环，所以
disable之后，再enable，调度执行即可，不会是一个corner case.

=== disable-enable例子分析

现在我们有一个clock period为100ns的sc_clock clock，并且有如下代码：

[source,cpp]
----
void calling()
{
  wait(20, SC_NS);
  t.disable(); // @20 ns
  wait(30, SC_NS);
  t.enable() // @50 ns

  wait(110, SC_NS);
  t.disable(); // @160 ns

  wait(200, SC_NS);
  t.endable(); // @360 ns
}

void target()
{
  while(1)
  {
      wait();
      cout << sc_time_stamp(); // 100 400 500
  }
}
----

target线程设置静态敏感事件为 `sensitive << clock.pos();`。 t是target线程的
sc_process_handle。

在第一个时钟上升沿，也就是100ns时，target处于enable状态，因此会正确输出100。接下来200ns
和300ns的时钟上升沿，target都处于disable状态。clock的posedge事件调用target的
<<api::sc_thread_process::trigger_static, trigger_static>>
成员函数，在这个函数里，有何如下代码(以thread的trigger_static为例，method中
有一样的处理代码)：

[source,cpp]
----
    // No need to try queueing this thread if one of the following is true:
    //    (a) it is disabled
    //    (b) it is already queued for execution
    //    (c) it is waiting on a dynamic event
    //    (d) its wait count is not satisfied and it is not currently in reset

    if ( (m_state & ps_bit_disabled) || is_runnable() ||
          m_trigger_type != STATIC )
        return;
----

可以看到如果状态中有disable状态，那么trigger_static是不生效的，这里会直接返回。

直到400ns的上升沿事件发生，target才处于enable状态，target才会调度执行，从上次
执行时被阻塞的地方恢复执行。

如果动态阻塞在一个事件，这个事件在process disable状态发生的话，调用的是process
的
<<sc_process_b::trigger_dynamic, trigger_dynamic>>，这里有如下代码(以thread
为例，method中有一样的处理代码）：

[source,cpp]
----
    // If a process is disabled then we ignore any events, leaving them enabled:
    //
    // But if this is a time out event we need to remove both it and the
    // event that was being waited for.

    if ( m_state & ps_bit_disabled )
    {
        if ( e == m_timeout_event_p )
	{
	    remove_dynamic_events( true ); <1>
	    return true;
	}
	else
	{
	    return false;
	}
    }
----
<1> 保留timed event对象，参见<<api::sc_process_b::remove_dynamic_events, remove_dynamic_events>>部分

如果动态trigger这个disabled process的事件是个timed事件，那么disabled状态的
线程认为这个事件已经被accpet，需要清除掉这个事件，同时返回true。这个返回值用以
向事件表明是否线程被成功调度。这里可以看到，disabled process向外界报告自己被
重新调度，然而却没有放入runnable列表。

回到最初的那个例子，如果那个例子中target没有设置静态敏感事件，而是依赖动态敏感
事件的话：

[source,cpp]
----
void target()
{
  while(1)
  {
      wait(100, SC_NS);
      cout << sc_time_stamp(); // 100 360, 460
  }
}
----

那么在100ns时候输出100后，200ns 时候timed event发生，这里不会恢复执行，只会将200ns
的timed event移除。这样带来的后果是，target线程在之后永远不会被调度执行！因为200ns
的timed event被移除，但target没有恢复执行以创建下一个300ns的timed event，这个
target奖没有任何event能够唤醒，哪怕之后被enable了同样如此。这是使用disable-enable
时候应当注意的一点：一个使用disable-enable控制的线程，应当有静态敏感事件，以协助在enable
线程之后，线程可以继续调度执行。
在<<use::process::control::prepare_to_simulate, prepare_to_simulate中的状态判断>>
部分，我们也可能看到simc在初始的时候，是不允许disable状态的线程没有静态敏感事件的。


线程在disable状态，无法响应任何发生的事件。这种特性可以用来模拟clock-gating行为。disable-enable
机制一般适用于clock驱动的process，这些process天然带有clock的敏感沿作为静态事件。


=== suspend and resume
[[concept::process::control::suspend_resume]]

suspend操作会挂起一个线程，而resume操作则会继续此线程的执行。这里的suspend/resume
指的是从用户方显式地要求挂起和唤醒线程，而不是SystemC内部在线程切换的时候的线程挂起
和唤醒动作。

sc_process_handle的suspend和resume都转发给了下层的process的suspend_process()
和resume_process():

.src/sysc/kernel/sc_process_handle.h
[source,cpp]
----
// resume this object instance's target.

inline void sc_process_handle::resume(sc_descendant_inclusion_info descendants)
{
    if ( m_target_p )
        m_target_p->resume_process(descendants);
    else
        SC_REPORT_WARNING( SC_ID_EMPTY_PROCESS_HANDLE_, "resume()");
}

// suspend this object instance's target.

inline void sc_process_handle::suspend(sc_descendant_inclusion_info descendants)
{
    if ( m_target_p )
        m_target_p->suspend_process(descendants);
    else
        SC_REPORT_WARNING( SC_ID_EMPTY_PROCESS_HANDLE_, "suspend()");
}
----

Method和Thread/CThread有着不同的suspend/resume动作。

==== Thread/CThread

以下是Thread/CThread的suspend_process的代码：
[[concept::process::control::suspend::thread]]

.src/sysc/kernel/sc_thread_process.cpp
[source,cpp]
----
void sc_thread_process::suspend_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE SUSPEND REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->suspend_process(descendants);
        }
    }

    // CORNER CASE CHECKS, THE FOLLOWING ARE ERRORS:
    //   (a) if this thread has a reset_signal_is specification
    //   (b) if this thread is in synchronous reset

    if ( !sc_allow_process_control_corners && m_has_reset_signal )
    {
        report_error(SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                     "attempt to suspend a thread that has a reset signal");
        // may continue, if suppressed
    }
    else if ( !sc_allow_process_control_corners && m_sticky_reset )
    {
        report_error(SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                     "attempt to suspend a thread in synchronous reset");
        // may continue, if suppressed
    }

    // SUSPEND OUR OBJECT INSTANCE:
    //
    // (1) If we are on the runnable queue then set suspended and ready_to_run,
    //     and remove ourselves from the run queue.
    // (2) If this is a self-suspension then a resume should cause immediate
    //     scheduling of the process, and we need to call suspend_me() here.

    m_state = m_state | ps_bit_suspended;
    if ( next_runnable() != 0 )
    {
	m_state = m_state | ps_bit_ready_to_run;
	simcontext()->remove_runnable_thread( this );
    }
    if ( sc_get_current_process_b() == dynamic_cast<sc_process_b*>(this)  )
    {
	m_state = m_state | ps_bit_ready_to_run;
	suspend_me();
    }
}
----

中间检查了suspend的时候，是否有reset信号。如果有，并且sc_allow_process_control_corners
是false，就报错，否则就跳过检查。

主要的动作是把m_state的ps_bit_suspended置位。如果 `next_runnable()` 非空，说明当前
的process在runnable列表中，这种情况下需要将其标记为ready to run(因为已经要准备run了)
并且从simc的runnable列表中移除此线程。

如果是suspend请求是来自线程自身，即当suspend_process
调用的时候当前线程正在执行， 同样标记ready to run，并且调用suspend_me让渡出执行权。
这样的suspend表现的类似于一个wait()，调用后从不返回，直到线程被外部唤醒的时候才返回。

[[concept::process::control::resume::thread]]
resume_process的操作如下：

.src/sysc/kernel/sc_thread_process.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_thread_process::resume_process"
//
// This method resumes the execution of this process, and if requested, its
// descendants. If the process was suspended and has a resumption pending it
// will be dispatched in the next delta cycle. Otherwise the state will be
// adjusted to indicate it is no longer suspended, but no immediate execution
// will occur.
//------------------------------------------------------------------------------
void sc_thread_process::resume_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE RESUME REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->resume_process(descendants);
        }
    }

    // BY DEFAULT THE CORNER CASE IS AN ERROR:

    if ( !sc_allow_process_control_corners && (m_state & ps_bit_disabled) &&
         (m_state & ps_bit_suspended) )
    {
        m_state = m_state & ~ps_bit_suspended;
        report_error(SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                     "call to resume() on a disabled suspended thread");
        // may continue, if suppressed
    }

    // CLEAR THE SUSPENDED BIT:

    m_state = m_state & ~ps_bit_suspended;

    // RESUME OBJECT INSTANCE IF IT IS READY TO RUN:

    if ( m_state & ps_bit_ready_to_run )
    {
	m_state = m_state & ~ps_bit_ready_to_run;
	if ( next_runnable() == 0 )
	    simcontext()->push_runnable_thread(this);
	remove_dynamic_events();  // order important.
    }
}
----

如前所述，resume一个suspended，但是disabled的process是implementation defined行为，这里
用sc_allow_process_control_corners变量控制行为：如果这个变量为true，跳过检查，否则报错。

主要工作是清除ps_bit_suspended位。如果清除之后，m_state显示ready to run，说明线程在被挂起
的时候处于可运行状态（要么是在runnable列表中，要么就是正在运行）。此时清除掉ready to run
标志，同时向本线程放入runnable列表中，这样在下一个delta cycle本线程就会调度执行。线程
可以被执行，说明已经满足调度条件，所以这里可以移除所有动态的events。

所以一个自我suspended的thread，在resume的时候，会立即开始执行（实际上是从下一个delta cycle
开始执行），而不会等待阻塞事件发生（因为实际上并没有被事件阻塞）。一个满足调度条件的thread，再被
suspended之后不会执行，直到resume的时候才会被放入调度队列，重新开始执行。

对于Thread线程而言，suspend的地方可以是上次被调度出去的地方（某个wait），也可以是
自我suspend时候的 `suspend_me` 地方。当resume这个线程的时候，在下一个delta cycle，
线程会从上次被打断的地方恢复执行。对于自我suspend的情况，这相当于 suspend_process函数
中的suspend_me返回了。

==== Method

Method的suspend_process实现如下：
[[concept::process::control::suspend::method]]

.src/sysc/kernel/sc_method_process.cpp
[source,cpp]
----
void sc_method_process::suspend_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE SUSPEND REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->suspend_process(descendants);
        }
    }

    // CORNER CASE CHECKS, THE FOLLOWING ARE ERRORS:
    //   (a) if this method has a reset_signal_is specification
    //   (b) if this method is in synchronous reset

    if ( !sc_allow_process_control_corners && m_has_reset_signal )
    {
        report_error(SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                     "attempt to suspend a method that has a reset signal");
        // may continue, if suppressed
    }
    else if ( !sc_allow_process_control_corners && m_sticky_reset )
    {
        report_error(SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                     "attempt to suspend a method in synchronous reset");
        // may continue, if suppressed
    }

    // SUSPEND OUR OBJECT INSTANCE:
    //
    // (1) If we are on the runnable queue then set suspended and ready_to_run,
    //     and remove ourselves from the run queue.
    // (2) If this is a self-suspension then a resume should cause immediate
    //     scheduling of the process.

    m_state = m_state | ps_bit_suspended;
    if ( next_runnable() != 0 )
    {
	m_state = m_state | ps_bit_ready_to_run;
	simcontext()->remove_runnable_method( this );
    }
    if ( sc_get_current_process_b() == dynamic_cast<sc_process_b*>(this)  )
    {
	m_state = m_state | ps_bit_ready_to_run;
    }
}
----

可以看出，Method的suspend_process处理过程和tHREAD基本是一模一样的。
不同之处在于，Method没有suspend_me的概念，所以如果自我suspend的case, suspend_process
并不会立即阻塞此线程，而是标记为ready_to_run之后，立即返回。这意味着，如果在一个method
process中，我们调用了这个线程的suspend_process，线程不会阻塞，还是会继续执行下去。

[[concept::process::control::resume::method]]
Method的resume_process执行如下：

.src/sysc/kernel/sc_method_process.cpp
[source,cpp]
----

//------------------------------------------------------------------------------
//"sc_method_process::resume_process"
//
// This method resumes the execution of this process, and if requested, its
// descendants. If the process was suspended and has a resumption pending it
// will be dispatched in the next delta cycle. Otherwise the state will be
// adjusted to indicate it is no longer suspended, but no immediate execution
// will occur.
//------------------------------------------------------------------------------
void sc_method_process::resume_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE RESUME REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->resume_process(descendants);
        }
    }


    // BY DEFAULT THE CORNER CASE IS AN ERROR:

    if ( !sc_allow_process_control_corners && (m_state & ps_bit_disabled) &&
         (m_state & ps_bit_suspended) )
    {
        m_state = m_state & ~ps_bit_suspended;
        report_error( SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                      "call to resume() on a disabled suspended method" );
        // may continue, if suppressed
    }

    // CLEAR THE SUSPENDED BIT:

    m_state = m_state & ~ps_bit_suspended;

    // RESUME OBJECT INSTANCE:
    //
    // If this is not a self-resume and the method is ready to run then
    // put it on the runnable queue.

    if ( m_state & ps_bit_ready_to_run )
    {
	m_state = m_state & ~ps_bit_ready_to_run;
	if ( next_runnable() == 0 &&
	   ( sc_get_current_process_b() != dynamic_cast<sc_process_b*>(this) ) )
        {
	    simcontext()->push_runnable_method(this);
	    remove_dynamic_events();
	}
    }
}
----

resume一个Method线程的动作和resume一个Thread线程的动作是一模一样的。概念上的区别在于，resume
一个Method线程，这个线程会从头开始执行，而不像Thread线程那样，从上次suspend的地方开始执行。

=== suspend-resume例子分析

例如，我们有calling和target两个Thread，其中 `t` 是target的sc_process_handle:

[source,cpp]
----
void calling()
{
  wait(20, SC_NS);
  t.suspend(); // @20 ns
  wait(30, SC_NS);
  t.resume() // @50 ns

  wait(110, SC_NS);
  t.suspend(); // @160 ns

  wait(200, SC_NS);
  t.resume(); // @360 ns
}

void target()
{
  while(1)
  {
      wait(100, SC_NS);
      cout << sc_time_stamp(); // 100 360, 460
  }
}
----

这个例子中，target process的suspend和resume都是从另外一个线程calling发出的。
target线程每次都创建一个100ns延时的timed event，并等待此event的发生。

target中，第一个100ns的时候，target处于正常状态（20ns的suspend又在50ns的时候resume了），
所以target被正常调度执行，打印100，接下来又创建一个100ns的delay，准备在200ns的时候
唤醒此线程。然而，200ns的时候，设定的延时时间到达，事件发生，事件调用trigger_dynamic，将
动态阻塞在这个事件上的线程trigger起来的时候，线程处于suspended状态（160ns开始被suspend）。
在 <<sc_process_b::trigger_dynamic, trigger_dynamic>>的实现中，我们可以看到
如下部分代码(在method/thread的trigger_static中也是这套逻辑)：

[source,cpp]
----
    if ( (m_state & ps_bit_suspended) )
    {
	m_state = m_state | ps_bit_ready_to_run;
    }
    else
    {
        simcontext()->push_runnable_method(this);
    }
----

如果线程状态m_state的suspended位被置位，那么如果线程满足调度条件，这里也只是将其标记为
ready to run，而不会真正放入runnable列表。

因此，在这个例子中，200ns时候的timed event只会将线程target标记为ready to run，然后返回。
在360ns的时候，target线程被resume。由于
<<concept::process::control::resume::thread, resume此线程>>的时候，
线程是ready to run的，因此线程被
立即放入runnable列表，执行的时候打印出360的结果。之后线程以360ns为开始，每隔100ns
打印一个时间戳，直到仿真结束。

从这个例子中，我们也可以看到，一个被suspend的process，仍然可以接受调度请求。
在suspend期间，如果process满足调度条件，那么就会被延迟到resume的时候才会被
调度执行。如果suspend期间不满足调度请求，那么resume的时候，继续之前的状态，
表现起来好像这段suspend期间从未存在过一样。

suspend-resume机制不太适合用于clock驱动的process，因为使用clock驱动的process
很那理解这种把suspend期间发生的事件推迟到resume时候的概念。suspend-resume
一般用来抽象调度器。

=== prepare_to_simulate中的状态判断
[[use::process::control::prepare_to_simulate]]

在<<concept::simulate::initialize, 初始化>>部分，我们介绍过，在仿真开始前的时刻，
simc会将所有没有设定dont_initialize的method/thread都放入runnable列表中。这个
说法并不是很准确，因为里边还涉及到一些process状态的判断，现在我们回过头来看一下这部分代码：

.src/sysc/kernel/sc_simcontext.h
[source,cpp]
----
    // make all method processes runnable

    for ( method_p = m_process_table->method_q_head();
	  method_p; method_p = method_p->next_exist() )
    {
	if ( ((method_p->m_state & sc_process_b::ps_bit_disabled) != 0) ||
	     method_p->dont_initialize() )
	{
	    if ( method_p->m_static_events.size() == 0 )
	    {
	        SC_REPORT_WARNING( SC_ID_DISABLE_WILL_ORPHAN_PROCESS_,
		                   method_p->name() );
	    }
	}
	else if ( (method_p->m_state & sc_process_b::ps_bit_suspended) == 0)
	{
            if ( !method_p->is_runnable() ) // already scheduled?
                push_runnable_method_front( method_p );
        }
	else
	{
	    method_p->m_state |= sc_process_b::ps_bit_ready_to_run;
	}
    }

    // make thread processes runnable
    // (cthread processes always have the dont_initialize flag set)

    for ( thread_p = m_process_table->thread_q_head();
	  thread_p; thread_p = thread_p->next_exist() )
    {
	if ( ((thread_p->m_state & sc_process_b::ps_bit_disabled) != 0) ||
	     thread_p->dont_initialize() )
	{
	    if ( thread_p->m_static_events.size() == 0 )
	    {
	        SC_REPORT_WARNING( SC_ID_DISABLE_WILL_ORPHAN_PROCESS_,
		                   thread_p->name() );
	    }
	}
	else if ( (thread_p->m_state & sc_process_b::ps_bit_suspended) == 0)
	{
            if ( !thread_p->is_runnable() ) // already scheduled?
                push_runnable_thread_front( thread_p );
        }
	else
	{
	    thread_p->m_state |= sc_process_b::ps_bit_ready_to_run;
	}
    }
----

这两段代码分别处理了所有的method和thread，处理method和thread的代码一致，我们以thread
为例来说明。

对于每个thread，如果在仿真开始前被disable掉了，或者设置dont_initialize(CThread天然
设置无需初始化)，那么就需要检查，必须存在静态敏感事件。这个和我们之前的分析是一致的。
如果在仿真开始之前线程没有被suspend掉了，这表明线程应当可以执行，放入runnable列表。最后
就是仿真开始之前线程已经被suspend了，由于理论上此时线程应该被执行一次，但是却被suspend，按照
suspend-resume的逻辑，需要标记其为ready to run，这样在resume的时候就可以执行起来了。

== Dynamic Process

动态的process，指的是在仿真开始之后（simulation阶段）创建出来的线程，这些线程一般使用
sc_

=== sc_spawn


[[func::sc_spawn]]
sc_spawn用以从给定的参数中生成一个SystemC级别的线程（可以是Method，也可以是Thread，但不会是
CThread）。以下是sc_spawn的实现代码：

.src/sysc/kernel/sc_spawn.h
[source,cpp]
----
template <typename T>
inline sc_process_handle sc_spawn( 
    T object, 
    const char* name_p = 0,
    const sc_spawn_options* opt_p = 0)
{
    sc_simcontext*      context_p;
    sc_spawn_object<T>* spawn_p;
    
    context_p = sc_get_curr_simcontext();
    spawn_p = new sc_spawn_object<T>(object); <1>
    if ( !opt_p || !opt_p->is_method() )
    {
            sc_process_handle thread_handle = context_p->create_thread_process( 
            name_p, true,
            SC_MAKE_FUNC_PTR(sc_spawn_object<T>,semantics), <2>
            spawn_p, opt_p 
        );
        return thread_handle;
    }
    else
    {
            sc_process_handle method_handle = context_p->create_method_process( 
            name_p, true,
            SC_MAKE_FUNC_PTR(sc_spawn_object<T>,semantics), <2>
            spawn_p, opt_p 
        );
        return method_handle;
    }
}
----
<1> 从类型T的对象object创建一个 `sc_spawn_object<T>` 对象
<2> 设置Method/Thread的启动函数为刚才创建对象 spawn_p的 `semantics` 成员函数

从这段代码可以看出，对于给定的对象 `object`，这里会新建一个类型为 `sc_spawn_object<T>`
的对象，设置Method/Thread启动函数为这个新建的对象的 `semantics`。以下是 `sc_spawn_object<>`
的定义：

.src/sysc/kernel/sc_spawn.h
[source,cpp]
----
template<typename T>
class sc_spawn_object : public sc_process_host {
  public:
    sc_spawn_object( T object) : m_object(object)
    {
    }

    virtual void semantics()
    {
        m_object();
    }

  protected:
    T                        m_object; <1>
};
----
<1> sc_spwan_object保存了对象的拷贝

所以我们能看到， `semantics` 成员函数实际上调用的是 `m_object()` ，这意味着
对象的类必须重载了 `operator()` 才可以。

在sc_spawn的时候，我们可以看到，创建method/thread时候的第二个参数被设置为true，这与
使用<<api::SC_THREAD, SC_THREAD>>创建Thread线程，使用<<api::SC_METHOD, SC_METHOD>>
创建Method线程时都不同（那两个都将第二个参数设置为false）。这实际上是free_host参数，表明
这个method/thread所依赖的对象是否是一个自由对象。如果是，那么在相应的sc_process_b
析构的时候，会调用delete删除此对象。这也是为何在sc_spawn中，只new不delete却不会内存
泄漏的原因：

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
sc_process_b::~sc_process_b()
{

    // REDIRECT ANY CHILDREN AS CHILDREN OF THE SIMULATION CONTEXT:

    orphan_child_objects();


    // DELETE SEMANTICS OBJECTS IF NEED BE:

    if ( m_free_host ) delete m_semantics_host_p; <1>
#   if !defined(SC_USE_MEMBER_FUNC_PTR) // Remove invocation object.
        delete m_semantics_method_p;
#   endif


    // REMOVE ANY STRUCTURES THAT MAY HAVE BEEN BUILT:

    delete m_last_report_p;
    delete m_name_gen_p;
    delete m_reset_event_p;
    delete m_resume_event_p;
    delete m_term_event_p;
    delete m_throw_helper_p;
    delete m_timeout_event_p;

}
----
<1> 如果设置free host，在相应的sc_process_b析构的时候，会帮忙删除new出来的对象

另一个值得观察的地方在于，sc_spawn创建Method/Thread的最后一个参数都不为空，而是可能
给出参数。这个参数就是 `sc_spawn_options` 指针。之所以如此，是因为sc_spawn创建
出来的method/thread，没有类似<<api::SC_THREAD, SC_THREAD>>和<<api::SC_METHOD, SC_METHOD>>
那样可以辅助设置静态敏感事件、设定是否需要初始化等操作。为了支持这些，sc_spawn允许
传入一个 `sc_spwan_options` 对象的指针，补上这些。

例如，在sc_thread_process的构造函数中，有这么一段代码：

.src/sysc/kernel/sc_thread_process.cpp
[source,cpp]
----
    if (opt_p) {
        m_dont_init = opt_p->m_dont_initialize;
        if ( opt_p->m_stack_size ) m_stack_size = opt_p->m_stack_size;

        // traverse event sensitivity list
        for (unsigned int i = 0; i < opt_p->m_sensitive_events.size(); i++) {
            sc_sensitive::make_static_sensitivity(
                this, *opt_p->m_sensitive_events[i]);
        }

        // traverse port base sensitivity list
        for ( unsigned int i = 0; i < opt_p->m_sensitive_port_bases.size(); i++)
        {
            sc_sensitive::make_static_sensitivity(
                this, *opt_p->m_sensitive_port_bases[i]);
        }

        // traverse interface sensitivity list
        for ( unsigned int i = 0; i < opt_p->m_sensitive_interfaces.size(); i++)
        {
            sc_sensitive::make_static_sensitivity(
                this, *opt_p->m_sensitive_interfaces[i]);
        }

        // traverse event finder sensitivity list
        for ( unsigned int i = 0; i < opt_p->m_sensitive_event_finders.size();
            i++)
        {
            sc_sensitive::make_static_sensitivity(
                this, *opt_p->m_sensitive_event_finders[i]);
        }

        // process any reset signal specification:

	opt_p->specify_resets();

    }

    else
    {
        m_dont_init = false;
    }
----

这里在 `opt_p` 非空，即外界传入一个有效的 `sc_spawn_options` 指针的时候，使用这个
对象里的选项来初始化sc_thread_process的内容。sc_method_process的构造函数有着一样
的实现。

[[usage::sc_spawn::sc_clock]]
举个sc_spawn使用的例子。在sc_clock的before_end_of_elaboration中，
sc_clock就是用sc_spawn，创造出两个
METHOD，分别用来实现上升沿事件和下降沿事件：

.src/sysc/communication/sc_clock.cpp
[source,cpp]
----
void sc_clock::before_end_of_elaboration()
{
    std::string gen_base;
    sc_spawn_options posedge_options;	// Options for posedge process.
    sc_spawn_options negedge_options;	// Options for negedge process.

    posedge_options.spawn_method();
    posedge_options.dont_initialize();
    posedge_options.set_sensitivity(&m_next_posedge_event);
    gen_base = basename();
    gen_base += "_posedge_action";
    sc_spawn(sc_clock_posedge_callback(this),
	sc_gen_unique_name( gen_base.c_str() ), &posedge_options);

    negedge_options.spawn_method();
    negedge_options.dont_initialize();
    negedge_options.set_sensitivity(&m_next_negedge_event);
    gen_base = basename();
    gen_base += "_negedge_action";
    sc_spawn( sc_clock_negedge_callback(this),
    	sc_gen_unique_name( gen_base.c_str() ), &negedge_options );
}
----

这里sc_clock需要用 sc_spawn_options，指定：

* 创造出来的是Method，而不是Thread(如果不指定，则默认创造Thread)
* 无需初始化
* 设置两个Method的静态敏感事件列表

sc_spawn设置的两个Method，宿主是 `sc_clock_posedge_callback(this)` 和
`sc_clock_negedge_callback(this)` 。两个都是临时对象，这不会带来问题，因为
在 `sc_spawn_object<T>` 构造的时候，对象是**拷贝**而不是引用进来的。两个Method
的函数体就是 `sc_clock_posedge_callback(this)` 和 `sc_clock_negedge_callback(this)`
的 `operator()` :

.src/sysc/communication/sc_clock.h
[source,cpp]
----

class SC_API sc_clock_posedge_callback {
public:
    sc_clock_posedge_callback(sc_clock* target_p) : m_target_p(target_p) {}
    inline void operator () () { m_target_p->posedge_action(); }
  protected:
    sc_clock* m_target_p;
};

class SC_API sc_clock_negedge_callback {
  public:
    sc_clock_negedge_callback(sc_clock* target_p) : m_target_p(target_p) {}
    inline void operator () () { m_target_p->negedge_action(); }
  protected:
    sc_clock* m_target_p;
};
----

所以实际上，当 `sc_clock` 的 m_next_posedge_event发生的时候，调用的是自己的 `posedge_action`
函数。当 m_next_negedge_event发生的时候，调用的是自己的 `negedge_action` 函数。
这也是这两个辅助类名字里的 `callback` 含义所在。

.src/sysc/communication/sc_clock.h
[source,cpp]
----
inline
void
sc_clock::posedge_action()
{
    m_next_negedge_event.notify_internal( m_negedge_time );
	m_new_val = true;
	request_update(); <1>
}

inline
void
sc_clock::negedge_action()
{
    m_next_posedge_event.notify_internal( m_posedge_time );
	m_new_val = false;
	request_update(); <1>
}
----
<1> sc_clock继承自sc_signal，需要调用 `request_update` 在UPDATE PHASE更新值

在 `posedge_action` 中，设置了延时 `m_negedge_time` 后，`m_next_negedge_event`
发生。同样，在 `negedge_action` 中，设置了延时 `m_posedge_time` 后， `m_next_posedge_event`
发生。如此，只要 m_next_posedge_event和m_next_negedge_event中有一个事件发生，sc_clock
就可以自我驱动下去，实现了时钟的功能。

m_next_posedge_event和m_next_negedge_event谁先发生，取决于sc_clock初始化的时候
的设置。这是概念上，一个clock时钟初始时是0还是1的区别：初始为0，那么先发生上升沿事件，初始为1
则先发生下降沿事件。例如，在sc_clock的某个构造函数中，有这么一段：

.src/sysc/communication/sc_clock.h
[source,cpp]
----
    init( sc_time( period_v_, period_tu_, simcontext() ),
	  duty_cycle_,
	  sc_time( start_time_v_, start_time_tu_, simcontext() ),
	  posedge_first_ );

    if( posedge_first_ ) {
	// posedge first
	m_next_posedge_event.notify_internal( m_start_time );
    } else {
	// negedge first
	m_next_negedge_event.notify_internal( m_start_time );
    }
----

先用 `init` 成员函数初始化值。接下来，如果要求现有上升沿，就让事件m_next_posedge_event
发生，否则就先让 m_next_negedge_event发生。可以想象，在init中，也是根据是否先要上升沿
决定当前值的：如果现有上升沿，初始值为0，否则为1：

[source,cpp]
----
    if( posedge_first_ ) {
	this->m_cur_val = false;
	this->m_new_val = false;
    } else {
	this->m_cur_val = true;
	this->m_new_val = true;
    }
----

sc_clock虽然只是一个sc_signal，但是借助sc_spawn，获得了类似于sc_module
这样的能够创建单独线程的能力，这就实现了sc_clock的自激励特性。