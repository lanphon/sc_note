---
---
:source-highlighter: coderay


= SystemC中的process
[[chap::process]]
:toc: left

== 引言

在<<chap::schedule_model, SystemC调度模型>>
一章中，我们已经可以了解SystemC是如何创建和使用Process的。
本部分是对SystemC中Method/Thread/CThread的总结，并且
总结了SystemC中process control部分的内容，重点介绍了reset process的实现，
process的disable/enable，以及process的suspend/resume。

在开始之前，我们需要厘清以下几个数据结构的关系：

* sc_process_b 是所有method/thread/cthread的基础类，直接继承自 `sc_object`
* sc_thread_process直接继承自sc_process_b，是表示thread线程的数据结构
* sc_method_process直接继承自sc_process_b，是表示method线程的数据结构
* sc_cthread_process直接继承自sc_thread_process，是表示cthread线程的数据结构
* sc_thread_handle是 `sc_thread_process*` 的别名
* sc_method_handle是 `sc_method_process*` 的别名
* sc_cthread_handle是 `sc_cthread_process*` 的别名
* sc_process_handle是基础类，不继承任何其他类，内部保存一个指向sc_process_b的指针，因此可以认为是一个包装类

== sc_process_b
[[data::sc_process_b]]

sc_process_b 是所有三种process的基类，并且这是一个接口类，派生自sc_process_b
的类需要实现对应到接口函数。

sc_process_b 作为一个接口类，不只是简单定义了接口函数，而是实现了非常丰富的
成员变量，以及相应的成员函数，以供继承类使用。

=== 成员变量

sc_process_b 继承自 <<data::sc_object, sc_object>> ，除了继承得到的成员变量以外，sc_process_b还
增加了非常丰富的成员变量，以支持process这一概念：

.src/sysc/kernel/sc_process.h
[source,cpp]
----
    // debugging stuff:

  public:
    const char*                 file;
    int                         lineno;
    int                         proc_id;

  protected:
    int                          m_active_areset_n; // number of aresets active.
    int                          m_active_reset_n;  // number of resets active.
    bool                         m_dont_init;       // true: no initialize call.
    spawn_t                      m_dynamic_proc;    // SPAWN_ELAB, SPAWN_START, SPAWN_SIM
    const sc_event*              m_event_p;         // Dynamic event waiting on.
    int                          m_event_count;     // number of events.
    const sc_event_list*         m_event_list_p;    // event list waiting on.
    sc_process_b*                m_exist_p;         // process existence link.
    bool                         m_free_host;       // free sc_semantic_host_p.
    bool                         m_has_reset_signal;  // has reset_signal_is.
    bool                         m_has_stack;       // true is stack present.
    bool                         m_is_thread;       // true if this is thread.
    sc_report*                   m_last_report_p;   // last report this process.
    sc_name_gen*                 m_name_gen_p;      // subprocess name generator
    sc_curr_proc_kind            m_process_kind;    // type of process.
    int                          m_references_n;    // outstanding handles.
    std::vector<sc_reset*>       m_resets;          // resets for process.
    sc_event*                    m_reset_event_p;   // reset event.
    sc_event*                    m_resume_event_p;  // resume event.
    sc_process_b*                m_runnable_p;      // sc_runnable link
    sc_process_host*             m_semantics_host_p;   // host for semantics.
    SC_ENTRY_FUNC                m_semantics_method_p; // method for semantics.
    int                          m_state;           // process state.
    std::vector<const sc_event*> m_static_events;   // static events waiting on.
    bool                         m_sticky_reset;    // see note 3 above.
    sc_event*                    m_term_event_p;    // terminated event.
    sc_throw_it_helper*          m_throw_helper_p;  // what to throw.
    process_throw_type           m_throw_status;    // exception throwing status
    bool                         m_timed_out;       // true if we timed out.
    sc_event*                    m_timeout_event_p; // timeout event.
    trigger_t                    m_trigger_type;    // type of trigger using.
    bool                         m_unwinding;       // true if unwinding stack.

protected:
    static sc_process_b* m_last_created_process_p; // Last process created.

----

sc_process_b的成员变量比较复杂，这里我们按照这些成员变量的作用一个一个说。

第一组是用来做debug目的的三个成员变量：

----
    const char*                 file;
    int                         lineno;
    int                         proc_id;
----

然后是做reset处理的两个成员变量，扮演的角色是相应reset事件的计数器（异步reset和同步reset）：

----
    int                          m_active_areset_n; // number of aresets active.
    int                          m_active_reset_n;  // number of resets active.
----

(((dont_initialize)))
[[api::sc_process_b::dont_initialize]]
单独的 `m_dont_init` 是用来表示process是否需要在最初执行一遍，参考
<<api::dont_initialize, 控制METHOD线程是否初始化>>部分的使用，Thread/CThread
部分和Method线程初始化控制同理：

----
    bool                         m_dont_init;       // true: no initialize call.
----

成员变量 `m_dynamic_proc` 与动态线程有关：

----
    spawn_t                      m_dynamic_proc;    // SPAWN_ELAB, SPAWN_START, SPAWN_SIM
----

而接下来的三个变量则是处理动态敏感的。如果wait/next_trigger在一个单独的event上，就使用
成员变量 `m_event_p` 保存这个事件的指针。如果wait/next_trigger在多个事件上，就使用
成员变量 `m_event_list_p` 保存创建出来的sc_event_list派生类的指针。对于AND LIST类型
的多个事件， `m_event_count` 保存着事件的个数，以方便事件发生的时候进行计数：

----
    const sc_event*              m_event_p;         // Dynamic event waiting on.
    int                          m_event_count;     // number of events.
    const sc_event_list*         m_event_list_p;    // event list waiting on.
----

成员变量 `m_exist_p` 构成了一条process之间的链表。这个成员变量在sc_process_b中没有
使用，在sc_method_process和sc_thread_process中，分别用一对set_next_exist和next_exist
API使用了这个成员变量，而set_next_exist API在创建线程的时候被调用，将新建的
process handle放入simc的 `m_process_table` 中：

----
    sc_process_b*                m_exist_p;         // process existence link.
----

接下来这四个bool成员变量都是创建时候设定的，其中 `m_is_thread` 在SystemC中没有得到使用。
`m_last_report_p` 是sc_report类型，目前还不清楚作用。 `m_name_gen_p` 是用来
辅助产生hierarchy命名的部分。而 `m_process_kind` 则是用来表示派生类的类型，可选的有
METHOD，THREAD和CTHREAD：

----
    bool                         m_free_host;       // free sc_semantic_host_p.
    bool                         m_has_reset_signal;  // has reset_signal_is.
    bool                         m_has_stack;       // true is stack present.
    bool                         m_is_thread;       // true if this is thread.
    sc_report*                   m_last_report_p;   // last report this process.
    sc_name_gen*                 m_name_gen_p;      // subprocess name generator
    sc_curr_proc_kind            m_process_kind;    // type of process.
----

成员变量 `m_references_n` 是用来做引用计数中，计数器角色的。这个动态线程
中的资源自动释放机制有关：

----
    int                          m_references_n;    // outstanding handles.
----

这一组成员变量和reset/resume机制有关：

----
    std::vector<sc_reset*>       m_resets;          // resets for process.
    sc_event*                    m_reset_event_p;   // reset event.
    sc_event*                    m_resume_event_p;  // resume event.
----

`m_runnable_p` 成员变量使得sc_process_b能够形成一个链表，链表中的每个节点
都是一个进入runnable状态的线程，可以在下一个delta cycle得到调度执行：

----
    sc_process_b*                m_runnable_p;      // sc_runnable link
----

如果一个process的 `m_runnable_p` 指针为空，那么就意味着这process要么在当前delta cycle
已经执行完毕了，所以从runnable列表中移出来，要么这个process在当前的delta cycle无需运行。

接下来这一组成员变量就是sc_process_b所代表的线程的入口函数，以及基类指针：

----
    sc_process_host*             m_semantics_host_p;   // host for semantics.
    SC_ENTRY_FUNC                m_semantics_method_p; // method for semantics.
----

[[data::sc_process_b::m_state]]
`m_state` 表示的是当前线程的状态，这个integer类型采用了位掩码的方式，来表示各种
不同的状态的组合：

----
    int                          m_state;           // process state.
----

目前定义的状态位有：

.src/sysc/kernel/sc_process.h
[source,cpp]
----
    enum process_state {
	ps_bit_disabled = 1,      // process is disabled.
	ps_bit_ready_to_run = 2,  // process is ready to run.
        ps_bit_suspended = 4,     // process is suspended.
	ps_bit_zombie = 8,        // process is a zombie.
        ps_normal = 0             // must be zero.
    };
----

sc_process_b构造的时候， `m_state`的值为 `ps_normal` 。ps_normal是个特殊的值，它
并不是一个位掩码，而是一个全0的值。这意味着当没有任何一个位掩码置位的时候，就是ps_normal。
所以在使用的时候，ps_normal可以不需要显式赋值，只需要将原先状态位的位掩码一个一个去掉，全部
清除之后，状态自然变成了ps_normal了。


`m_static_events` 则是本process所设置的静态事件对象列表，这些事件之间是或的关系，只要有一个
事件发生，就可能唤醒此线程：

----
    std::vector<const sc_event*> m_static_events;   // static events waiting on.
----

这四个成员变量和sticky_reset以及异常机制有关：

----
    bool                         m_sticky_reset;    // see note 3 above.
    sc_event*                    m_term_event_p;    // terminated event. <1>
    sc_throw_it_helper*          m_throw_helper_p;  // what to throw.
    process_throw_type           m_throw_status;    // exception throwing status
----
<1> 当sc_process_b的 `disconnect_process` 被调用的时候，m_term_event_p被notify

`m_throw_status` 是标记本process应当抛出的类型。这个状态位会在reset/kill等被调用的时候标记，然后
在合适的地方（method的run_process，以及thread的suspend_me）检查，并根据需要抛出异常。
在reset/kill的时候，我们会着重介绍这个变量的使用。

`m_timed_out` 表示process是否超时，目前没看到与之相关的代码：

----
    bool                         m_timed_out;       // true if we timed out.
----

`m_timeout_event_p` 则保存了当process动态敏感时候，带延时时间时，延时时间对象的指针：

----
    sc_event*                    m_timeout_event_p; // timeout event.
----

`m_trigger_type` 表明了当前的trigger类型，动态和静态trigger有不同的处理流程：

----
    trigger_t                    m_trigger_type;    // type of trigger using.
----

一个process只能是静态或者动态。当process处于STATIC状态时，使用 `m_static_events`
里的静态事件trigger。如果process处于非STATIC的状态时，说明process动态trigger，这个
时候 `trigger_static` 就会会略来自 `m_static_events` 所记录的sc_event的请求，只是
简单返回。

最后一个成员变量 `m_unwinding` 与异常处理的时候，堆栈展开有关：

----
    bool                         m_unwinding;       // true if unwinding stack.
----

除了这些成员变量以外，sc_process_b还有一个静态成员变量， `m_last_created_process_p` ，
这个静态成员变量在每次sc_process_b构建的时候，都会获得当前process的指针值。

----
protected:
    static sc_process_b* m_last_created_process_p; // Last process created.
----

这个 `m_last_created_process_p` 是实现 `last_created_process_handle`
的基石。

==== 静态/动态事件

Process的成员变量中，有多个与sc_event相关的部分，这些是process静态或者动态调度时所依赖
的时间对象。Process使用哪些对象，要根据 `m_trigger_type` 判断：

* trigger type为 `STATIC` ，使用 m_static_events 里所保存的事件对象，此时process是静态process，除此之外所有的trigger type都是动态process
* trigger type为 `EVENT` ，使用 m_event_p 所保存的事件对象
* trigger type为 `OR_LIST` ，使用 m_event_list_p 所保存的事件列表对象
* trigger type为 `AND_LIST` ，使用 m_event_list_p 所保存的事件列表对象，并辅助使用 m_event_count 记录事件发生的数目
* trigger type为 `TIMEOUT` ，使用 m_timeout_event_p 所保存的事件对象
* trigger type为 `EVENT_TIMEOUT` ，使用 m_event_p 和 m_timeout_event_p 两个事件对象
* trigger type为 `OR_LIST_TIMEOUT` ，使用 m_event_list_p 和 m_timeout_event_p 两个对象
* trigger type为 `AND_LIST_TIMEOUT` ，使用 m_event_list_p 和 m_timeout_event_p 两个对象，并辅助使用 m_event_count

一种特定trigger type下，不使用的动态部分需要清空。

=== 重要成员函数

sc_process_b还实现了非常多的基础函数，以供派生类使用。

==== semantics
[[api::sc_process_b::semantics]]

sc_process_b的semantics函数会启动sc_process_b所保存的线程函数，这个我们在
<<api::semantic, coroutine>>部分已经讲过了。除此之外，semantics还需要
处理一些异常相关的部分。semantics的函数实现如下：

.src/sysc/kernel/sc_process.h
[source,cpp]
----
inline void sc_process_b::semantics()
{

    // within this function, the process has a stack associated

    scoped_flag scoped_stack_flag( m_has_stack ); <1>

    sc_assert( m_process_kind != SC_NO_PROC_ );

    // Determine the reset status of this object instance and potentially
    // trigger its notify event:

    // See if we need to trigger the notify event:

    if ( m_reset_event_p &&
         ( (m_throw_status == THROW_SYNC_RESET) ||
	   (m_throw_status == THROW_ASYNC_RESET) )
    ) {
        trigger_reset_event();
    }

    // Set the new reset status of this object based on the reset counts:

    m_throw_status = m_active_areset_n ? THROW_ASYNC_RESET :
        ( m_active_reset_n  ?  THROW_SYNC_RESET : THROW_NONE);

    // Dispatch the actual semantics for the process:

#   ifndef SC_USE_MEMBER_FUNC_PTR
        m_semantics_method_p->invoke( m_semantics_host_p );
#   else
        (m_semantics_host_p->*m_semantics_method_p)();
#   endif
}
----
<1> 在semantics开始，将m_has_stack设置为true，当semantics执行完毕的时候，`scoped_stack_flag` 
的析构函数会自动设置m_has_stack为false，这意味着对于永远不会退出的Thread/Cthread而言，运行过程中时钟保持着m_has_stack为true，参见<<concept::process::control::kill::thread, thread的kill_process>>部分的应用

在启动线程函数之前，semantics会首先检查变量 `m_throw_status`的值，
看是否有需要抛出什么东西。如果需要异步或者同步reset，那就
调用 `trigger_reset_event`，这其实就是一个很简单的事件对象的 `notify`

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
void sc_process_b::trigger_reset_event()
{
    if ( m_reset_event_p ) m_reset_event_p->notify();
}
----

接下来 `m_throw_status` 会根据 `m_active_areset_n` 和 `m_active_reset_n`
的值被赋值，其中异步reset计数器优先级高于同步reset计数器。

在同步reset的时候，我们会调用 
<<api::sc_process_handle::sync_reset_on, sync_reset_on>> 开启同步reset周期。这会
调用 <<api::sc_process_b::reset_changed, reset_changed>>，将 `m_active_reset_n` 计数器加一。
`m_active_reset_n` 计数器会一直保持，直到
<<api::sc_process_handle::sync_reset_on, sync_reset_off>>
被调用为止。这意味着，如果 `sync_reset_on` 和 `sync_reset_off`
所定义的同步reset周期内，process被多次启动，那么每一次 `m_throw_status`
都会保持 `THROW_SYNC_RESET` 不变，并且每次都会
调用<<api::sc_process_b::trigger_reset_event, trigger reset event>> footnote:[这里假设
没有异步reset]。


==== add_static_event

[[api::sc_process_b::add_static_event]]
`add_static_event` 将一个事件加入到 `m_static_events` 列表中，同时也将
本process cast为合适的派生类，调用事件的
<<api::sc_event::add_static, `add_static`>>成员函数，设置到事件中：

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_process_b::add_static_event"
//
// This method adds an event to the list of static events, and sets the
// event up to call back this process when it fires.
//------------------------------------------------------------------------------
void sc_process_b::add_static_event( const sc_event& e )
{
    sc_method_handle method_h; // This process as a method.
    sc_thread_handle thread_h; // This process as a thread.


    // CHECK TO SEE IF WE ARE ALREADY REGISTERED WITH THE EVENT:

    for( int i = m_static_events.size() - 1; i >= 0; -- i ) {
        if( &e == m_static_events[i] ) {
            return;
        }
    }

    // REMEMBER THE EVENT AND THEN REGISTER OUR OBJECT INSTANCE WITH IT:

    m_static_events.push_back( &e );

    switch ( m_process_kind )
    {
      case SC_THREAD_PROC_:
      case SC_CTHREAD_PROC_:
        thread_h = static_cast<sc_thread_handle>( this );
        e.add_static( thread_h );
        break;
      case SC_METHOD_PROC_:
        method_h = static_cast<sc_method_handle>( this );
        e.add_static( method_h );
        break;
      default:
        sc_assert( false );
        break;
    }
}
----

注意，sc_process_b并没有定义与add_static_event相对应的
add_dynamic_event，这是因为static的event是在process 创建的时候指定的。而
dynamic event则是在<<concept::wait, wait>>或者<<concept::next_trigger, next_trigger>>
时候设置的。对于事件，将一个sc_process_b通过add_dynamic列入本事件所关联的动态
事件，也是在wait/next_trigger中**动态**完成的。

==== remove_static_events

[[api::sc_process_b::remove_static_events]]
与add_static_event功能相反的是remove_static_events:

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_process_b::remove_static_events"
//
// This method removes this object instance from the events in its static
// event list.
//------------------------------------------------------------------------------
void
sc_process_b::remove_static_events()
{
    sc_method_handle method_h; // This process as a method.
    sc_thread_handle thread_h; // This process as a thread.

    switch ( m_process_kind )
    {
      case SC_THREAD_PROC_:
      case SC_CTHREAD_PROC_:
        thread_h = static_cast<sc_thread_handle>( this );
        for( int i = m_static_events.size() - 1; i >= 0; -- i ) {
            m_static_events[i]->remove_static( thread_h );
        }
        m_static_events.resize(0);
        break;
      case SC_METHOD_PROC_:
        method_h = static_cast<sc_method_handle>( this );
        for( int i = m_static_events.size() - 1; i >= 0; -- i ) {
            m_static_events[i]->remove_static( method_h );
        }
        m_static_events.resize(0);
        break;
      default: // Some other type, it needs to clean up itself.
        // std::cout << "Check " << __FILE__ << ":" << __LINE__ << std::endl;
        break;
    }
}
----

这里的过程和 `add_static_event` 相反。对于每一个 `m_static_events`
的事件，调用其 <<api::sc_event::remove_static, `remove_static`>> 将本process handle从sc_event的
static process列表中移除。最后将 `m_static_events` 清零。

一般来说，很少需要将process的static events列表清除，因为在process的生命周期中，process
都需要依赖这些静态事件的发生来被调度。只有当process的生命周期显式地被要求结束（在disconnect_process中），才需要调用remove_static_events。

==== remove_dynamic_events

[[api::sc_process_b::remove_dynamic_events]]
在process生命周期显式被结束的时候，还需要清除动态敏感事件，因此有一个 `remove_dynamic_events`
的成员函数：

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_process_b::remove_dynamic_events"
//
// This method removes this object instance from the events in its dynamic
// event lists.
//
// Arguments:
//     skip_timeout = skip cleaning up the timeout event, it will be done
//                    by sc_event_notify().
//------------------------------------------------------------------------------
void
sc_process_b::remove_dynamic_events( bool skip_timeout )
{
    sc_method_handle  method_h;   // This process as a method.
    sc_thread_handle  thread_h;   // This process as a thread.

    m_trigger_type = STATIC;
    switch ( m_process_kind )
    {
      case SC_THREAD_PROC_:
      case SC_CTHREAD_PROC_:
        thread_h = static_cast<sc_thread_handle>(this);
	if ( thread_h->m_timeout_event_p && !skip_timeout ) {
	    thread_h->m_timeout_event_p->remove_dynamic(thread_h);
	    thread_h->m_timeout_event_p->cancel();
	}
        if ( m_event_p )
        {
            m_event_p->remove_dynamic( thread_h );
            m_event_p = 0;
        }
        if ( m_event_list_p )
        {
            m_event_list_p->remove_dynamic( thread_h, 0 );
            m_event_list_p->auto_delete();
	    m_event_list_p = 0;
        }
        break;
      case SC_METHOD_PROC_:
        method_h = static_cast<sc_method_handle>(this);
	if ( method_h->m_timeout_event_p && !skip_timeout ) {
	    method_h->m_timeout_event_p->remove_dynamic(method_h);
	    method_h->m_timeout_event_p->cancel();
	}
        if ( m_event_p )
        {
            m_event_p->remove_dynamic( method_h );
            m_event_p = 0;
        }
        if ( m_event_list_p )
        {
            m_event_list_p->remove_dynamic( method_h, 0 );
            m_event_list_p->auto_delete();
	    m_event_list_p = 0;
        }
        break;
      default: // Some other type, it needs to clean up itself.
        // std::cout << "Check " << __FILE__ << ":" << __LINE__ << std::endl;
        break;
    }
}
----

对于sc_process_b而言，静态事件都保存在 `m_static_events` 列表中，然而动态事件：

* 单一的动态事件，指针保存在 m_event_p 中
* 组合的动态事件列表，指针保存在 m_event_list_p 中
* 定时的内部创建的事件（wait/next_trigger中带延时功能），保存在 m_timed_event_p 中

因此在 `remove_dynamic_events` 的时候，需要一个一个检查是否有效，并移除。

需要注意的是， `remove_dynamic_events` 可以接受一个布尔参数，表明是否跳过timeout event
的移除。默认情况下会将所有动态事件移除，如果设置跳过timed event，则移除除了timeout
event以外所有的动态事件（其实只有单一事件和多个事件列表）。只有在trigger_dynamic的时候，
process被disable，才会传入一个参数要求保留timeout event，但这么设计的原因目前未知。

==== child object management

sc_process_b中有三个用于管理子对象的函数：

* add_child_object
* remove_child_object
* get_child_objects 

这3个都调用基类sc_object的相应函数，来管理process的子对象，sc_process_b在其中
增加了引用计数 `m_references_n` 管理部分的工作：

.src/sysc/kernel/sc_process.h
[source,cpp]
----
inline void
sc_process_b::add_child_object( sc_object* object_p )
{
    sc_object::add_child_object( object_p );
    reference_increment();
}

inline bool
sc_process_b::remove_child_object( sc_object* object_p )
{
    if ( sc_object::remove_child_object( object_p ) ) {
	    reference_decrement();
            return true;
    }
    else
    {
        return false;
    }
}

inline const ::std::vector<sc_object*>&
sc_process_b::get_child_objects() const
{
    return m_child_objects;
}
----

==== disconnect_process
[[api::sc_process_b::disconnect_process]]

disconnect_process 用以在kill_process中，从其他与之关联的数据结构，如monitor, event等，
移除本process:

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
void sc_process_b::disconnect_process()
{
    int               mon_n;      // monitor queue size.
    sc_thread_handle  thread_h;   // This process as a thread.

    // IF THIS OBJECT IS PINING FOR THE FJORDS WE ARE DONE:

    if ( m_state & ps_bit_zombie ) return;

    // IF THIS IS A THREAD SIGNAL ANY MONITORS WAITING FOR IT TO EXIT:

    switch ( m_process_kind )
    {
      case SC_THREAD_PROC_:
      case SC_CTHREAD_PROC_:
        thread_h = static_cast<sc_thread_handle>(this);
        mon_n = thread_h->m_monitor_q.size();
        if ( mon_n )
        {
            for ( int mon_i = 0; mon_i < mon_n; mon_i++ )
            {
                thread_h->m_monitor_q[mon_i]->signal( thread_h,
			      sc_process_monitor::spm_exit);
            }
        }
        break;
      default:
        break;
    }

    // REMOVE EVENT WAITS, AND REMOVE THE PROCESS FROM ITS SC_RESET:

    remove_dynamic_events();
    remove_static_events();

    for ( std::vector<sc_reset*>::size_type rst_i = 0; rst_i < m_resets.size(); rst_i++ )
    {
        m_resets[rst_i]->remove_process( this );
    }
    m_resets.resize(0);


    // FIRE THE TERMINATION EVENT, MARK AS TERMINATED, AND DECREMENT THE COUNT:
    //
    // (1) We wait to set the process kind until after doing the removals
    //     above.
    // (2) Decrementing the reference count will result in actual object
    //     deletion if we hit zero.

    m_state = ps_bit_zombie;
    if ( m_term_event_p ) m_term_event_p->notify();
    reference_decrement();
}
----

disconnect process主要的动作有：

* 对于thread，调度monitor的signal接口函数，通知线程退出
* 使用<<api::sc_process_b::remove_static_events, remove_static_events>>和
<<api::sc_process_b::remove_dynamic_events, remove_dynamic_events>>断开与sc_event
之间的连接
* 从每个reset中移除本process，并清除本process保存的reset信息
* 将状态m_state置为zombie状态
* 如果有terminated event，就notify terminated event
* 减少引用计数器

调用了disconnect_process的process进入zombie状态，m_state被标记为ps_zombie
bit位。对一个zombie的process调用disconnect_process会直接返回。

==== delete_process
[[api::sc_process_b::delete_process]]

delete_process可以将本process所有分配的资源释放掉：

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
void sc_process_b::delete_process()
{
    sc_assert( m_references_n == 0 );

    // Immediate deletion:

    if ( NULL == sc_get_current_process_b() )
    {
        delete this; <1>
    }

    // Deferred deletion: note we set the reference count to one  for the call
    // to reference_decrement that occurs in sc_simcontext::crunch().

    else
    {
        m_references_n = 1;
        detach();
        simcontext()->mark_to_collect_process( this );
    }
}
----
<1> 之所以能够delete，是因为所有的process都是new出来的

注意只有引用计数为0的时候，才能够调用delete_process。如果删除的请求来源不是来自一个process，那么
立即删除，否则就将这个process标记为待回收的process。

待回收的process在每次<<concept::crunch, crunch>>的最后，do_collect_processes
会调用每一个待回收的process的reference_decrement()
[[api::sc_simcontext::do_collect_processes]]

.src/sysc/kernel/sc_simcontext.cpp
[source,cpp]
----
void sc_simcontext::do_collect_processes()
{
    while( ! m_collectable->empty() )
    {
        sc_process_b* del_p = m_collectable->front();
        m_collectable->pop_front();
        del_p->reference_decrement();
    }
}
----

[[api::sc_process_b::reference_decrement]]
而在sc_process_b的reference_decrement中，将引用计数减去一，如果引用计数为0，则
再次调用delete_process:

.src/sysc/kernel/sc_process.h
[source,cpp]
----
inline void sc_process_b::reference_decrement()
{
    m_references_n--;
    if ( m_references_n == 0 ) delete_process();
}
----

在simc的do_collect_processes之前，会调用reset_curr_proc，将当前的process
信息重置：

[source,cpp]
----
    this->reset_curr_proc();
    do_collect_processes();
----

所以这一次，sc_get_current_proc_b返回空指针，delete_process就可以正常 `delete this` 了。

==== reset_process
[[api::sc_process_b::reset_process]]

不同于disconnect_process或者delete_process, reset_process的处理相对来说比较复杂，因为
reset_process需要reset之后，process还能够正常运行。对于Method线程而言这比较容易做到，因为每个
Method执行的时候都是完整执行函数体的。但是对于Thread/CThread线程而言，reset就没那么简单了。

关于reset_process的内容，请参考<<concept::process::reset, reset机制>>的
<<api::sc_process_b::reset_process::impl, reset执行流程>>部分。

==== reset_event and terminated_event
[[api::sc_process_b::reset_event]]

sc_process_b的 `reset_event` 返回一个与本process相关联的reset event的引用。如果
成员变量 `m_reset_event_p` 为空，就新建一个kernel event：

[[api::sc_process_b::terminated_event]]
与 `reset_event` 类似的还有一个 `terminated_event` ，返回内部新建的terminated event
的引用。当process调用<<api::sc_process_b::disconnect_process, disconnect_process>>
的时候，terminated event被触发。

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
sc_event& sc_process_b::reset_event()
{
    if ( !m_reset_event_p )
    {
        m_reset_event_p = new sc_event( sc_event::kernel_event, "reset_event" );
    }
    return *m_reset_event_p;
}
----

这个sc_event可以用来用来做静态或者动态的调度事件使用，也可以用在其他event能够使用的场合。
[[api::sc_process_b::trigger_reset_event]]

在trigger_reset_event成员函数中，这个reset event可以被trigger:

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
void sc_process_b::trigger_reset_event()
{
    if ( m_reset_event_p ) m_reset_event_p->notify();
}
----

==== last_created_process_handle

last_created_process_handle是一个静态成员函数，用以返回最后一次创建的process
的handle:

.src/sysc/kernel/sc_process_handle.h
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_process_b::last_created_process_handle"
//
// This method returns the kind of this process.
//------------------------------------------------------------------------------
inline sc_process_handle sc_process_b::last_created_process_handle()
{
    return sc_process_handle(m_last_created_process_p);
}
----

这里面主要借助了 sc_process_b 静态成员变量 m_last_created_process_p 。

==== start_unwinding, clear_unwinding and is_unwinding

start_unwinding, clear_unwinding, 以及 is_unwinding，这三个函数实际上
只是操作 `m_unwinding` 这个状态变量：

[[api::sc_process_b::start_unwinding]]
.src/sysc/kernel/sc_process.h
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_process_b::start_unwinding"
//
// This method flags that this object instance should start unwinding if the
// current throw status requires an unwind.
//
// Result is true if the flag is set, false if the flag is already set.
//------------------------------------------------------------------------------
inline bool sc_process_b::start_unwinding()
{
    if ( !m_unwinding )
    {
	switch( m_throw_status )
	{
	  case THROW_KILL:
	  case THROW_ASYNC_RESET:
	  case THROW_SYNC_RESET:
	    m_unwinding = true;
	     return true;
	  case THROW_USER:
	   default:
	     break;
	 }
    }
    return false;
}
----

对于start_unwinding而言，只有THROW_KILL以及THROW_ASYNC_RESET/THROW_SYNC_RESET，即
在kill或者异步/同步reset中，才需要展开调用栈，在其他情况下是不需要展开调用栈的。

sc_process_b的start_unwinding只在构造sc_unwind_exception的时候被调用。如果构造
sc_unwind_exception的process处于kill或者reset状态，process自己的m_unwinding
就会被标记为true，否则保持原样：

.src/sysc/kernel/sc_except.cpp
[source,cpp]
----
sc_unwind_exception::sc_unwind_exception( sc_process_b* proc_p, bool is_reset )
  : m_proc_p(proc_p), m_is_reset( is_reset )
{
  sc_assert( m_proc_p );
  m_proc_p->start_unwinding();
}
----

[[api::sc_process_b::clear_unwinding]]
.src/sysc/kernel/sc_process.h
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_process_b::clear_unwinding"
//
// This method clears this object instance's throw status and always returns
// true.
//------------------------------------------------------------------------------
inline bool sc_process_b::clear_unwinding()
{
    m_unwinding = false;
    return true;
}
----

而clear_unwinding只是简单将m_unwinding标志位置为false即可。

[[api::sc_process_b::is_unwinding]]
.src/sysc/kernel/sc_process.h
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_process_b::is_unwinding"
//
// This method returns true if this process is unwinding from a kill or reset.
//------------------------------------------------------------------------------
inline bool sc_process_b::is_unwinding() const
{
    return m_unwinding;
}
----

is_unwinding则返回m_unwinding的状态。

== sc_process_handle
[[data::sc_process_handle]]

=== 成员变量

sc_process_handle内部只保存了一个指向基类sc_process_b指针的成员变量 `m_target_p`:

.src/sysc/kernel/sc_process_handle.h
[source,cpp]
----
  protected:
    sc_process_b* m_target_p;   // Target for this object instance.

  protected:
    static std::vector<sc_event*>  empty_event_vector;  // If m_target_p == 0.
    static std::vector<sc_object*> empty_object_vector; // If m_target_p == 0.
    static sc_event                non_event;           // If m_target_p == 0.
----

另外三个静态成员变量，是为了在 `m_target_p` 为空的情况下，某些需要返回
对象引用的成员函数能够正确返回引用而添加的。

=== 成员函数

sc_process_handle的成员函数，绝大多数都是调用保存的 `m_target_p` 的相应同名或者
近似名称的成员函数:

* `disable` 调用了sc_process_b的<<concept::process::control::disable_enable, disable_process>>
* `enable` 调用了sc_process_b的<<concept::process::control::disable_enable, enable_process>>
* `dont_initialize` 调用了sc_process_b的<<api::sc_process_b::dont_initialize, dont_initialize>>
* `dump_state` 调用了sc_process_b的dump_state
* `dynamic` 调用了sc_process_b的dynamic
* `get_child_events` 调用了sc_process_b的get_child_events
* `get_child_objects` 调用了sc_process_b的get_child_objects
* `get_parent_object` 调用了sc_process_b的get_parent_object
* `is_unwinding` 调用了sc_process_b的<<api::sc_process_b::is_unwinding, is_unwinding>>
* `kill` 调用了sc_process_b的<<concept::process::control::kill, kill_process>>
* `name` 调用了sc_process_b的name
* `basename` 调用了sc_process_b的basename
* `proc_kind` 调用了sc_process_b的proc_kind
* `reset` 调用了sc_process_b的<<api::sc_process_b::reset_process, reset_process>>
* `reset_event` 调用了sc_process_b的<<api::sc_process_b::reset_event, reset_event>>
* `resume` 调用了sc_process_b的<<api::sc_process_b::resume_process, resume_process>>
* `suspend` 调用了sc_process_b的<<api::sc_process_b::suspend_process, suspend_process>>
* `sync_reset_off` 调用了sc_process_b的<<api::sc_process_b::reset_process, reset_process>>
* `sync_reset_on` 调用了sc_process_b的<<api::sc_process_b::reset_process, reset_process>>
* `terminated` 调用了sc_process_b的terminated
* `terminated_event` 调用了sc_process_b的<<api::sc_process_b::terminated_event, terminated_event>>

== sc_thread_process
[[data::sc_thread_process]]

=== 成员变量

除了基类 `sc_process_b` 的成员变量以外，((sc_thread_process))为支持协程
能力，增加了如下几个成员变量：

.src/sysc/kernel/sc_thread_process.h
[source,cpp]
----
  protected:
    sc_cor*                          m_cor_p;        // Thread's coroutine.
    std::vector<sc_process_monitor*> m_monitor_q;    // Thread monitors.
    std::size_t                      m_stack_size;   // Thread stack size.
    int                              m_wait_cycle_n; // # of waits to be done.
----

`m_cor_p` 以及 `m_stack_size` 是为支持协程而添加的。
`m_cor_p` 就是代表本thread的协程参数，用以启动、挂起和恢复协程时使用。
`m_stack_size` 则是有栈协程的协程栈的大小。

`m_monitor_q` 是thread monitor，后续我们再介绍。

最后一个m_wait_cycle_n，主要用在
<<api::sc_thread_process::wait_cycles, wait_cycles>>成员函数中，用以支持设定
特定等待时钟周期的场景。

=== 重要成员函数

==== throw_reset
[[api::sc_thread_process::throw_reset]]

throw_reset是 <<api::sc_process_b::reset_changed, reset_changed>> 成员函数中最终调用的
部分。throw_reset是个接口函数，method和thread都需要实现自己的throw_reset函数。

从名字上来看，throw_reset的本意在于抛出一个reset，但是以何种形式抛出，取决于SystemC的实现。实际上
systemC在throw_reset里并不真正抛出reset，而是做了标记，等到需要的时候才抛出reset。以下是
thread的throw_reset的实现：

.src/sysc/kernel/sc_thread_process.cpp
[source,cpp]
----
void sc_thread_process::throw_reset( bool async )
{
    // IF THE PROCESS IS CURRENTLY UNWINDING OR IS ALREADY A ZOMBIE
    // IGNORE THE RESET:

    if ( m_unwinding )
    {
        SC_REPORT_WARNING( SC_ID_PROCESS_ALREADY_UNWINDING_, name() );
        return;
    }

    if ( m_state & ps_bit_zombie )
        return;


    // Set the throw type and clear any pending dynamic events:

    m_throw_status = async ? THROW_ASYNC_RESET : THROW_SYNC_RESET;
    m_wait_cycle_n = 0;

    // If this is an asynchronous reset:
    //
    //   (a) Cancel any dynamic events
    //   (b) Set the thread up for execution:
    //         (i) If we are in the execution phase do it now.
    //         (ii) If we are not queue it to execute next when we hit
    //              the execution phase.

    if ( async )
    {
        m_state = m_state & ~ps_bit_ready_to_run;
        remove_dynamic_events();
	if ( simcontext()->evaluation_phase() )
	{
            simcontext()->preempt_with( this );
	}
	else
	{
	    if ( is_runnable() )
	        simcontext()->remove_runnable_thread(this);
	    simcontext()->execute_thread_next(this);
	}
    }
}
----

首先检查unwinding标志和state位，这里不允许一个已经unwinding的thread抛出reset，并且
对于zombie的process没必要抛出reset。然后根据是否是异步异常来设置 m_throw_status，并
清除m_wait_cycle_n变量。 m_wait_cycle_n变量记录的是thread线程动态wait还剩下的数目，
如果thread线程被reset掉，就需要把这个值也重置为0.

''''

如果是同步reset，这里就无需多余的动作，可以直接返回了。同步的reset并不会在这里抛出异常，
而是根据字面意思，会在process执行的时候**同步**抛出。这个位置在
<<api::sc_thread_process::suspend_me, suspend_me>>的地方。回忆一下，对于
一个thread process，如果调用了suspend_me，那么这个thread process会在yield
的地方挂起，交出CPU执行权。等到这个thread process再次被调度执行的时候，才会从
yield返回。这意味着，每次从yield返回之后的代码，就是thread process每次执行（除了
初始化的第一次之外）的代码。以下是从yield返回值后的代码：

.src/sysc/kernel/sc_thread_process.h
[source,cpp]
----
    // IF THERE IS A THROW TO BE DONE FOR THIS PROCESS DO IT NOW:
    //
    // (1) Optimize THROW_NONE for speed as it is the normal case.
    // (2) If this thread is already unwinding then suspend_me() was
    //     called from the catch clause to throw an exception on another
    //     process, so just go back to the catch clause.

    if ( m_throw_status == THROW_NONE ) return;

    if ( m_unwinding ) return;

    switch( m_throw_status )
    {
      case THROW_ASYNC_RESET:
      case THROW_SYNC_RESET:
        DEBUG_MSG( DEBUG_NAME , this, "throwing reset for");
	if ( m_reset_event_p ) m_reset_event_p->notify();
        throw sc_unwind_exception( this, true ); <1>

      case THROW_USER:
        DEBUG_MSG( DEBUG_NAME, this, "invoking throw_it for");
	m_throw_status = m_active_areset_n ? THROW_ASYNC_RESET :
	                                  (m_active_reset_n ? THROW_SYNC_RESET :
			                  THROW_NONE);
        m_throw_helper_p->throw_it();
	break;

      case THROW_KILL:
        DEBUG_MSG( DEBUG_NAME, this, "throwing kill for");
	throw sc_unwind_exception( this, false ); <1>

      default: // THROWING_NOW
        if( !unwinding_preempted )
            SC_REPORT_FATAL( SC_ID_INTERNAL_ERROR_
                           , "unexpected unwinding/throw status" );
        // may continue, if suppressed
        m_throw_status = THROW_NONE;
        DEBUG_MSG( DEBUG_NAME, this, "restarting thread");
        break;
    }
----
<1> 同步/异步reset和KILL时候的异常抛出类型一致，只不过参数不同

如果thread process执行过程中没有设置抛出什么东西，或者已经unwinding了，suspend_me就可以直接结束执行。反之，如果 `m_throw_status` 被设置为需要同步或者异步reset，这里除了
notify以下 <<api::sc_process_b::reset_event, reset event>>之外，主要就是
抛出一个 `sc_unwind_exception(this, true)` 类型的异常了。

同时我们也能看到，对于 m_throw_status 为THROW_KILL的情况，SystemC也是抛出
一个 `sc_unwind_exception(this, false)` 类型的异常来结束处理的。第二个布尔
型参数用来设置异常是否是reset:

.src/sysc/kernel/sc_except.h
[source,cpp]
----
  protected:
    explicit
    sc_unwind_exception( sc_process_b* target_p, bool is_reset = false );
----



抛出来的异常会在 <<api::sc_thread_cor_fn, sc_thread_cor_fn>> 这个自由函数
中被catch住。 以下是相关的代码片段：

.src/sysc/kernel/sc_thread_process.cpp
[source,cpp]
----
    while( true ) {

        try {
            thread_h->semantics(); <2>
        }
        catch( sc_user ) {
            continue;
        }
        catch( sc_halt ) {
            ::std::cout << "Terminating process "
                      << thread_h->name() << ::std::endl;
        }
        catch( const sc_unwind_exception& ex ) {
	    ex.clear();
            if ( ex.is_reset() ) continue;
        }
        catch( ... ) {
            sc_report* err_p = sc_handle_exception();
            thread_h->simcontext()->set_error( err_p );
        }
        break;
    }
----

如果是 `sc_unwind_exception` 类型的异常，如果是reset，那么就继续执行当前的while
循环，这等同于将thread线程函数 **重新** 执行一遍，来达到reset thread 线程的目的。
如果不是reset，那就是kill了，此时走到后边的 `break` 会结束当前while循环，执行后续
的kill process收尾动作。

''''

如果throw_reset的时候，要求是异步reset，那么在throw_reset内还需要做其他的动作。

[source,cpp]
----
    if ( async )
    {
        m_state = m_state & ~ps_bit_ready_to_run;
        remove_dynamic_events();
	if ( simcontext()->evaluation_phase() )
	{
            simcontext()->preempt_with( this );
	}
	else
	{
	    if ( is_runnable() )
	        simcontext()->remove_runnable_thread(this);
	    simcontext()->execute_thread_next(this);
	}
    }
----

首先是将状态位的 ready to run清除掉，并移除所有动态的event。

如果当前仿真在EVALUATE PHASE，这意味着reset请求的来源来自其中当前delta cycle
中某一个runnable列表中的process。这种情况下调用simc的
<<api::sc_simcontext::preempt_with::thread>>
来立即执行即将被reset的process。

如果当前仿真没有在EVALUATE PHASE，例如正在UPDATE PHASE，那么reset的请求来源
不是某个process. 例如，某个signal作为reset，直到UPDATE PHASE值才会更新，并
触发reset请求（这个例子存疑，需要仔细斟酌下是否有可能）。
这种情况下先检查这个process是否在runnable中，如果在，则移除。移除的目的并不是为了
不执行这个process，恰恰相反，接下来我们要调用 `execute_thread_next`
将这个process加入到runnable的最前边（method或者thread列表第一个）。这样
到了下一个delta cycle的时候，process将会是第一个得到执行的。

执行process的结果和同步reset是一样的。

''''

异步reset和同步reset的区别在于：

* 异步reset会尽可能早地将process reset掉，如果reset请求来自其它process，则使用
<<api::sc_simcontext::preempt_with, preempt_with>>抢占当前process，进行reset。
如果reset请求来自其它地方，则将本process放入runnable最前边，以使得下一个delta cycle本process就能够执行。
* 同步reset只会将需要reset的proces标记好，等到下一次这个需要reset的process执行的时候，才
reset

==== throw_user
[[api::sc_thread_process::throw_user]]
类似throw_reset, throw_user抛出一个用户自定义的异常。

== sc_method_process
[[data::sc_method_process]]

=== 成员变量

((sc_method_process))在基类 `sc_process_b` 的基础上增加了如下几个成员变量：

.src/sysc/kernel/sc_method_process.h
[source,cpp]
----
    sc_cor*                          m_cor;        // Thread's coroutine.
    std::size_t                      m_stack_size; // Thread stack size.
    std::vector<sc_process_monitor*> m_monitor_q;  // Thread monitors.
----

然而这三个成员变量在sc_method_process中并没有得到使用。

=== 重要成员函数

==== throw_reset
[[api::sc_method_process::throw_reset]]

对于method的throw_reset，其实现如下：

.src/sysc/kernel/sc_method_process.cpp
[source,cpp]
----
void sc_method_process::throw_reset( bool async )
{
    // IF THE PROCESS IS CURRENTLY UNWINDING OR IS ALREADY A ZOMBIE
    // IGNORE THE RESET:

    if ( m_unwinding )
    {
        SC_REPORT_WARNING( SC_ID_PROCESS_ALREADY_UNWINDING_, name() );
        return;
    }

    if ( m_state & ps_bit_zombie )
        return;

    // Set the throw status and if its an asynchronous reset throw an
    // exception:

    m_throw_status = async ? THROW_ASYNC_RESET : THROW_SYNC_RESET;
    if ( async )
    {
        remove_dynamic_events();
	if ( sc_get_current_process_b() == this )
	{
	    DEBUG_MSG(DEBUG_NAME,this,"throw_reset: throwing exception");
	    m_throw_status = THROW_ASYNC_RESET;
	    throw sc_unwind_exception( this, true );
	}
	else
	{
	    DEBUG_MSG(DEBUG_NAME,this,
	              "throw_reset: queueing this method for execution");
	    simcontext()->preempt_with(this);
	}
    }
}
----

大部分处理与<<api::sc_thread_process::throw_reset, thread的throw_reset>>一样，
除了method不需要ready to run位清零（因为method不使用ready to run状态)。所不同之初在于
异步reset的处理。

如果是异步reset，并且当前本method正在执行，则直接抛出一个 `sc_unwind_exception`
异常，并标识其为一个reset的异常。

不同于thread借助协程来一个一个运行，method都是调度其 `run_process` 来直接执行的

.src/sysc/kernel/sc_method_process.h
[source,cpp]
----
inline bool sc_method_process::run_process()
{
    // Execute this object instance's semantics and catch any exceptions that
    // are generated:

    bool restart = false;
    do {
        try {
            DEBUG_MSG(DEBUG_NAME,this,"executing method semantics");
            semantics();
            restart = false;
        }
        catch( sc_unwind_exception& ex ) {
            DEBUG_MSG(DEBUG_NAME,this,"caught unwind exception");
            ex.clear();
            restart = ex.is_reset();
        }
        catch( ... ) {
            sc_report* err_p = sc_handle_exception();
            simcontext()->set_error( err_p );
            return false;
        }
    } while( restart );

    return true;
}
----

throw_reset抛出来的异常会在这里被catch住，然后整个method会再一次执行一遍。

如果当前process不是被reset的method process，那么就调用
<<api::sc_simcontext::preempt_with::method, method重载形式的preempt_with>>，
来抢占执行method。

对于method而言，同步的reset似乎不需要特殊处理。因为对于method而言，每一次执行都是重新开始执行。

==== run_process
[[api::sc_method_process::run_process]]

method的 `run_process` 函数是method的入口函数，例如，在simc的
<<concept::crunch, crunch>>中，每一个method都是调用 run_process 来调度执行的:

.src/sysc/kernel/sc_method_process.h
[source,cpp]
----
// +----------------------------------------------------------------------------
// |"sc_method_process::run_process"
// | 
// | This method executes this object instance, including fielding exceptions.
// |
// | Result is false if an unfielded exception occurred, true if not.
// +----------------------------------------------------------------------------
inline bool sc_method_process::run_process()
{
    // Execute this object instance's semantics and catch any exceptions that
    // are generated:

    bool restart = false;
    do {
        try {
            DEBUG_MSG(DEBUG_NAME,this,"executing method semantics");
            semantics();
            restart = false;
        }
        catch( sc_unwind_exception& ex ) {
            DEBUG_MSG(DEBUG_NAME,this,"caught unwind exception");
            ex.clear();
            restart = ex.is_reset();
        }
        catch( ... ) {
            sc_report* err_p = sc_handle_exception();
            simcontext()->set_error( err_p );
            return false;
        }
    } while( restart );

    return true;
}
----

Method的调度执行相比于Thread比较简单，这是因为method的调度执行每一次都会执行完整的函数体，而没有
Thread挂起/恢复机制。

这里主要是处理调用method函数体(即semantics)过程中抛出的异常。除了reset会让函数体重新执行
以外，其他的异常都会中断执行，并根据情况返回状态位。

==== check_for_throws
[[api::sc_method_process::check_for_throws]]

method process的check_for_throws主要用在<<api::sc_simcontext::preempt_with, simc的preempt_with>>中。当一个Method正在运行时，如果被抢占执行，无论抢占执行的是另一个Method，还是
另一个Thread，都有可能在抢占执行的过程中改变被抢占的Method的对象，例如，调用被抢占method的
sc_process_handle的kill/reset等。所以抢占执行的method/thread执行完毕之后，method需要检查
自己的状态，看是否有需要抛出异常：

.src/sysc/kernel/sc_method_process.h
[source,cpp]
----
// +----------------------------------------------------------------------------
// |"sc_method_process::check_for_throws"
// |
// | This method checks to see if this method process should throw an exception
// | or not. It is called from sc_simcontext::preempt_with() to see if the
// | thread that was executed during the preemption did a kill or other
// | manipulation on this object instance that requires it to throw an
// | exception.
// +----------------------------------------------------------------------------
void sc_method_process::check_for_throws()
{
    if ( !m_unwinding )
    {
	switch( m_throw_status )
	{
	  case THROW_ASYNC_RESET:
	    simcontext()->preempt_with(this);
	    break;
          case THROW_KILL:
	    throw sc_unwind_exception( this, false );
	  default:
	    break;
	}
    }
}
----

目前看在被抢占执行的时候，method只会被改变为异步reset，或者kill。因此这里只处理这两种
情况。

check_for_throws的具体设计用途，以及为什么没有同步reset，目前还不是很清楚。从注释来看，似乎
的确是考虑到被抢占时，抢占的thread可能对被抢占的method做出kill/reset等动作而导致的。

== sc_cthread_process
[[data::sc_cthread_process]]

sc_cthread_process是一种特殊的thread_process。cthread中的c，意思是clock-drived。
sc_cthread_process直接继承自sc_thread_process。

sc_cthread_process概念的提出是在因为在SystemC早期版本中，sc_thread_process设计不完善的时候，为了补充
时钟驱动的能力，而设计的。目前sc_cthread_process的能力已经可以被sc_thread_process完全取代了。
相比于sc_thread_process，使用sc_cthread_process建模目前为数不多的优点只有：

* API上有约束，例如必须通过特定形式设置时钟上升沿/下降沿敏感
* 默认无需初始化，并且不能使用 dont_initialize来设置(会报出warning)

在目前最新的SystemC版本中，建议使用sc_thread_process代替sc_cthread_process。sc_cthread_process
概念只作为兼容性部分，保留在最新的SystemC代码中。

=== 成员变量

sc_cthread_process在基类 `sc_thread_process` 基础上，没有新增加其他的
成员变量。

=== 成员函数

sc_cthread_process并没有新增比较重要的成员函数。

== reset机制
[[concept::process::reset]]

(((sc_thread_process, reset)))
Process中有一套非常复杂的reset机制，来仿真模拟实际的RTL reset行为。

=== reset设置流程

[[api::sc_module::async_reset_signal_is]]
<<data::sc_module, sc_module>>提供了如下几组API，用来实现process的reset逻辑指定：

[[api::sc_module::reset_signal_is]]
.src/sysc/kernel/sc_module.h
[source,cpp]
----
    // set reset sensitivity for SC_xTHREADs
    void async_reset_signal_is( const sc_in<bool>& port, bool level );
    void async_reset_signal_is( const sc_inout<bool>& port, bool level );
    void async_reset_signal_is( const sc_out<bool>& port, bool level );
    void async_reset_signal_is( const sc_signal_in_if<bool>& iface, bool level);
    void reset_signal_is( const sc_in<bool>& port, bool level );
    void reset_signal_is( const sc_inout<bool>& port, bool level );
    void reset_signal_is( const sc_out<bool>& port, bool level );
    void reset_signal_is( const sc_signal_in_if<bool>& iface, bool level );
----

这些API实际调用的是 `sc_reset` 数据结构的 `reset_signal_is` 函数。例如：

.src/sysc/kernel/sc_module.cpp
[source,cpp]
----
void
sc_module::reset_signal_is( const sc_in<bool>& port, bool level )
{
	sc_reset::reset_signal_is(false, port, level);
}
----

`reset_signal_is` 是 `sc_reset` 的一组带重载的静态函数，所以这里无需一个sc_reset
的instance，就可以直接调用 `reset_signal_is` 。

[[api::sc_reset::reset_signal_is]]
`reset_signal_is` 具有多种重载形式，这里我们选择最终实现逻辑的一种重载形式来进行分析。
其他几种重载形式如果能拿到interface指针，都会直接调用这个，否则采取类似于
<<api::sc_event_finder, sc_event_finder>>的方式，
构造<<data::sc_reset_finder, sc_reset_finder>>延迟查找
这些interface。

以下是reset_signal_is的实现：

.src/sysc/kernel/sc_reset.cpp
[source,cpp]
----
void sc_reset::reset_signal_is(
    bool async, const sc_signal_in_if<bool>& iface, bool level )
{
    sc_process_b*   process_p;    // process adding reset for.
    sc_reset_target reset_target; // entry to build for the process.
    sc_reset*       reset_p;      // reset object.

    process_p = sc_process_b::last_created_process_base(); <1>
    sc_assert( process_p );
    process_p->m_has_reset_signal = true;
    switch ( process_p->proc_kind() )
    {
      case SC_METHOD_PROC_:
      case SC_CTHREAD_PROC_:
      case SC_THREAD_PROC_:
	reset_p = iface.is_reset(); <2>
	process_p->m_resets.push_back(reset_p);
        reset_target.m_async = async;
	reset_target.m_level = level;
	reset_target.m_process_p = process_p;
	reset_p->m_targets.push_back(reset_target);
	if ( iface.read() == level ) process_p->initially_in_reset( async );
        break;
      default:
        SC_REPORT_ERROR(SC_ID_UNKNOWN_PROCESS_TYPE_, process_p->name());
        break;
    }
}
----
<1> process handle是直接获取的，类似于sensitive中获取的最后一个创建的process handle的方式
<2> is_reset是sc_signal_in_if<T>的接口函数，默认返回一个空指针

process中的 `m_resets` 保存了设置reset的 `sc_reset` 对象指针，而这个reset对象指针里的
`m_targets` 则保存了reset需要的三个信息：

1. reset的同步/异步情况
2. reset的level（低电平reset还是高电平reset）
3. reset的process handle

如果发现当前信号值等于所设置的reset电平值，则调用process的initially_in_reset函数：
[[api::sc_process_b::initially_in_reset]]

.src/sysc/kernel/sc_process.h
[source,cpp]
----
inline void sc_process_b::initially_in_reset( bool async )
{
    if ( async )
        m_active_areset_n++;
    else
        m_active_reset_n++;
}
----

而这里只是简单将reset的counter计数器做自增而已，至于加在哪个上边，取决于是异步reset还是
同步reset。

至此，用作reset的sc_signal和设置这个sc_signal作为reset的process已经建立了关系：

* sc_signal内保存了所有的需要reset的process 的一组三元信息
* process内保存了所有用作reset的sc_reset指针footnote:[从SystemC代码中并没有看到这里保存的m_resets被使用的情况]

=== reset执行流程

在SystemC中，reset大致可以分为两种：

* 异步reset(asynchronous)，这种reset一般是与clock无关的reset信号，要求reset信号到达之后，相应的
process立马被reset
* 同步reset(synchronous)，这种reset一般由clock驱动的signal发出来，与时钟同步，reset动作需要等到
时钟沿才进行

[[api::sc_process_handle::sync_reset_on]]
对于一个sc_process_handle，提供了3个API，支持这两种reset机制：

* `sc_process_handle::reset` 成员函数可以异步reset process
* `sc_process_handle::sync_reset_off` 和 `sc_process_handle::sync_reset_on` 可以同步reset process

.src/sysc/kernel/sc_process_handle.h
[source,cpp]
----
inline void sc_process_handle::reset( sc_descendant_inclusion_info descendants )
{
    if ( m_target_p )
        m_target_p->reset_process( sc_process_b::reset_asynchronous,
	                           descendants );
    else
        SC_REPORT_WARNING( SC_ID_EMPTY_PROCESS_HANDLE_, "reset()");
}

inline void sc_process_handle::sync_reset_off(
    sc_descendant_inclusion_info descendants)
{
    if ( m_target_p )
        m_target_p->reset_process( sc_process_b::reset_synchronous_off,
	                           descendants);
    else
        SC_REPORT_WARNING( SC_ID_EMPTY_PROCESS_HANDLE_, "sync_reset_off()");
}

// turn sync_reset on for this object instance's target.

inline void sc_process_handle::sync_reset_on(
    sc_descendant_inclusion_info descendants)
{
    if ( m_target_p )
    {
        m_target_p->reset_process(sc_process_b::reset_synchronous_on,
            descendants);
    }
    else
    {
        SC_REPORT_WARNING( SC_ID_EMPTY_PROCESS_HANDLE_, "sync_reset_on()");
    }
}
----

所以reset/sync_reset_on/sync_reset_off实际调用的都是sc_process_b的reset_process。

[[api::sc_process_b::reset_process::impl]]
以下是sc_process_b的reset_process代码实现：

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_process_b::reset_process"
//
// This inline method changes the reset state of this object instance and
// conditionally its descendants.
//
// Notes:
//   (1) It is called for sync_reset_on() and sync_reset_off(). It is not used
//       for signal sensitive resets, though all reset flow ends up in
//       reset_changed().
//
// Arguments:
//     rt = source of the reset:
//            * reset_asynchronous     - sc_process_handle::reset()
//            * reset_synchronous_off  - sc_process_handle::sync_reset_off()
//            * reset_synchronous_on   - sc_process_handle::sync_reset_on()
//     descendants = indication of how to process descendants.
//------------------------------------------------------------------------------
void sc_process_b::reset_process( reset_type rt,
                                  sc_descendant_inclusion_info descendants )
{

    // PROCESS THIS OBJECT INSTANCE'S DESCENDANTS IF REQUESTED TO:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*> children = get_child_objects();
        int                           child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->reset_process(rt, descendants);
        }
    }

    // PROCESS THIS OBJECT INSTANCE:

    switch (rt)
    {
      // One-shot asynchronous reset: remove dynamic sensitivity and throw:
      //
      // If this is an sc_method only throw if it is active.

      case reset_asynchronous:
	if ( sc_get_status() != SC_RUNNING )
	{
	    report_error(SC_ID_RESET_PROCESS_WHILE_NOT_RUNNING_);
	}
	else
	{
	    remove_dynamic_events();
	    throw_reset(true);
	}
        break;

      // Turn on sticky synchronous reset: use standard reset mechanism.

      case reset_synchronous_on:
	if ( m_sticky_reset == false )
	{
	    m_sticky_reset = true;
	    reset_changed( false, true );
	}
        break;

      // Turn off sticky synchronous reset: use standard reset mechanism.

      default:
	if ( m_sticky_reset == true )
	{
	    m_sticky_reset = false;
	    reset_changed( false, false );
	}
        break;
    }
}
----

最开始的代码用以处理子对象的reset请求。如前所述，reset来源分为异步reset，同步的reset开
和同步的reset关，反映在 `reset_process` 的第一个参数 `rt`, 即reset type上。

如果是异步的reset，首先移除所有动态事件，因为reset一个process需要从头开始执行，所以
这些阻塞的动态事件就没必要了，接下来调度 throw_reset(true)。这里代码会检查异步
reset的时机，保证异步reset发生在simulation运行过程中。

如果是同步的reset，这里使用了变量 `m_sticky_reset` 来辅助做同步reset。m_stick_reset
默认为false，其含义是是否处于同步reset周期内。如果请求打开同步reset，且未处于reset
周期内（m_sticky_reset为false），调用 `reset_changed(false, true)`，并设置 
m_sticky_reset为true，否则无动作。同样，如果请求关闭同步reset，且处于reset
周期内（m_sticky_reset为true），调用 `reset_changed(false, false)`，并设置
m_sticky_reset为false，否则无动作。m_sticky_reset的引入，保证了无论
同步reset持续多长的时钟周期，表现都如同一个reset一样。

[[api::sc_process_b::reset_changed]]
这里的 `reset_changed` 实现如下：

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_process_b::reset_changed"
//
// This method is called when there is a change in the value of the
// signal that was specified via reset_signal_is, or the value of the
// m_sticky_reset field. We get called any time m_sticky_reset changes
// or a signal value changes since, since we may need to throw an exception
// or clear one. Note that this method may be called when there is no
// active process, but rather the main simulator is executing so we must
// check for that case.
//
// Arguments:
//     async    = true if this is an asynchronous reset.
//     asserted = true if reset being asserted, false if being deasserted.
//------------------------------------------------------------------------------
void sc_process_b::reset_changed( bool async, bool asserted )
{

    // Error out on the corner case:

    if ( !sc_allow_process_control_corners && !async &&
         (m_state & ps_bit_suspended) )
    {
	report_error( SC_ID_PROCESS_CONTROL_CORNER_CASE_,
	              "synchronous reset changed on a suspended process" );
    }

    // IF THIS OBJECT IS PUSHING UP DAISIES WE ARE DONE:

    if ( m_state & ps_bit_zombie ) return;

    // Reset is being asserted:

    if ( asserted )
    {
        // if ( m_reset_event_p ) m_reset_event_p->notify();
        if ( async )
	{
	    m_active_areset_n++;
	    if ( sc_is_running() ) throw_reset(true);
	}
	else
	{
	    m_active_reset_n++;
	    if ( sc_is_running() ) throw_reset(false);
	}
    }

    // Reset is being deasserted:

    else
    {
        if ( async )
	{
	    m_active_areset_n--;
	}
	else
	{
	    m_active_reset_n--;
	}
    }

    // Clear the throw type if there are no active resets.

    if ( (m_throw_status == THROW_SYNC_RESET ||
          m_throw_status == THROW_ASYNC_RESET) &&
         m_active_areset_n == 0 && m_active_reset_n == 0 && !m_sticky_reset )
    {
        m_throw_status = THROW_NONE;
    }
}
----

这里最开始是处理一个corner case，即同步reset一个suspended的case。

异步和同步reset，主要是在相关的计数器加减上。另外，如果reset时simulation已经开始，这里
同样会调用 throw_reset()函数。

reset_changed这个函数除了在sc_process_b的reset_process中使用以外，还在sc_reset
的notify_processes中使用：
[[api::sc_reset::notify_processes]]

.src/sysc/kernel/sc_reset.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_reset::notify_processes"
//
// Notify processes that there is a change in the reset signal value.
//------------------------------------------------------------------------------
void sc_reset::notify_processes()
{
    bool                                    active;       // true if reset is active.
    sc_reset_target*                        entry_p;      // reset entry processing.
    std::vector<sc_reset_target>::size_type process_i;    // index of process resetting.
    std::vector<sc_reset_target>::size_type process_n;    // # of processes to reset.
    bool                                    value;        // value of our signal.

    value = m_iface_p->read();
    process_n = m_targets.size();
    for ( process_i = 0; process_i < process_n; process_i++ )
    {
        entry_p = &m_targets[process_i];
	active = ( entry_p->m_level == value );
	entry_p->m_process_p->reset_changed( entry_p->m_async, active );
    }
}
----

这相当于从一个sc_reset中触发所有依赖这个sc_reset的process的reset_changed函数了。

reset流程走到最后，着落点在于 `throw_reset` 这个函数。这是sc_process_b的接口函数，
<<api::sc_thread_process::throw_reset, thread>>和
<<api::sc_method_process::throw_reset, method>>都实现了自己的throw_reset逻辑。

异步的reset请求，每请求一次，就调用一次 `throw_reset(true)`。同步的reset请求，每一对
sync_reset_on和sync_reset_off，在sync_reset_on的时候，调用一次 `throw_reset(false)`。
实际从thread和method的throw_reset逻辑来看，同步的reset请求，throw_reset只是：

* 将 `m_throw_status` 设置为 `THROW_SYNC_RESET`
* 对于thread，清除 `m_wait_cycle_n` 为0

而没有其他的逻辑，这是因为对于同步reset，只需要标记 `m_throw_status` 为 `THROW_SYNC_RESET`
就足够了。

对于Method线程而言，将 `m_throw_status` 置为 `THROW_SYNC_RESET`，意味着在Method下次启动执行
的时候，<<api::sc_process_b::semantics, sc_process_b的semantics>>中会trigger可能的
reset event。但这种trigger reset event的事情，会在同步reset期间，每一次调度的时候都执行
一遍，直到同步reset结束为止。


=== 能够用作reset的类型

默认情况下， `sc_signal_in_if<T>` 的 is_reset 会返回一个空指针，这意味着普通的sc_signal
是无法作为reset的。从逻辑角度考虑这也是符合事实的，只有一根信号的sc_signal才能够作为
reset信号。

在SystemC中，只有 sc_signal<bool> footnote:[这意味着只有sc_signal<bool>才能作为reset信号]才实现了is_reset API返回一个sc_reset对象指针的功能：

.src/sysc/communication/sc_signal.cpp
[source,cpp]
----
template< sc_writer_policy POL >
sc_reset*
sc_signal<bool,POL>::is_reset() const
{
    sc_reset* result_p;
    if ( !m_reset_p ) m_reset_p = new sc_reset( this );
    result_p = m_reset_p;
    return result_p;
}
----

`sc_signal<sc_dt::sc_logic>` 不能作为reset信号，猜测是因为 `sc_logic` 是一个四值逻辑，不符合
作为reset信号的二值逻辑要求。

=== sc_reset_finder
[[data::sc_reset_finder]]

sc_reset_finder的设计思想和设计目的与sc_event_finder一致，都是在module中，sc_port/sc_export
还没有绑定具体的sc_signal的时候，如何作为reset信号设置下来。

如同sc_event_finder一样，sc_reset_finder是在sc_reset的静态成员函数reconcile_resets中
完成决议，将具体的interace从sc_reset_finder中查找出来的。
reconcile_resets则在simc的elabroate函数中被调用，这就保证了仿真开始之前，reset信号被真正
设置了下去.

以下是reconcile_resets的实现：
[[api::sc_reset::reconcile_resets]]

.src/sysc/kernel/sc_reset.cpp
[source,cpp]
----
void sc_reset::reconcile_resets(sc_reset_finder* reset_finder_q)
{
    const sc_signal_in_if<bool>*  iface_p;      // Interface to reset signal.
    sc_reset_finder*              next_p;       // Next finder to process.
    sc_reset_finder*              now_p;        // Finder currently processing.
    sc_reset_target               reset_target; // Target's reset entry.
    sc_reset*                     reset_p;      // Reset object to use.

    for ( now_p = reset_finder_q; now_p; now_p = next_p )
    {
        next_p = now_p->m_next_p;
        if ( now_p->m_in_p )
        {
            iface_p = dynamic_cast<const sc_signal_in_if<bool>*>(
                now_p->m_in_p->get_interface());
        }
        else if ( now_p->m_inout_p )
        {
            iface_p = dynamic_cast<const sc_signal_in_if<bool>*>(
                now_p->m_inout_p->get_interface());
        }
        else
        {
            iface_p = dynamic_cast<const sc_signal_in_if<bool>*>(
                now_p->m_out_p->get_interface());
        }
        sc_assert( iface_p != 0 );
        reset_p = iface_p->is_reset();
	now_p->m_target_p->m_resets.push_back(reset_p);
	reset_target.m_async = now_p->m_async;
	reset_target.m_level = now_p->m_level;
	reset_target.m_process_p = now_p->m_target_p;
	reset_p->m_targets.push_back(reset_target);
	if ( iface_p->read() == now_p->m_level ) // see note 1 above
	    now_p->m_target_p->initially_in_reset( now_p->m_async ); <1>
        delete now_p;
    }
}
----
<1> 如果elaboration的时候，reset信号的值等于设定的reset值，这意味着仿真一开始process就处于
reset状态了

对于sc_in<bool>，sc_inout<bool>，可以在没有被绑定sc_signal<bool>的情况下，
就可以使用<<api::sc_module::reset_signal_is, sc_module的reset_signal_is>>，
设置其为process的reset信号。如果需要设置异步reset，可以使用
<<api::sc_module::async_reset_signal_is, sc_module的async_reset_signal_is>>。

== process状态的迁移变化

在sc_process_b中，有一个记录当前线程状态的位掩码 <<data::sc_process_b::m_state, `m_state`>> 。
sc_process_b可能有如下几种状态：

* disable
* ready to run
* suspend
* zombie
* normal

前四种分别为位的掩码，意味着process可以同时处于前四种状态中的多种。

在使用过程中，应当调用自由函数 `sc_get_current_process_handle` ，获取一个
<<data::sc_process_handle, sc_process_handle>>的对象，然后通过这个对象的
如下成员函数，调度这些管理process状态的部分：

* suspend，调用所保管的process handle的 `suspend_process` 成员函数
* resume，调用所保管的process handle的 `resume_process` 成员函数
* enable，调用所保管的process handle的 `enable_process` 成员函数
* disable，调用所保管的process handle的 `disable_process` 成员函数
* kill，调用所保管的process handle的 `kill_process` 成员函数
* reset，调用所保管的process handle的 `reset_process` 成员函数

IEEE 1666对于SystemC在如下几种process状态切换时的行为，交给实现自行定义：

* 当一个disabled, suspended的process上调用resume()时的行为
* 当一个suspended的process上调用sync_reset_on()和sync_reset_off()时的行为
* 当一个suspended的process上的由reset_signal_is()所指定的signal值发生变化时的行为

Proof of Concept实现在默认情况下，对这三种情况都当做错误处理。此外，在设置
一个变量 `sc_allow_process_control_corners` 为true的时候，实现可以转而采用
一种不报错的方式：

* 如果一个disabled, suspended的process上调用了resume()，则这个process被标记为
不再suspend。如果这么处理后的process是可以调度执行的（没有阻塞在任何事件上），那么这个
process将会被放入runnable列表中
* sync_reset_on()和sync_reset_off()只会将相关的标志位置位或者复位。process是否处于
reset状态，取决于当process得到执行时候，相关标志位的状态。
* 如果一个suspended的process有由reset_signal_is()所制定的reset signal，则这个reset
signal的值只有在这个process下次执行的时候，才会被采样，采样的结果决定process是否reset

[[data::sc_allow_process_control_corners]]
`sc_allow_process_control_corners` 在SystemC中默认值是false:

.src/sysc/kernel/sc_simcontext.h
[source,cpp]
----
bool sc_allow_process_control_corners = false;

// The state transition diagram for the interaction of disable and suspend
// when sc_allow_process_control_corners is true is shown below:
//
// ......................................................................
// .         ENABLED                    .           DISABLED            .
// .                                    .                               .
// .                 +----------+    disable      +----------+          .
// .   +------------>|          |-------.-------->|          |          .
// .   |             | runnable |       .         | runnable |          .
// .   |     +-------|          |<------.---------|          |------+   .
// .   |     |       +----------+     enable      +----------+      |   .
// .   |     |          |    ^          .            |    ^         |   .
// .   |     |  suspend |    | resume   .    suspend |    | resume  |   .
// .   |     |          V    |          .            V    |         |   .
// .   |     |       +----------+    disable      +----------+      |   .
// .   |     |       | suspend  |-------.-------->| suspend  |      |   .
// . t |   r |       |          |       .         |          |      | r .
// . r |   u |       |  ready   |<------.---------|  ready   |      | u .
// . i |   n |       +----------+     enable      +----------+      | n .
// . g |   / |         ^                .                           | / .
// . g |   w |  trigger|                .                           | w .
// . e |   a |         |                .                           | a .
// . r |   i |       +----------+    disable      +----------+      | i .
// .   |   t |       | suspend  |-------.-------->| suspend  |      | t .
// .   |     |       |          |       .         |          |      |   .
// .   |     |       | waiting  |<------.---------| waiting  |      |   .
// .   |     |       +----------+     enable      +----------+      |   .
// .   |     |          |    ^          .            |    ^         |   .
// .   |     |  suspend |    | resume   .    suspend |    | resume  |   .
// .   |     |          V    |          .            V    |         |   .
// .   |     |       +----------+    disable      +----------+      |   .
// .   |     +------>|          |-------.-------->|          |      |   .
// .   |             | waiting  |       .         | waiting  |      |   .
// .   +-------------|          |<------.---------|          |<-----+   .
// .                 +----------+     enable      +----------+          .
// .                                    .                               .
// ......................................................................

----

如果需要支持不出错的处理，可以编译代码的时候将这个更改为true，或者在sc_main()中，第一行
加入：

[source,cpp]
----
sc_core::sc_allow_process_control_corners = true;
----

=== disable and enable
[[concept::process::control::disable_enable]]

sc_process_handle的enable/disable调用，如前所述，调用的其实是内部sc_process_b
的enable_process/disable_process接口函数：

.src/sysc/kernel/sc_process_handle.h
[source,cpp]
----
// enable this object instance's target.

inline void sc_process_handle::enable(sc_descendant_inclusion_info descendants)
{
    if ( m_target_p )
        m_target_p->enable_process(descendants);
    else
        SC_REPORT_WARNING( SC_ID_EMPTY_PROCESS_HANDLE_, "enable()");
}

// disable this object instance's target.

inline void sc_process_handle::disable(sc_descendant_inclusion_info descendants)
{
    if ( m_target_p )
        m_target_p->disable_process(descendants);
    else
        SC_REPORT_WARNING( SC_ID_EMPTY_PROCESS_HANDLE_, "disable()");
}
----

enable_process/disable_process是sc_process_b的接口函数，是纯虚函数。对于Thread和Method
有着不同的实现。

==== Thread/CThread

[[concept::process::control::disable::thread]]
首先我们来看Thread/CThread是如何实现disable的：

.src/sysc/kernel/sc_thread_process.cpp
[source,cpp]
----
void sc_thread_process::disable_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE DISABLE REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->disable_process(descendants);
        }
    }

    // DON'T ALLOW CORNER CASE BY DEFAULT:

    if ( !sc_allow_process_control_corners )
    {
        switch( m_trigger_type )
        {
          case AND_LIST_TIMEOUT:
          case EVENT_TIMEOUT:
          case OR_LIST_TIMEOUT:
          case TIMEOUT:
            report_error(SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                   "attempt to disable a thread with timeout wait");
            // may continue, if suppressed
            break;
          default:
            break;
        }
    }

    // DISABLE OUR OBJECT INSTANCE:

    m_state = m_state | ps_bit_disabled;

    // IF THIS CALL IS BEFORE THE SIMULATION DON'T RUN THE THREAD:

    if ( !sc_is_running() )
    {
	m_state = m_state | ps_bit_ready_to_run;
        simcontext()->remove_runnable_thread(this);
    }
}
----

所有的这些状态转移函数，都会带一个 `descendants` 参数，表示是否需要将动作
传播给子对象。这部分的内容基本就是检索所有的子对象，并使用dynamic_cast来
检查这鞋子对象是否是process对象，如果是，就将请求转发过去。后续类似这部分的内容
我们就不再多解析了。

默认情况下，disable一个process的时候回检查process的状态。如果process设置了
超时状态（延时执行），那么就报错。如果我们将 `sc_allow_process_control_corners`
置为true，就会跳过这一步的检查，允许在设置有超时（延时）状态的process上执行disable动作。

接下来，
<<data::sc_process_b::m_state, m_state>>的ps_bit_disabled位被置位。如果disable process
发生在仿真开始之前，同时会把m_state的ps_bit_ready_to_run置位，从simc中准备runnable
的列表中移除这个process。如果disable process发生在仿真过程中，就无需其他动作，只需要继续执行下去。
如果disable_process的请求来自线程本身，disable_process并不会立即生效，而是会继续执行，直到
此线程被阻塞住，然后让渡出CPU执行权为止。

这么设计的原因还暂时不清楚。

[[concept::process::control::enable::thread]]
Thread/CThrad的enable_process实现则是：

.src/sysc/kernel/sc_thread_process.cpp
[source,cpp]
----
void sc_thread_process::enable_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE ENABLE REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->enable_process(descendants);
        }
    }

    // ENABLE THIS OBJECT INSTANCE:
    //
    // If it was disabled and ready to run then put it on the run queue.

    m_state = m_state & ~ps_bit_disabled;
    if ( m_state == ps_bit_ready_to_run && sc_allow_process_control_corners )
    {
        m_state = ps_normal;
	if ( next_runnable() == 0 )
	    simcontext()->push_runnable_thread(this);
    }
}
----

首先是将m_state的ps_bit_disabled位复位。接下来如果状态是ps_bit_ready_to_run，并且
设置了 sc_allow_process_control_corners为true的话，将m_state置为ps_normal。如果
next_runnable()为空，即这个process不在runnable列表中，就将这个thread加入到runnable
列表中去。

由此可见：

* 如果仿真前disable process，在仿真过程中enable process，process会被放入runnable列表中执行，在下一个delta cycle立马开始执行。如果不这样做，这个process只能等到与之关联的静态敏感事件发生才会被
放入调度列表中得到执行了，因为process disable发生在仿真之前，process根本没得到执行，无法动态
等待事件。
* 如果仿真中disable process，之后再enable process，除非之前process已经执行且处于ready to run状态，否则enable_process不会将这个process放入列表中执行。仿真已经开始，说明这个process handle要么可能被静态敏感事件注册为关联线程，要么动态等待在一个事件上，都会有机会被调度重新放入可执行列表的

==== Method

[[concept::process::control::disable::method]]
Method的disable_process实现如下：

.src/sysc/kernel/sc_method_process.cpp
[source,cpp]
----
void sc_method_process::disable_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE SUSPEND REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->disable_process(descendants);
        }
    }

    // DON'T ALLOW CORNER CASE BY DEFAULT:

    if ( !sc_allow_process_control_corners )
    {
        switch( m_trigger_type )
        {
          case AND_LIST_TIMEOUT:
          case EVENT_TIMEOUT:
          case OR_LIST_TIMEOUT:
          case TIMEOUT:
            report_error( SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                          "attempt to disable a method with timeout wait" );
            // may continue, if suppressed
            break;
          default:
            break;
        }
    }

    // DISABLE OUR OBJECT INSTANCE:

    m_state = m_state | ps_bit_disabled;

    // IF THIS CALL IS BEFORE THE SIMULATION DON'T RUN THE METHOD:

    if ( !sc_is_running() )
    {
        sc_get_curr_simcontext()->remove_runnable_method(this);
    }
}
----

Method的disable process处理基本和Thread的差不多，最大的区别在于，如果disable
发生在仿真开始之前，没有将状态位ready_to_run置位的。
这么做的原因还不是很清楚。

[[concept::process::control::enable::method]]
Method的enable_process实现则是：

.src/sysc/kernel/sc_method_process.cpp
[source,cpp]
----
void sc_method_process::enable_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE RESUME REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->enable_process(descendants);
        }
    }

    // ENABLE THIS OBJECT INSTANCE:
    //
    // If it was disabled and ready to run then put it on the run queue.

    m_state = m_state & ~ps_bit_disabled;
    if ( m_state == ps_bit_ready_to_run )
    {
        m_state = ps_normal;
	if ( next_runnable() == 0 )
	    simcontext()->push_runnable_method(this);
    }
}
----

这里的处理基本和Thread一致，除了检查状态时候，无须sc_allow_process_control_corners
为true。我个人猜测，这应该是因为Method每次都会完整执行一遍，不像Thread那样存在死循环，所以
disable之后，再enable，调度执行即可，不会是一个corner case.

=== disable-enable例子分析

现在我们有一个clock period为100ns的sc_clock clock，并且有如下代码：

[source,cpp]
----
void calling()
{
  wait(20, SC_NS);
  t.disable(); // @20 ns
  wait(30, SC_NS);
  t.enable() // @50 ns

  wait(110, SC_NS);
  t.disable(); // @160 ns

  wait(200, SC_NS);
  t.endable(); // @360 ns
}

void target()
{
  while(1)
  {
      wait();
      cout << sc_time_stamp(); // 100 400 500
  }
}
----

target线程设置静态敏感事件为 `sensitive << clock.pos();`。 t是target线程的
sc_process_handle。

在第一个时钟上升沿，也就是100ns时，target处于enable状态，因此会正确输出100。接下来200ns
和300ns的时钟上升沿，target都处于disable状态。clock的posedge事件调用target的
<<api::sc_thread_process::trigger_static, trigger_static>>
成员函数，在这个函数里，有何如下代码(以thread的trigger_static为例，method中
有一样的处理代码)：

[source,cpp]
----
    // No need to try queueing this thread if one of the following is true:
    //    (a) it is disabled
    //    (b) it is already queued for execution
    //    (c) it is waiting on a dynamic event
    //    (d) its wait count is not satisfied and it is not currently in reset

    if ( (m_state & ps_bit_disabled) || is_runnable() ||
          m_trigger_type != STATIC )
        return;
----

可以看到如果状态中有disable状态，那么trigger_static是不生效的，这里会直接返回。

直到400ns的上升沿事件发生，target才处于enable状态，target才会调度执行，从上次
执行时被阻塞的地方恢复执行。

如果动态阻塞在一个事件，这个事件在process disable状态发生的话，调用的是process
的
<<sc_process_b::trigger_dynamic, trigger_dynamic>>，这里有如下代码(以thread
为例，method中有一样的处理代码）：

[source,cpp]
----
    // If a process is disabled then we ignore any events, leaving them enabled:
    //
    // But if this is a time out event we need to remove both it and the
    // event that was being waited for.

    if ( m_state & ps_bit_disabled )
    {
        if ( e == m_timeout_event_p )
	{
	    remove_dynamic_events( true ); <1>
	    return true;
	}
	else
	{
	    return false;
	}
    }
----
<1> 保留timed event对象，参见<<api::sc_process_b::remove_dynamic_events, remove_dynamic_events>>部分

如果动态trigger这个disabled process的事件是个timed事件，那么disabled状态的
线程认为这个事件已经被accpet，需要清除掉这个事件，同时返回true。这个返回值用以
向事件表明是否线程被成功调度。这里可以看到，disabled process向外界报告自己被
重新调度，然而却没有放入runnable列表。

回到最初的那个例子，如果那个例子中target没有设置静态敏感事件，而是依赖动态敏感
事件的话：

[source,cpp]
----
void target()
{
  while(1)
  {
      wait(100, SC_NS);
      cout << sc_time_stamp(); // 100 360, 460
  }
}
----

那么在100ns时候输出100后，200ns 时候timed event发生，这里不会恢复执行，只会将200ns
的timed event移除。这样带来的后果是，target线程在之后永远不会被调度执行！因为200ns
的timed event被移除，但target没有恢复执行以创建下一个300ns的timed event，这个
target奖没有任何event能够唤醒，哪怕之后被enable了同样如此。这是使用disable-enable
时候应当注意的一点：一个使用disable-enable控制的线程，应当有静态敏感事件，以协助在enable
线程之后，线程可以继续调度执行。
在<<use::process::control::prepare_to_simulate, prepare_to_simulate中的状态判断>>
部分，我们也可能看到simc在初始的时候，是不允许disable状态的线程没有静态敏感事件的。


线程在disable状态，无法响应任何发生的事件。这种特性可以用来模拟clock-gating行为。disable-enable
机制一般适用于clock驱动的process，这些process天然带有clock的敏感沿作为静态事件。


=== suspend and resume
[[concept::process::control::suspend_resume]]

suspend操作会挂起一个线程，而resume操作则会继续此线程的执行。这里的suspend/resume
指的是从用户方显式地要求挂起和唤醒线程，而不是SystemC内部在线程切换的时候的线程挂起
和唤醒动作。

[[api::sc_process_b::suspend_process]]
sc_process_handle的suspend和resume都转发给了下层的process的suspend_process()
和resume_process():
[[api::sc_process_b::resume_process]]

.src/sysc/kernel/sc_process_handle.h
[source,cpp]
----
// resume this object instance's target.

inline void sc_process_handle::resume(sc_descendant_inclusion_info descendants)
{
    if ( m_target_p )
        m_target_p->resume_process(descendants);
    else
        SC_REPORT_WARNING( SC_ID_EMPTY_PROCESS_HANDLE_, "resume()");
}

// suspend this object instance's target.

inline void sc_process_handle::suspend(sc_descendant_inclusion_info descendants)
{
    if ( m_target_p )
        m_target_p->suspend_process(descendants);
    else
        SC_REPORT_WARNING( SC_ID_EMPTY_PROCESS_HANDLE_, "suspend()");
}
----

Method和Thread/CThread有着不同的suspend/resume动作。

==== Thread/CThread

以下是Thread/CThread的suspend_process的代码：
[[concept::process::control::suspend::thread]]

.src/sysc/kernel/sc_thread_process.cpp
[source,cpp]
----
void sc_thread_process::suspend_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE SUSPEND REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->suspend_process(descendants);
        }
    }

    // CORNER CASE CHECKS, THE FOLLOWING ARE ERRORS:
    //   (a) if this thread has a reset_signal_is specification
    //   (b) if this thread is in synchronous reset

    if ( !sc_allow_process_control_corners && m_has_reset_signal )
    {
        report_error(SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                     "attempt to suspend a thread that has a reset signal");
        // may continue, if suppressed
    }
    else if ( !sc_allow_process_control_corners && m_sticky_reset )
    {
        report_error(SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                     "attempt to suspend a thread in synchronous reset");
        // may continue, if suppressed
    }

    // SUSPEND OUR OBJECT INSTANCE:
    //
    // (1) If we are on the runnable queue then set suspended and ready_to_run,
    //     and remove ourselves from the run queue.
    // (2) If this is a self-suspension then a resume should cause immediate
    //     scheduling of the process, and we need to call suspend_me() here.

    m_state = m_state | ps_bit_suspended;
    if ( next_runnable() != 0 )
    {
	m_state = m_state | ps_bit_ready_to_run;
	simcontext()->remove_runnable_thread( this );
    }
    if ( sc_get_current_process_b() == dynamic_cast<sc_process_b*>(this)  )
    {
	m_state = m_state | ps_bit_ready_to_run;
	suspend_me();
    }
}
----

中间检查了suspend的时候，是否有reset信号。如果有，并且sc_allow_process_control_corners
是false，就报错，否则就跳过检查。

主要的动作是把m_state的ps_bit_suspended置位。如果 `next_runnable()` 非空，说明当前
的process在runnable列表中，这种情况下需要将其标记为ready to run(因为已经要准备run了)
并且从simc的runnable列表中移除此线程。

如果是suspend请求是来自线程自身，即当suspend_process
调用的时候当前线程正在执行， 同样标记ready to run，并且调用suspend_me让渡出执行权。
这样的suspend表现的类似于一个wait()，调用后从不返回，直到线程被外部唤醒的时候才返回。

[[concept::process::control::resume::thread]]
resume_process的操作如下：

.src/sysc/kernel/sc_thread_process.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_thread_process::resume_process"
//
// This method resumes the execution of this process, and if requested, its
// descendants. If the process was suspended and has a resumption pending it
// will be dispatched in the next delta cycle. Otherwise the state will be
// adjusted to indicate it is no longer suspended, but no immediate execution
// will occur.
//------------------------------------------------------------------------------
void sc_thread_process::resume_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE RESUME REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->resume_process(descendants);
        }
    }

    // BY DEFAULT THE CORNER CASE IS AN ERROR:

    if ( !sc_allow_process_control_corners && (m_state & ps_bit_disabled) &&
         (m_state & ps_bit_suspended) )
    {
        m_state = m_state & ~ps_bit_suspended;
        report_error(SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                     "call to resume() on a disabled suspended thread");
        // may continue, if suppressed
    }

    // CLEAR THE SUSPENDED BIT:

    m_state = m_state & ~ps_bit_suspended;

    // RESUME OBJECT INSTANCE IF IT IS READY TO RUN:

    if ( m_state & ps_bit_ready_to_run )
    {
	m_state = m_state & ~ps_bit_ready_to_run;
	if ( next_runnable() == 0 )
	    simcontext()->push_runnable_thread(this);
	remove_dynamic_events();  // order important.
    }
}
----

如前所述，resume一个suspended，但是disabled的process是implementation defined行为，这里
用sc_allow_process_control_corners变量控制行为：如果这个变量为true，跳过检查，否则报错。

主要工作是清除ps_bit_suspended位。如果清除之后，m_state显示ready to run，说明线程在被挂起
的时候处于可运行状态（要么是在runnable列表中，要么就是正在运行）。此时清除掉ready to run
标志，同时向本线程放入runnable列表中，这样在下一个delta cycle本线程就会调度执行。线程
可以被执行，说明已经满足调度条件，所以这里可以移除所有动态的events。

所以一个自我suspended的thread，在resume的时候，会立即开始执行（实际上是从下一个delta cycle
开始执行），而不会等待阻塞事件发生（因为实际上并没有被事件阻塞）。一个满足调度条件的thread，再被
suspended之后不会执行，直到resume的时候才会被放入调度队列，重新开始执行。

对于Thread线程而言，suspend的地方可以是上次被调度出去的地方（某个wait），也可以是
自我suspend时候的 `suspend_me` 地方。当resume这个线程的时候，在下一个delta cycle，
线程会从上次被打断的地方恢复执行。对于自我suspend的情况，这相当于 suspend_process函数
中的suspend_me返回了。

==== Method

Method的suspend_process实现如下：
[[concept::process::control::suspend::method]]

.src/sysc/kernel/sc_method_process.cpp
[source,cpp]
----
void sc_method_process::suspend_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE SUSPEND REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->suspend_process(descendants);
        }
    }

    // CORNER CASE CHECKS, THE FOLLOWING ARE ERRORS:
    //   (a) if this method has a reset_signal_is specification
    //   (b) if this method is in synchronous reset

    if ( !sc_allow_process_control_corners && m_has_reset_signal )
    {
        report_error(SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                     "attempt to suspend a method that has a reset signal");
        // may continue, if suppressed
    }
    else if ( !sc_allow_process_control_corners && m_sticky_reset )
    {
        report_error(SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                     "attempt to suspend a method in synchronous reset");
        // may continue, if suppressed
    }

    // SUSPEND OUR OBJECT INSTANCE:
    //
    // (1) If we are on the runnable queue then set suspended and ready_to_run,
    //     and remove ourselves from the run queue.
    // (2) If this is a self-suspension then a resume should cause immediate
    //     scheduling of the process.

    m_state = m_state | ps_bit_suspended;
    if ( next_runnable() != 0 )
    {
	m_state = m_state | ps_bit_ready_to_run;
	simcontext()->remove_runnable_method( this );
    }
    if ( sc_get_current_process_b() == dynamic_cast<sc_process_b*>(this)  )
    {
	m_state = m_state | ps_bit_ready_to_run;
    }
}
----

可以看出，Method的suspend_process处理过程和tHREAD基本是一模一样的。
不同之处在于，Method没有suspend_me的概念，所以如果自我suspend的case, suspend_process
并不会立即阻塞此线程，而是标记为ready_to_run之后，立即返回。这意味着，如果在一个method
process中，我们调用了这个线程的suspend_process，线程不会阻塞，还是会继续执行下去。

[[concept::process::control::resume::method]]
Method的resume_process执行如下：

.src/sysc/kernel/sc_method_process.cpp
[source,cpp]
----

//------------------------------------------------------------------------------
//"sc_method_process::resume_process"
//
// This method resumes the execution of this process, and if requested, its
// descendants. If the process was suspended and has a resumption pending it
// will be dispatched in the next delta cycle. Otherwise the state will be
// adjusted to indicate it is no longer suspended, but no immediate execution
// will occur.
//------------------------------------------------------------------------------
void sc_method_process::resume_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE RESUME REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->resume_process(descendants);
        }
    }


    // BY DEFAULT THE CORNER CASE IS AN ERROR:

    if ( !sc_allow_process_control_corners && (m_state & ps_bit_disabled) &&
         (m_state & ps_bit_suspended) )
    {
        m_state = m_state & ~ps_bit_suspended;
        report_error( SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                      "call to resume() on a disabled suspended method" );
        // may continue, if suppressed
    }

    // CLEAR THE SUSPENDED BIT:

    m_state = m_state & ~ps_bit_suspended;

    // RESUME OBJECT INSTANCE:
    //
    // If this is not a self-resume and the method is ready to run then
    // put it on the runnable queue.

    if ( m_state & ps_bit_ready_to_run )
    {
	m_state = m_state & ~ps_bit_ready_to_run;
	if ( next_runnable() == 0 &&
	   ( sc_get_current_process_b() != dynamic_cast<sc_process_b*>(this) ) )
        {
	    simcontext()->push_runnable_method(this);
	    remove_dynamic_events();
	}
    }
}
----

resume一个Method线程的动作和resume一个Thread线程的动作是一模一样的。概念上的区别在于，resume
一个Method线程，这个线程会从头开始执行，而不像Thread线程那样，从上次suspend的地方开始执行。

=== suspend-resume例子分析

例如，我们有calling和target两个Thread，其中 `t` 是target的sc_process_handle:

[source,cpp]
----
void calling()
{
  wait(20, SC_NS);
  t.suspend(); // @20 ns
  wait(30, SC_NS);
  t.resume() // @50 ns

  wait(110, SC_NS);
  t.suspend(); // @160 ns

  wait(200, SC_NS);
  t.resume(); // @360 ns
}

void target()
{
  while(1)
  {
      wait(100, SC_NS);
      cout << sc_time_stamp(); // 100 360, 460
  }
}
----

这个例子中，target process的suspend和resume都是从另外一个线程calling发出的。
target线程每次都创建一个100ns延时的timed event，并等待此event的发生。

target中，第一个100ns的时候，target处于正常状态（20ns的suspend又在50ns的时候resume了），
所以target被正常调度执行，打印100，接下来又创建一个100ns的delay，准备在200ns的时候
唤醒此线程。然而，200ns的时候，设定的延时时间到达，事件发生，事件调用trigger_dynamic，将
动态阻塞在这个事件上的线程trigger起来的时候，线程处于suspended状态（160ns开始被suspend）。
在 <<sc_process_b::trigger_dynamic, trigger_dynamic>>的实现中，我们可以看到
如下部分代码(在method/thread的trigger_static中也是这套逻辑)：

[source,cpp]
----
    if ( (m_state & ps_bit_suspended) )
    {
	m_state = m_state | ps_bit_ready_to_run;
    }
    else
    {
        simcontext()->push_runnable_method(this);
    }
----

如果线程状态m_state的suspended位被置位，那么如果线程满足调度条件，这里也只是将其标记为
ready to run，而不会真正放入runnable列表。

因此，在这个例子中，200ns时候的timed event只会将线程target标记为ready to run，然后返回。
在360ns的时候，target线程被resume。由于
<<concept::process::control::resume::thread, resume此线程>>的时候，
线程是ready to run的，因此线程被
立即放入runnable列表，执行的时候打印出360的结果。之后线程以360ns为开始，每隔100ns
打印一个时间戳，直到仿真结束。

从这个例子中，我们也可以看到，一个被suspend的process，仍然可以接受调度请求。
在suspend期间，如果process满足调度条件，那么就会被延迟到resume的时候才会被
调度执行。如果suspend期间不满足调度请求，那么resume的时候，继续之前的状态，
表现起来好像这段suspend期间从未存在过一样。

suspend-resume机制不太适合用于clock驱动的process，因为使用clock驱动的process
很难理解这种把suspend期间发生的事件推迟到resume时候的概念。suspend-resume
一般用来抽象调度器。

=== kill
[[concept::process::control::kill]]

与disable/enable, suspend/resume相比，kill一个process并没有与之配对的函数，这是因为
一但一个Process被kill，就进入zombie状态，等待资源被回收。killed的process是无法
恢复执行的。

kill一个process主要通过sc_process_b的接口类kill_process实现，Thread和Method有着不同
的实现方式。

==== Thread/CThread
[[concept::process::control::kill::thread]]

Thread的kill_process实现如下：

.src/sysc/kernel/sc_thread_process.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_thread_process::kill_process"
//
// This method removes this object instance from use. It calls the
// sc_process_b::kill_process() method to perform low level clean up. Then
// it aborts this process if it is the active process.
//------------------------------------------------------------------------------
void sc_thread_process::kill_process(sc_descendant_inclusion_info descendants )
{

    // IF THE SIMULATION HAS NOT BEEN INITIALIZED YET THAT IS AN ERROR:

    if ( !sc_is_running() )
    {
        report_error( SC_ID_KILL_PROCESS_WHILE_UNITIALIZED_ );
        return;
    }

    // IF NEEDED PROPOGATE THE KILL REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*> children = get_child_objects();
        int                           child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->kill_process(descendants);
        }
    }

    // IF THE PROCESS IS CURRENTLY UNWINDING OR IS ALREADY A ZOMBIE
    // IGNORE THE KILL:

    if ( m_unwinding )
    {
        SC_REPORT_WARNING( SC_ID_PROCESS_ALREADY_UNWINDING_, name() );
        return;
    }

    if ( m_state & ps_bit_zombie )
        return;

    // SET UP TO KILL THE PROCESS IF SIMULATION HAS STARTED:
    //
    // If the thread does not have a stack don't try the throw!

    if ( sc_is_running() && m_has_stack )
    {
        m_throw_status = THROW_KILL;
        m_wait_cycle_n = 0;
        simcontext()->preempt_with(this);
    }

    // IF THE SIMULATION HAS NOT STARTED REMOVE TRACES OF OUR PROCESS FROM
    // EVENT QUEUES, ETC.:

    else
    {
        disconnect_process();
    }
}
----

函数实现最开始是一些简单的检查，以及按需求kill子对象。

''''

如果simulation正在跑，并且 m_has_stack为true（意味着thread已经开始运行，参见
<<api::sc_process_b::semantics, semantics>>部分的设置），那么
就将m_throw_status设置为THROW_KILL，m_wait_cycle_n清零，并调用
<<api::sc_simcontext::preempt_with::thread, preempt_with>>立即调度执行当前的Thread线程。

立即被调度执行的当前线程会从上次的suspend_me中的yield处返回，然后
抛出一个sc_unwind_exception异常，设置为kill，参见
<<api::sc_thread_process::suspend_me, suspend_me>>部分的介绍。

抛出来的异常会在 <<api::sc_thread_cor_fn, `sc_thread_cor_fn`>> 中捕获，结束while
循环，并执行如下代码：

[source,cpp]
----
    sc_process_b*    active_p = sc_get_current_process_b();

    // REMOVE ALL TRACES OF OUR THREAD FROM THE SIMULATORS DATA STRUCTURES:

    thread_h->disconnect_process();

    // IF WE AREN'T ACTIVE MAKE SURE WE WON'T EXECUTE:

    if ( thread_h->next_runnable() != 0 )
    {
	simc_p->remove_runnable_thread(thread_h);
    }

    // IF WE ARE THE ACTIVE PROCESS ABORT OUR EXECUTION:


    if ( active_p == (sc_process_b*)thread_h )
    {

        sc_core::sc_cor* x = simc_p->next_cor();
	simc_p->cor_pkg()->abort( x );
    }
----

如果是因为kill原因导致sc_thread_cor_fn中的while退出，那么这里的 `active_p`
的值应当等于当前线程的值 `thread_h`。这里主要调用了线程的
<<api::sc_process_b::disconnect_process, disconnect_process>>函数。如果当前
thread在runnable列表中，则从中移除。接下来完全结束(abort)当前线程的执行，转而调度
下一个线程。

这样一来，就完成了simulation过程中，一个已经开始运行并挂起的thread的kill动作。

''''

如果被kill的process并没有执行过（因而也没有被挂起），或者simulation已经结束，这里只需要简单调用
process的<<api::sc_process_b::disconnect_process, disconnect_process>>
函数即可。

==== Method
[[concept::process::control::kill::method]]

Method的kill_process相比而言，实现比较简单：

.src/sysc/kernel/sc_method_process.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_method_process::kill_process"
//
// This method removes throws a kill for this object instance. It calls the
// sc_process_b::kill_process() method to perform low level clean up.
//------------------------------------------------------------------------------
void sc_method_process::kill_process(sc_descendant_inclusion_info descendants)
{

    // IF THE SIMULATION HAS NOT BEEN INITIALIZED YET THAT IS AN ERROR:

    if ( !sc_is_running() )
    {
        report_error( SC_ID_KILL_PROCESS_WHILE_UNITIALIZED_ );
        return;
    }

    // IF NEEDED, PROPOGATE THE KILL REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*> children = get_child_objects();
        int                           child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->kill_process(descendants);
        }
    }

    // IF THE PROCESS IS CURRENTLY UNWINDING OR IS ALREADY A ZOMBIE
    // IGNORE THE KILL:

    if ( m_unwinding )
    {
        SC_REPORT_WARNING( SC_ID_PROCESS_ALREADY_UNWINDING_, name() );
        return;
    }

    if ( m_state & ps_bit_zombie )
        return;


    // REMOVE OUR PROCESS FROM EVENTS, ETC., AND IF ITS THE ACTIVE PROCESS
    // THROW ITS KILL.
    //
    // Note we set the throw status to kill regardless if we throw or not.
    // That lets check_for_throws stumble across it if we were in the call
    // chain when the kill call occurred.

    if ( next_runnable() != 0 )
        simcontext()->remove_runnable_method( this );
    disconnect_process();

    m_throw_status = THROW_KILL;
    if ( sc_get_current_process_b() == this )
    {
        throw sc_unwind_exception( this, false );
    }
}
----

函数体之前部分比较简单，和thread的处理基本一致。由于Method不存在挂起的问题，所以在从
runnable中移除可能的method之后，立即调用<<api::sc_process_b::disconnect_process, disconnect_process>>。接下来将m_throw_status置为THROW_KILL。

如果当前运行的线程就是这个method，即kill请求来源自本线程，直接抛出一个sc_unwind_exception。这个
异常会在<<api::sc_method_process::run_process, method的run_process>>
中被catch住，**立即**结束当前的执行。并且由于接下来要分析的原因，这个method永远也不会被调度执行。

如果当前运行的线程不是要被kill的线程，那么要被kill的线程只是被标记为THROW_KILL。
由于被kill的线程已经被从当前runnable list中移除，因此当前delta cycle之后不会执行这个被kill
的method线程了。
同时被kill的线程
调用了disconnect_process，这个method未来也不会再被调度执行了。这就达到了kill method process
的目的。


=== prepare_to_simulate中的状态判断
[[use::process::control::prepare_to_simulate]]

在<<concept::simulate::initialize, 初始化>>部分，我们介绍过，在仿真开始前的时刻，
simc会将所有没有设定dont_initialize的method/thread都放入runnable列表中。这个
说法并不是很准确，因为里边还涉及到一些process状态的判断，现在我们回过头来看一下这部分代码：

.src/sysc/kernel/sc_simcontext.h
[source,cpp]
----
    // make all method processes runnable

    for ( method_p = m_process_table->method_q_head();
	  method_p; method_p = method_p->next_exist() )
    {
	if ( ((method_p->m_state & sc_process_b::ps_bit_disabled) != 0) ||
	     method_p->dont_initialize() )
	{
	    if ( method_p->m_static_events.size() == 0 )
	    {
	        SC_REPORT_WARNING( SC_ID_DISABLE_WILL_ORPHAN_PROCESS_,
		                   method_p->name() );
	    }
	}
	else if ( (method_p->m_state & sc_process_b::ps_bit_suspended) == 0)
	{
            if ( !method_p->is_runnable() ) // already scheduled?
                push_runnable_method_front( method_p );
        }
	else
	{
	    method_p->m_state |= sc_process_b::ps_bit_ready_to_run;
	}
    }

    // make thread processes runnable
    // (cthread processes always have the dont_initialize flag set)

    for ( thread_p = m_process_table->thread_q_head();
	  thread_p; thread_p = thread_p->next_exist() )
    {
	if ( ((thread_p->m_state & sc_process_b::ps_bit_disabled) != 0) ||
	     thread_p->dont_initialize() )
	{
	    if ( thread_p->m_static_events.size() == 0 )
	    {
	        SC_REPORT_WARNING( SC_ID_DISABLE_WILL_ORPHAN_PROCESS_,
		                   thread_p->name() );
	    }
	}
	else if ( (thread_p->m_state & sc_process_b::ps_bit_suspended) == 0)
	{
            if ( !thread_p->is_runnable() ) // already scheduled?
                push_runnable_thread_front( thread_p );
        }
	else
	{
	    thread_p->m_state |= sc_process_b::ps_bit_ready_to_run;
	}
    }
----

这两段代码分别处理了所有的method和thread，处理method和thread的代码一致，我们以thread
为例来说明。

对于每个thread，如果在仿真开始前被disable掉了，或者设置dont_initialize(CThread天然
设置无需初始化)，那么就需要检查，必须存在静态敏感事件。这个和我们之前的分析是一致的。
如果在仿真开始之前线程没有被suspend掉了，这表明线程应当可以执行，放入runnable列表。最后
就是仿真开始之前线程已经被suspend了，由于理论上此时线程应该被执行一次，但是却被suspend，按照
suspend-resume的逻辑，需要标记其为ready to run，这样在resume的时候就可以执行起来了。

== Dynamic Process

动态的process，指的是在仿真开始之后（simulation阶段）创建出来的线程，这些线程一般使用
sc_spawn来实现。sc_spawn也可以用来为那些不符合
<<api::SC_METHOD, SC_METHOD>>和<<api::SC_THREAD, SC_THREAD>>要求的
函数原型的成员函数创建method/thread类型的线程。

=== sc_spawn


[[func::sc_spawn]]
((sc_spawn))用以从给定的参数中生成一个SystemC级别的线程（可以是Method，也可以是Thread，但不会是
CThread）。以下是sc_spawn的实现代码：

.src/sysc/kernel/sc_spawn.h
[source,cpp]
----
template <typename T>
inline sc_process_handle sc_spawn( 
    T object, 
    const char* name_p = 0,
    const sc_spawn_options* opt_p = 0)
{
    sc_simcontext*      context_p;
    sc_spawn_object<T>* spawn_p;
    
    context_p = sc_get_curr_simcontext();
    spawn_p = new sc_spawn_object<T>(object); <1>
    if ( !opt_p || !opt_p->is_method() )
    {
            sc_process_handle thread_handle = context_p->create_thread_process( 
            name_p, true,
            SC_MAKE_FUNC_PTR(sc_spawn_object<T>,semantics), <2>
            spawn_p, opt_p 
        );
        return thread_handle;
    }
    else
    {
            sc_process_handle method_handle = context_p->create_method_process( 
            name_p, true,
            SC_MAKE_FUNC_PTR(sc_spawn_object<T>,semantics), <2>
            spawn_p, opt_p 
        );
        return method_handle;
    }
}
----
<1> 从类型T的对象object创建一个 `sc_spawn_object<T>` 对象
<2> 设置Method/Thread的启动函数为刚才创建对象 spawn_p的 `semantics` 成员函数

从这段代码可以看出，对于给定的对象 `object`，这里会新建一个类型为 `sc_spawn_object<T>`
的对象，设置Method/Thread启动函数为这个新建的对象的 `semantics`。以下是 `sc_spawn_object<>`
的定义：

.src/sysc/kernel/sc_spawn.h
[source,cpp]
----
template<typename T>
class sc_spawn_object : public sc_process_host {
  public:
    sc_spawn_object( T object) : m_object(object)
    {
    }

    virtual void semantics()
    {
        m_object();
    }

  protected:
    T                        m_object; <1>
};
----
<1> sc_spwan_object保存了对象的拷贝

所以我们能看到， `semantics` 成员函数实际上调用的是 `m_object()` ，这意味着
对象的类必须重载了 `operator()` 才可以。

在sc_spawn的时候，我们可以看到，创建method/thread时候的第二个参数被设置为true，这与
使用<<api::SC_THREAD, SC_THREAD>>创建Thread线程，使用<<api::SC_METHOD, SC_METHOD>>
创建Method线程时都不同（那两个都将第二个参数设置为false）。这实际上是free_host参数，表明
这个method/thread所依赖的对象是否是一个自由对象。如果是，那么在相应的sc_process_b
析构的时候，会调用delete删除此对象。这也是为何在sc_spawn中，只new不delete却不会内存
泄漏的原因：

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
sc_process_b::~sc_process_b()
{

    // REDIRECT ANY CHILDREN AS CHILDREN OF THE SIMULATION CONTEXT:

    orphan_child_objects();


    // DELETE SEMANTICS OBJECTS IF NEED BE:

    if ( m_free_host ) delete m_semantics_host_p; <1>
#   if !defined(SC_USE_MEMBER_FUNC_PTR) // Remove invocation object.
        delete m_semantics_method_p;
#   endif


    // REMOVE ANY STRUCTURES THAT MAY HAVE BEEN BUILT:

    delete m_last_report_p;
    delete m_name_gen_p;
    delete m_reset_event_p;
    delete m_resume_event_p;
    delete m_term_event_p;
    delete m_throw_helper_p;
    delete m_timeout_event_p;

}
----
<1> 如果设置free host，在相应的sc_process_b析构的时候，会帮忙删除new出来的对象

另一个值得观察的地方在于，sc_spawn创建Method/Thread的最后一个参数都不为空，而是可能
给出参数。这个参数就是 `sc_spawn_options` 指针。之所以如此，是因为sc_spawn创建
出来的method/thread，没有类似<<api::SC_THREAD, SC_THREAD>>和<<api::SC_METHOD, SC_METHOD>>
那样可以辅助设置静态敏感事件、设定是否需要初始化等操作。为了支持这些，sc_spawn允许
传入一个 `sc_spwan_options` 对象的指针，补上这些。

例如，在sc_thread_process的构造函数中，有这么一段代码：

.src/sysc/kernel/sc_thread_process.cpp
[source,cpp]
----
    if (opt_p) {
        m_dont_init = opt_p->m_dont_initialize;
        if ( opt_p->m_stack_size ) m_stack_size = opt_p->m_stack_size;

        // traverse event sensitivity list
        for (unsigned int i = 0; i < opt_p->m_sensitive_events.size(); i++) {
            sc_sensitive::make_static_sensitivity(
                this, *opt_p->m_sensitive_events[i]);
        }

        // traverse port base sensitivity list
        for ( unsigned int i = 0; i < opt_p->m_sensitive_port_bases.size(); i++)
        {
            sc_sensitive::make_static_sensitivity(
                this, *opt_p->m_sensitive_port_bases[i]);
        }

        // traverse interface sensitivity list
        for ( unsigned int i = 0; i < opt_p->m_sensitive_interfaces.size(); i++)
        {
            sc_sensitive::make_static_sensitivity(
                this, *opt_p->m_sensitive_interfaces[i]);
        }

        // traverse event finder sensitivity list
        for ( unsigned int i = 0; i < opt_p->m_sensitive_event_finders.size();
            i++)
        {
            sc_sensitive::make_static_sensitivity(
                this, *opt_p->m_sensitive_event_finders[i]);
        }

        // process any reset signal specification:

	opt_p->specify_resets();

    }

    else
    {
        m_dont_init = false;
    }
----

这里在 `opt_p` 非空，即外界传入一个有效的 `sc_spawn_options` 指针的时候，使用这个
对象里的选项来初始化sc_thread_process的内容。sc_method_process的构造函数有着一样
的实现。

[[usage::sc_spawn::sc_clock]]
举个sc_spawn使用的例子。在((sc_clock))的before_end_of_elaboration中，
sc_clock就是用sc_spawn，创造出两个
METHOD，分别用来实现上升沿事件和下降沿事件：

.src/sysc/communication/sc_clock.cpp
[source,cpp]
----
void sc_clock::before_end_of_elaboration()
{
    std::string gen_base;
    sc_spawn_options posedge_options;	// Options for posedge process.
    sc_spawn_options negedge_options;	// Options for negedge process.

    posedge_options.spawn_method();
    posedge_options.dont_initialize();
    posedge_options.set_sensitivity(&m_next_posedge_event);
    gen_base = basename();
    gen_base += "_posedge_action";
    sc_spawn(sc_clock_posedge_callback(this),
	sc_gen_unique_name( gen_base.c_str() ), &posedge_options);

    negedge_options.spawn_method();
    negedge_options.dont_initialize();
    negedge_options.set_sensitivity(&m_next_negedge_event);
    gen_base = basename();
    gen_base += "_negedge_action";
    sc_spawn( sc_clock_negedge_callback(this),
    	sc_gen_unique_name( gen_base.c_str() ), &negedge_options );
}
----

这里sc_clock需要用 sc_spawn_options，指定：

* 创造出来的是Method，而不是Thread(如果不指定，则默认创造Thread)
* 无需初始化
* 设置两个Method的静态敏感事件列表

sc_spawn设置的两个Method，宿主是 `sc_clock_posedge_callback(this)` 和
`sc_clock_negedge_callback(this)` 。两个都是临时对象，这不会带来问题，因为
在 `sc_spawn_object<T>` 构造的时候，对象是**拷贝**而不是引用进来的。两个Method
的函数体就是 `sc_clock_posedge_callback(this)` 和 `sc_clock_negedge_callback(this)`
的 `operator()` :

.src/sysc/communication/sc_clock.h
[source,cpp]
----

class SC_API sc_clock_posedge_callback {
public:
    sc_clock_posedge_callback(sc_clock* target_p) : m_target_p(target_p) {}
    inline void operator () () { m_target_p->posedge_action(); }
  protected:
    sc_clock* m_target_p;
};

class SC_API sc_clock_negedge_callback {
  public:
    sc_clock_negedge_callback(sc_clock* target_p) : m_target_p(target_p) {}
    inline void operator () () { m_target_p->negedge_action(); }
  protected:
    sc_clock* m_target_p;
};
----

所以实际上，当 `sc_clock` 的 m_next_posedge_event发生的时候，调用的是自己的 `posedge_action`
函数。当 m_next_negedge_event发生的时候，调用的是自己的 `negedge_action` 函数。
这也是这两个辅助类名字里的 `callback` 含义所在。

.src/sysc/communication/sc_clock.h
[source,cpp]
----
inline
void
sc_clock::posedge_action()
{
    m_next_negedge_event.notify_internal( m_negedge_time );
	m_new_val = true;
	request_update(); <1>
}

inline
void
sc_clock::negedge_action()
{
    m_next_posedge_event.notify_internal( m_posedge_time );
	m_new_val = false;
	request_update(); <1>
}
----
<1> sc_clock继承自sc_signal，需要调用 `request_update` 在UPDATE PHASE更新值

在 `posedge_action` 中，设置了延时 `m_negedge_time` 后，`m_next_negedge_event`
发生。同样，在 `negedge_action` 中，设置了延时 `m_posedge_time` 后， `m_next_posedge_event`
发生。如此，只要 m_next_posedge_event和m_next_negedge_event中有一个事件发生，sc_clock
就可以自我驱动下去，实现了时钟的功能。

m_next_posedge_event和m_next_negedge_event谁先发生，取决于sc_clock初始化的时候
的设置。这是概念上，一个clock时钟初始时是0还是1的区别：初始为0，那么先发生上升沿事件，初始为1
则先发生下降沿事件。例如，在sc_clock的某个构造函数中，有这么一段：

.src/sysc/communication/sc_clock.h
[source,cpp]
----
    init( sc_time( period_v_, period_tu_, simcontext() ),
	  duty_cycle_,
	  sc_time( start_time_v_, start_time_tu_, simcontext() ),
	  posedge_first_ );

    if( posedge_first_ ) {
	// posedge first
	m_next_posedge_event.notify_internal( m_start_time );
    } else {
	// negedge first
	m_next_negedge_event.notify_internal( m_start_time );
    }
----

先用 `init` 成员函数初始化值。接下来，如果要求现有上升沿，就让事件m_next_posedge_event
发生，否则就先让 m_next_negedge_event发生。可以想象，在init中，也是根据是否先要上升沿
决定当前值的：如果现有上升沿，初始值为0，否则为1：

[source,cpp]
----
    if( posedge_first_ ) {
	this->m_cur_val = false;
	this->m_new_val = false;
    } else {
	this->m_cur_val = true;
	this->m_new_val = true;
    }
----

sc_clock虽然只是一个sc_signal，但是借助sc_spawn，获得了类似于
<<data::sc_module, sc_module>>
这样的能够创建单独线程的能力，这就实现了sc_clock的自激励特性。

=== sc_bind, sc_ref和sc_cref
[[func::sc_bind]]

为支持动态process功能，SystemC内置了如下3个辅助函数 footnote:[根据SystemC的开发记录，这些应当是从Boost中借鉴过来的]：
[[func::sc_cref]]

* sc_bind
* sc_ref
* sc_cref

[[func::sc_ref]]
.src/sysc/kernel/sc_dynamic_processes.h
[source,cpp]
----
namespace sc_unnamed {
using namespace std::placeholders;
} // namespace sc_unnamed

namespace sc_core {

template<typename F, typename... Args>
auto sc_bind( F&& f, Args&&... args )
#  if SC_CPLUSPLUS < 201402L // explicit return type needed before C++14
   -> decltype( std::bind(std::forward<F>(f), std::forward<Args>(args)...) )
#  endif
 { return std::bind( std::forward<F>(f), std::forward<Args>(args)... ); }

template<typename T>
auto sc_ref( T&& v )
#  if SC_CPLUSPLUS < 201402L // explicit return type needed before C++14
   -> decltype( std::ref(std::forward<T>(v) ) )
#  endif
 { return std::ref( std::forward<T>(v) ); }

template<typename T>
auto sc_cref( T&& v )
#  if SC_CPLUSPLUS < 201402L // explicit return type needed before C++14
   -> decltype( std::cref(std::forward<T>(v) ) )
#  endif
 { return std::cref( std::forward<T>(v) ); }

} // namespace sc_core
----

从代码实现来看，对于支持C{plus}{plus}11的编译器而言，这三个其实就是 `std::bind`， `std::ref`
和 `std::cref` 的别名而已。

sc_bind(可以认为就是std::bind)返回的是一个functor，天然重载了 `operator()` ，无需
显式重载 `operator()` 。

== preempt_with
[[api::sc_simcontext::preempt_with]]

preempt_with实现了“抢占”执行的概念，实际上SystemC仍然使用协程调度的方式，所谓的抢占
执行，只不过是把当前的process现场保存下来，然后调度需要抢占执行的协程而已。


根据要抢占执行的对象不同，preempt_with分为两种重载形式：

* 要抢占执行的是thread
* 要抢占执行的是method

=== thread重载形式
[[api::sc_simcontext::preempt_with::thread]]

当要抢占执行的是一个thread的时候，分三种情况：

* 被抢占的process是一个method
* 被抢占的process是其他thread
* 被抢占的process就是要抢占的thread

.src/sysc/kernel/sc_simcontext_int.h
[source,cpp]
----
// +----------------------------------------------------------------------------
// |"sc_simcontext::preempt_with"
// |
// | This method executes the supplied thread immediately, suspending the
// | caller. After executing the supplied thread the caller's execution will
// | be restored. It is used to allow a thread to immediately throw an
// | exception, e.g., when the thread's kill_process() method was called.
// | There are three cases to consider:
// |   (1) The caller is a method, e.g., murder by method.
// |   (2) The caller is another thread instance, e.g., murder by thread.
// |   (3) The caller is this thread instance, e.g., suicide.
// |
// | Arguments:
// |     thread_h -> thread to be executed.
// +----------------------------------------------------------------------------
inline
void
sc_simcontext::preempt_with( sc_thread_handle thread_h )
{
    sc_thread_handle  active_p;    // active thread or null.
    sc_curr_proc_info caller_info; // process info for caller.

    // Determine the active process and take the thread to be run off the
    // run queue, if its there, since we will be explicitly causing its
    // execution.

    active_p = dynamic_cast<sc_thread_handle>(sc_get_current_process_b()); <1>
    if ( thread_h->next_runnable() != NULL ) <2>
	remove_runnable_thread( thread_h );

    // THE CALLER IS A METHOD:
    //
    //   (a) Set the current process information to our thread.
    //   (b) If the method was called by an invoker thread push that thread
    //       onto the front of the run queue, this will cause the method
    //       to be resumed after this thread waits.
    //   (c) Invoke our thread directly by-passing the run queue.
    //   (d) Restore the process info to the caller.
    //   (e) Check to see if the calling method should throw an exception
    //       because of activity that occurred during the preemption.

    if ( active_p == NULL ) <3>
    {
	std::vector<sc_thread_handle>* invokers_p;  // active invokers stack.
	sc_thread_handle           invoke_thread_p; // latest invocation thread.
        sc_method_handle           method_p;        // active method.

	method_p = dynamic_cast<sc_method_handle>(sc_get_current_process_b());
	invokers_p = &get_active_invokers();
	caller_info = m_curr_proc_info;
	if ( invokers_p->size() != 0 )
	{
	    invoke_thread_p = invokers_p->back();
	    DEBUG_MSG( DEBUG_NAME, invoke_thread_p,
	        "queueing invocation thread to execute next" );
	    execute_thread_next(invoke_thread_p);
	}
        DEBUG_MSG( DEBUG_NAME, thread_h, "preempting method with thread" );
	set_curr_proc( (sc_process_b*)thread_h );
	m_cor_pkg->yield( thread_h->m_cor_p );
	m_curr_proc_info = caller_info;
        DEBUG_MSG(DEBUG_NAME, thread_h, "back from preempting method w/thread");
	method_p->check_for_throws();
    }

    // CALLER IS A THREAD, BUT NOT THE THREAD TO BE RUN:
    //
    //   (a) Push the calling thread onto the front of the runnable queue
    //       so it be the first thread to be run after this thread.
    //   (b) Push the thread to be run onto the front of the runnable queue so
    //       it will execute when we suspend the calling thread.
    //   (c) Suspend the active thread.

    else if ( active_p != thread_h )
    {
        DEBUG_MSG( DEBUG_NAME, thread_h,
	           "preempting active thread with thread" );
        execute_thread_next( active_p );
	execute_thread_next( thread_h );
	active_p->suspend_me();
    }

    // CALLER IS THE THREAD TO BE RUN:
    //
    //   (a) Push the thread to be run onto the front of the runnable queue so
    //       it will execute when we suspend the calling thread.
    //   (b) Suspend the active thread.

    else
    {
        DEBUG_MSG(DEBUG_NAME,thread_h,"self preemption of active thread");
	execute_thread_next( thread_h );
	active_p->suspend_me();
    }
}
----
<1> active_p保存的就是被抢占的process的handle
<2> 要抢占的process的next_runnable不为空，意味着被抢占的process就在接下来的runnable list中等待被调度执行，这种情况下需要从runnable list中先将被抢占的process移除出去
<3> 如果强制cast成 sc_thread_process指针，获得一个空指针，那么当前的process一定是一个method，因为preempt_with只能从process中被调用，不能从其他地方被调用

''''

如果被抢占的是一个method，执行如下代码序列：

[source,cpp]
----
	invokers_p = &get_active_invokers();
	caller_info = m_curr_proc_info; <1>
	if ( invokers_p->size() != 0 )
	{
	    invoke_thread_p = invokers_p->back();
	    DEBUG_MSG( DEBUG_NAME, invoke_thread_p,
	        "queueing invocation thread to execute next" );
	    execute_thread_next(invoke_thread_p);
	}
        DEBUG_MSG( DEBUG_NAME, thread_h, "preempting method with thread" );
	set_curr_proc( (sc_process_b*)thread_h ); <2>
	m_cor_pkg->yield( thread_h->m_cor_p ); <3>
	m_curr_proc_info = caller_info; <4>
        DEBUG_MSG(DEBUG_NAME, thread_h, "back from preempting method w/thread");
	method_p->check_for_throws(); <5>
----
<1> 保存被抢占的method process的information
<2> 设置抢占的thread为当前process
<3> 调度执行抢占的thread
<4> 恢复method process的信息
<5> 检查method是否需要抛出异常，因为抢占执行的thread执行过程中有可能改变被抢占的method的状态的

抢占的thread需要执行，就必须使用协程调度的方式。抢占的thread被恢复执行的时候，从
上一次的suspend_me处返回，检查thread本身的状态已决定是否需要抛出异常。
例如，在从<<api::sc_thread_process::throw_reset, thread线程的throw_reset>>
中，首先将线程 m_throw_status 置位同步或者异步reset，然后如果是异步reset，并且simulation
正在EVALUATE阶段，调用 preempt_with，这样一来当前线程会立马
从上次阻塞的 suspend_me恢复过来，检查得到需要抛出一个reset形式的异常。这个异常在
<<api::sc_thread_cor_fn, sc_thread_cor_fn>>中被捕获，从而重新运行
此thread线程，直到遇到suspend_me为止。而thread被重新执行，遇到suspend_m需要挂起，
需要恢复的地方是simc中下一个coroutine，下一个coroutine会是哪个？这点存疑。

理论上来说，一个method process，被thread process抢占，这个method process调用
`m_cor_pkg->yield(thread_h->m_cor_p);` 之后，thread process得到执行。这个
thread process应当在被阻塞的时候，将执行权交回给method process才对。但目前看来
这个thread process在阻塞的时候，suspend_me里，会寻找下一个runnable 的 thread来执行，
直到所有runnable thread process都执行完毕，才将执行权返回给method process。
这意味着不止有被reset的线程得到执行，所有其他runnable且未被执行的thread也都会被
执行，这点有点不太符合常理。如果SyseteC希望保证只有被reset的线程重新执行，那么是如何
做到的呢？


''''

如果被抢占的process是一个其他的thread process，则执行如下代码：

[source,cpp]
----
        DEBUG_MSG( DEBUG_NAME, thread_h,
	           "preempting active thread with thread" );
        execute_thread_next( active_p );
	execute_thread_next( thread_h );
	active_p->suspend_me();
----

`execute_thread_next` 可以将一个thread process放入runnable list的最前边。
这里首先将被抢占的thread process放回runnable，然后将要抢占的thread process放入runnable。
接下来调用被抢占的 thread的suspend_me，被抢占thread被挂起，simc接下来立马执行
要抢占的thread process，并在阻塞后，继续调度下一个runnable的thread process。由于
runnable中，被抢占的thread process就在要抢占的thread process之后，这回继续执行
被抢占的thread process，即被抢占的thread process调用的suspend_me在这里返回。

这样达到的效果就是，要抢占的thread在被抢占的thread suspend_me之后得到一次执行机会，
并在要抢占的thread阻塞后，恢复到被抢占的thread的suspend_me处，返回，继续执行。

''''

如果被抢占的process就是本thread process，则执行如下代码：

[source,cpp]
----
        DEBUG_MSG(DEBUG_NAME,thread_h,"self preemption of active thread");
	execute_thread_next( thread_h );
	active_p->suspend_me();
----

将本thread放入runnable最开始，接下来的suspend_me。但这次，suspend_me并不会把
本thread挂起，因为在suspend_me中：

[source,cpp]
----
    sc_cor*         cor_p = simc_p->next_cor();

    // do not switch, if we're about to execute next (e.g. suicide)

    if( m_cor_p != cor_p )
    {
        DEBUG_MSG( DEBUG_NAME , this, "suspending thread");
        simc_p->cor_pkg()->yield( cor_p );
        DEBUG_MSG( DEBUG_NAME , this, "resuming thread");
    }
----

只有接下来要执行的线程不等于当前线程，才会挂起当前线程，执行下一个线程。如果当前线程
等于接下来要执行的线程，这里只会简单走过去，进入接下来的suspend_me中的 `m_throw_status`
判断。如果m_throw_status显示需要一个同步或者异步的reset，那么这里就会抛出一个异常，
在<<api::sc_thread_cor_fn, sc_thread_cor_fn>>中截获，从头开始执行此线程。

所以，如果是线程抢占本线程，在reset的情况下 `active_p->suspend_me()` 从不会返回。
这表现为一个线程如果在内部reset了自己, reset立马生效，之后的代码不会执行。

这个行为需要确认。

=== method重载形式
[[api::sc_simcontext::preempt_with::method]]

method重载形式的preempt_with的代码如下：

.src/sysc/kernel/sc_simcontext.cpp
[source,cpp]
----
// +----------------------------------------------------------------------------
// |"sc_simcontext::preempt_with"
// |
// | This method executes the supplied method immediately, suspending the
// | caller. After executing the supplied method the caller's execution will
// | be restored. It is used to allow a method to immediately throw an
// | exception, e.g., when the method's kill_process() method was called.
// | There are three cases to consider:
// |   (1) The caller is a method, e.g., murder by method.
// |   (2) The caller is a thread instance, e.g., murder by thread.
// |   (3) The caller is this method instance, e.g., suicide.
// |
// | Arguments:
// |     method_h -> method to be executed.
// +----------------------------------------------------------------------------
void
sc_simcontext::preempt_with( sc_method_handle method_h )
{
    sc_curr_proc_info caller_info;     // process info for caller.
    sc_method_handle  active_method_h; // active method or null.
    sc_thread_handle  active_thread_h; // active thread or null.

    // Determine the active process and take the thread to be run off the
    // run queue, if its there, since we will be explicitly causing its
    // execution.

    active_method_h = dynamic_cast<sc_method_handle>(sc_get_current_process_b());
    active_thread_h = dynamic_cast<sc_thread_handle>(sc_get_current_process_b());
    if ( method_h->next_runnable() != NULL )
	remove_runnable_method( method_h );

    // CALLER IS THE METHOD TO BE RUN:
    //
    // Should never get here, ignore it unless we are debugging.

    if ( method_h == active_method_h )
    {
        DEBUG_MSG(DEBUG_NAME,method_h,"self preemption of active method");
    }

    // THE CALLER IS A METHOD:
    //
    //   (a) Set the current process information to our method.
    //   (b) Invoke our method directly by-passing the run queue.
    //   (c) Restore the process info to the caller.
    //   (d) Check to see if the calling method should throw an exception
    //       because of activity that occurred during the preemption.

    else if ( active_method_h != NULL )
    {
	caller_info = m_curr_proc_info;
        DEBUG_MSG( DEBUG_NAME, method_h,
	           "preempting active method with method" );
	sc_get_curr_simcontext()->set_curr_proc( (sc_process_b*)method_h );
	method_h->run_process();
	sc_get_curr_simcontext()->set_curr_proc((sc_process_b*)active_method_h);
	active_method_h->check_for_throws();
    }

    // CALLER IS A THREAD:
    //
    //   (a) Use an invocation thread to execute the method.

    else if ( active_thread_h != NULL )
    {
        DEBUG_MSG( DEBUG_NAME, method_h,
	           "preempting active thread with method" );
	m_method_invoker_p->invoke_method(method_h);
    }

    // CALLER IS THE SIMULATOR:
    //
    // That is not allowed.

    else
    {
	caller_info = m_curr_proc_info;
        DEBUG_MSG( DEBUG_NAME, method_h,
	           "preempting no active process with method" );
	sc_get_curr_simcontext()->set_curr_proc( (sc_process_b*)method_h );
	method_h->run_process();
	m_curr_proc_info = caller_info;
    }
}
----

method的抢占执行相对来说还是比较加单的，因为method不需要协程的支持，每次method
运行都是一次完整的运行。

这里我们重点关注method抢占thread的执行：

[source,cpp]
----
    else if ( active_thread_h != NULL )
    {
        DEBUG_MSG( DEBUG_NAME, method_h,
	           "preempting active thread with method" );
	m_method_invoker_p->invoke_method(method_h);
    }
----

这里为了在执行thread的时候，抢占执行一个method，而设计了一个 `m_method_invoker_p`
的方式。

== Process小结

Process是SystemC中非常重要的一个概念，是SystemC执行调度的基础。两种不同类型的Process也分别
适合建模不同的逻辑：Method适合建模组合逻辑，Thread适合建模时序逻辑，当然这种适合并非意味
着只能建模相应的逻辑。

Process也是使用SystemC最直观的部分。Process和Primitive Channel, Event一起，组成了
SystemC调度核心三要素，分别参与到delta cycle中的EVALUATE, NOTIFICATION, UPDATE
阶段。

对于Process的控制，SystemC也提供了非常多的方式，诸如suspend/resume, disable/enable, reset,
kill等，极大地方便了SystemC的使用。