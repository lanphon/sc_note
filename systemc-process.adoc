:source-highlighter: coderay

:toc: left

SystemC中的process
[[chap::process]]

== 引言

在<<chap::schedule_model, SystemC调度模型>>
一章中，我们已经可以了解SystemC是如何创建和使用Process的。
本部分是对SystemC中Method/Thread/CThread的总结。

在开始之前，我们需要厘清以下几个数据结构的关系：

* sc_process_b 是所有method/thread/cthread的基础类，直接继承自 `sc_object`
* sc_thread_process直接继承自sc_process_b，是表示thread线程的数据结构
* sc_method_process直接继承自sc_process_b，是表示method线程的数据结构
* sc_cthread_process直接继承自sc_thread_process，是表示cthread线程的数据结构
* sc_thread_handle是 `sc_thread_process*` 的别名
* sc_method_handle是 `sc_method_process*` 的别名
* sc_cthread_handle是 `sc_cthread_process*` 的别名
* sc_process_handle是基础类，不继承任何其他类，内部保存一个指向sc_process_b的指针，因此可以认为是一个包装类

== sc_process_b
[[data::sc_process_b]]

=== 成员变量

sc_process_b 继承自 `sc_object` ，除了继承得到的成员变量以外，sc_process_b还
增加了非常丰富的成员变量，以支持process这一概念：

.src/sysc/kernel/sc_process.h
[source,cpp]
----
    // debugging stuff:

  public:
    const char*                 file;
    int                         lineno;
    int                         proc_id;

  protected:
    int                          m_active_areset_n; // number of aresets active.
    int                          m_active_reset_n;  // number of resets active.
    bool                         m_dont_init;       // true: no initialize call.
    spawn_t                      m_dynamic_proc;    // SPAWN_ELAB, SPAWN_START, SPAWN_SIM
    const sc_event*              m_event_p;         // Dynamic event waiting on.
    int                          m_event_count;     // number of events.
    const sc_event_list*         m_event_list_p;    // event list waiting on.
    sc_process_b*                m_exist_p;         // process existence link.
    bool                         m_free_host;       // free sc_semantic_host_p.
    bool                         m_has_reset_signal;  // has reset_signal_is.
    bool                         m_has_stack;       // true is stack present.
    bool                         m_is_thread;       // true if this is thread.
    sc_report*                   m_last_report_p;   // last report this process.
    sc_name_gen*                 m_name_gen_p;      // subprocess name generator
    sc_curr_proc_kind            m_process_kind;    // type of process.
    int                          m_references_n;    // outstanding handles.
    std::vector<sc_reset*>       m_resets;          // resets for process.
    sc_event*                    m_reset_event_p;   // reset event.
    sc_event*                    m_resume_event_p;  // resume event.
    sc_process_b*                m_runnable_p;      // sc_runnable link
    sc_process_host*             m_semantics_host_p;   // host for semantics.
    SC_ENTRY_FUNC                m_semantics_method_p; // method for semantics.
    int                          m_state;           // process state.
    std::vector<const sc_event*> m_static_events;   // static events waiting on.
    bool                         m_sticky_reset;    // see note 3 above.
    sc_event*                    m_term_event_p;    // terminated event.
    sc_throw_it_helper*          m_throw_helper_p;  // what to throw.
    process_throw_type           m_throw_status;    // exception throwing status
    bool                         m_timed_out;       // true if we timed out.
    sc_event*                    m_timeout_event_p; // timeout event.
    trigger_t                    m_trigger_type;    // type of trigger using.
    bool                         m_unwinding;       // true if unwinding stack.
----

sc_process_b的成员变量比较复杂，这里我们按照这些成员变量的作用一个一个说。

第一组是用来做debug目的的三个成员变量：

----
    const char*                 file;
    int                         lineno;
    int                         proc_id;
----

然后是做reset处理的两个成员变量：

----
    int                          m_active_areset_n; // number of aresets active.
    int                          m_active_reset_n;  // number of resets active.
----

单独的 `m_dont_init` 是用来表示process是否需要在最初执行一遍，参考
<<api::dont_initialize, 控制METHOD线程是否初始化>>部分的使用：

----
    bool                         m_dont_init;       // true: no initialize call.
----

成员变量 `m_dynamic_proc` 与动态线程有关：

----
    spawn_t                      m_dynamic_proc;    // SPAWN_ELAB, SPAWN_START, SPAWN_SIM
----

而接下来的三个变量则是处理动态敏感的。如果wait/next_trigger在一个单独的event上，就使用
成员变量 `m_event_p` 保存这个事件的指针。如果wait/next_trigger在多个事件上，就使用
成员变量 `m_event_list_p` 保存创建出来的sc_event_list派生类的指针。对于AND LIST类型
的多个事件， `m_event_count` 保存着事件的个数，以方便事件发生的时候进行计数：

----
    const sc_event*              m_event_p;         // Dynamic event waiting on.
    int                          m_event_count;     // number of events.
    const sc_event_list*         m_event_list_p;    // event list waiting on.
----

成员变量 `m_exist_p` 构成了一条process之间的链表。这个成员变量在sc_process_b中没有
使用，在sc_method_process和sc_thread_process中，分别用一对set_next_exist和next_exist
API使用了这个成员变量，而set_next_exist API在创建线程的时候被调用，将新建的
process handle放入simc的 `m_process_table` 中：

----
    sc_process_b*                m_exist_p;         // process existence link.
----

接下来这四个bool成员变量都是创建时候设定的，其中 `m_is_thread` 在SystemC中没有得到使用。
`m_last_report_p` 是sc_report类型，目前还不清楚作用。 `m_name_gen_p` 是用来
辅助产生hierarchy命名的部分。而 `m_process_kind` 则是用来表示派生类的类型，可选的有
METHOD，THREAD和CTHREAD：

----
    bool                         m_free_host;       // free sc_semantic_host_p.
    bool                         m_has_reset_signal;  // has reset_signal_is.
    bool                         m_has_stack;       // true is stack present.
    bool                         m_is_thread;       // true if this is thread.
    sc_report*                   m_last_report_p;   // last report this process.
    sc_name_gen*                 m_name_gen_p;      // subprocess name generator
    sc_curr_proc_kind            m_process_kind;    // type of process.
----

成员变量 `m_references_n` 是用来做引用计数中，计数器角色的。这个看起来和动态线程
中的资源自动释放机制有关：

----
    int                          m_references_n;    // outstanding handles.
----

这一组成员变量和reset/resume机制有关：

----
    std::vector<sc_reset*>       m_resets;          // resets for process.
    sc_event*                    m_reset_event_p;   // reset event.
    sc_event*                    m_resume_event_p;  // resume event.
----

`m_runnable_p` 成员变量使得sc_process_b能够形成一个链表，链表中的每个节点
都是一个进入runnable状态的线程：

----
    sc_process_b*                m_runnable_p;      // sc_runnable link
----

这一组成员变量就是sc_process_b所代表的线程的入口函数，以及基类指针：

----
    sc_process_host*             m_semantics_host_p;   // host for semantics.
    SC_ENTRY_FUNC                m_semantics_method_p; // method for semantics.
----

[[data::sc_process_b::m_state]]
`m_state` 表示的是当前线程的状态，这个integer类型采用了位掩码的方式，来表示各种
不同的状态的组合：

----
    int                          m_state;           // process state.
----

目前定义的状态位有：

.src/sysc/kernel/sc_process.h
[source,cpp]
----
    enum process_state {
	ps_bit_disabled = 1,      // process is disabled.
	ps_bit_ready_to_run = 2,  // process is ready to run.
        ps_bit_suspended = 4,     // process is suspended.
	ps_bit_zombie = 8,        // process is a zombie.
        ps_normal = 0             // must be zero.
    };
----

sc_process_b构造的时候， `m_state`的值为 `ps_normal` 。ps_normal是个特殊的值，它
并不是一个位掩码，而是一个全0的值。这意味着当没有任何一个位掩码置位的时候，就是ps_normal。
所以在使用的时候，ps_normal可以不需要显式赋值，只需要将原先状态位的位掩码一个一个去掉，全部
清除之后，状态自然变成了ps_normal了。


`m_static_events` 则是本process所设置的静态事件对象列表，这些事件之间是或的关系，只要有一个
事件发生，就可能唤醒此线程：

----
    std::vector<const sc_event*> m_static_events;   // static events waiting on.
----

这四个成员变量和sticky_reset以及异常机制有关：

----
    bool                         m_sticky_reset;    // see note 3 above.
    sc_event*                    m_term_event_p;    // terminated event. <1>
    sc_throw_it_helper*          m_throw_helper_p;  // what to throw.
    process_throw_type           m_throw_status;    // exception throwing status
----
<1> 当sc_process_b的 `disconnect_process` 被调用的时候，m_term_event_p被notify

`m_timed_out` 表示process是否超时，目前没看到与之相关的代码：

----
    bool                         m_timed_out;       // true if we timed out.
----

`m_timeout_event_p` 则保存了当process动态敏感时候，带延时时间时，延时时间对象的指针：

----
    sc_event*                    m_timeout_event_p; // timeout event.
----

`m_trigger_type` 表明了当前的trigger类型，动态和静态trigger有不同的处理流程：

----
    trigger_t                    m_trigger_type;    // type of trigger using.
----

最后一个成员变量 `m_unwinding` 与异常处理的时候，堆栈展开有关：

----
    bool                         m_unwinding;       // true if unwinding stack.
----

==== 静态/动态事件

Process的成员变量中，有多个与sc_event相关的部分，这些是process静态或者动态调度时所依赖
的时间对象。Process使用哪些对象，要根据 `m_trigger_type` 判断：

* trigger type为 `STATIC` ，使用 m_static_events 里所保存的事件对象
* trigger type为 `EVENT` ，使用 m_event_p 所保存的事件对象
* trigger type为 `OR_LIST` ，使用 m_event_list_p 所保存的事件列表对象
* trigger type为 `AND_LIST` ，使用 m_event_list_p 所保存的事件列表对象，并辅助使用 m_event_count 记录事件发生的数目
* trigger type为 `TIMEOUT` ，使用 m_timeout_event_p 所保存的事件对象
* trigger type为 `EVENT_TIMEOUT` ，使用 m_event_p 和 m_timeout_event_p 两个事件对象
* trigger type为 `OR_LIST_TIMEOUT` ，使用 m_event_list_p 和 m_timeout_event_p 两个对象
* trigger type为 `AND_LIST_TIMEOUT` ，使用 m_event_list_p 和 m_timeout_event_p 两个对象，并辅助使用 m_event_count

一种特定trigger type下，不使用的动态部分需要清空。

=== 重要成员函数

==== semantics
[[api::sc_process_b::semantics]]

sc_process_b的semantics函数会启动sc_process_b所保存的线程函数，这个我们在
<<api::semantic, coroutine>>部分已经讲过了。除此之外，semantics还需要
处理一些异常相关的部分。semantics的函数实现如下：

.src/sysc/kernel/sc_process.h
[source,cpp]
----
inline void sc_process_b::semantics()
{

    // within this function, the process has a stack associated

    scoped_flag scoped_stack_flag( m_has_stack );

    sc_assert( m_process_kind != SC_NO_PROC_ );

    // Determine the reset status of this object instance and potentially
    // trigger its notify event:

    // See if we need to trigger the notify event:

    if ( m_reset_event_p &&
         ( (m_throw_status == THROW_SYNC_RESET) ||
	   (m_throw_status == THROW_ASYNC_RESET) )
    ) {
        trigger_reset_event();
    }

    // Set the new reset status of this object based on the reset counts:

    m_throw_status = m_active_areset_n ? THROW_ASYNC_RESET :
        ( m_active_reset_n  ?  THROW_SYNC_RESET : THROW_NONE);

    // Dispatch the actual semantics for the process:

#   ifndef SC_USE_MEMBER_FUNC_PTR
        m_semantics_method_p->invoke( m_semantics_host_p );
#   else
        (m_semantics_host_p->*m_semantics_method_p)();
#   endif
}
----

在启动线程函数之前，semantics会首先检查变量 `m_throw_status`的值，
看是否有需要抛出什么东西。如果需要异步或者同步reset，那就
调用 `trigger_reset_event`，这其实就是一个很简单的事件对象的 `notify`

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
void sc_process_b::trigger_reset_event()
{
    if ( m_reset_event_p ) m_reset_event_p->notify();
}
----

接下来 `m_throw_status` 会根据 `m_active_areset_n` 和 `m_active_reset_n`
的值被赋值，其中异步reset计数器优先级高于同步reset计数器。

在同步reset的时候，我们会调用 
<<api::sc_process_handle::sync_reset_on, sync_reset_on>> 开启同步reset周期。这会
调用 <<api::sc_process_b::reset_changed, reset_changed>>，将 `m_active_reset_n` 计数器加一。
`m_active_reset_n` 计数器会一直保持，直到
<<api::sc_process_handle::sync_reset_on, sync_reset_off>>
被调用为止。这意味着，如果 `sync_reset_on` 和 `sync_reset_off`
所定义的同步reset周期内，process被多次启动，那么每一次 `m_throw_status`
都会保持 `THROW_SYNC_RESET` 不变，并且每次都会trigger reset event footnote:[这里假设
没有异步reset]。


==== add_static_event

[[api::sc_process_b::add_static_event]]
`add_static_event` 将一个事件加入到 `m_static_events` 列表中，同时也将
本process cast为合适的派生类，调用事件的
<<api::sc_event::add_static, `add_static`>>成员函数，设置到事件中：

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_process_b::add_static_event"
//
// This method adds an event to the list of static events, and sets the
// event up to call back this process when it fires.
//------------------------------------------------------------------------------
void sc_process_b::add_static_event( const sc_event& e )
{
    sc_method_handle method_h; // This process as a method.
    sc_thread_handle thread_h; // This process as a thread.


    // CHECK TO SEE IF WE ARE ALREADY REGISTERED WITH THE EVENT:

    for( int i = m_static_events.size() - 1; i >= 0; -- i ) {
        if( &e == m_static_events[i] ) {
            return;
        }
    }

    // REMEMBER THE EVENT AND THEN REGISTER OUR OBJECT INSTANCE WITH IT:

    m_static_events.push_back( &e );

    switch ( m_process_kind )
    {
      case SC_THREAD_PROC_:
      case SC_CTHREAD_PROC_:
        thread_h = static_cast<sc_thread_handle>( this );
        e.add_static( thread_h );
        break;
      case SC_METHOD_PROC_:
        method_h = static_cast<sc_method_handle>( this );
        e.add_static( method_h );
        break;
      default:
        sc_assert( false );
        break;
    }
}
----

注意，sc_process_b并没有定义与add_static_event相对应的
add_dynamic_event，这是因为static的event是在process 创建的时候指定的。而
dynamic event则是在<<concept::wait, wait>>或者<<concept::next_trigger, next_trigger>>
时候设置的。对于事件，将一个sc_process_b通过add_dynamic列入本事件所关联的动态
事件，也是在wait/next_trigger中**动态**完成的。

==== remove_static_events

[[api::sc_process_b::remove_static_events]]
与add_static_event功能相反的是remove_static_events:

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_process_b::remove_static_events"
//
// This method removes this object instance from the events in its static
// event list.
//------------------------------------------------------------------------------
void
sc_process_b::remove_static_events()
{
    sc_method_handle method_h; // This process as a method.
    sc_thread_handle thread_h; // This process as a thread.

    switch ( m_process_kind )
    {
      case SC_THREAD_PROC_:
      case SC_CTHREAD_PROC_:
        thread_h = static_cast<sc_thread_handle>( this );
        for( int i = m_static_events.size() - 1; i >= 0; -- i ) {
            m_static_events[i]->remove_static( thread_h );
        }
        m_static_events.resize(0);
        break;
      case SC_METHOD_PROC_:
        method_h = static_cast<sc_method_handle>( this );
        for( int i = m_static_events.size() - 1; i >= 0; -- i ) {
            m_static_events[i]->remove_static( method_h );
        }
        m_static_events.resize(0);
        break;
      default: // Some other type, it needs to clean up itself.
        // std::cout << "Check " << __FILE__ << ":" << __LINE__ << std::endl;
        break;
    }
}
----

这里的过程和 `add_static_event` 相反。对于每一个 `m_static_events`
的事件，调用其 <<api::sc_event::remove_static, `remove_static`>> 将本process handle从sc_event的
static process列表中移除。最后将 `m_static_events` 清零。

一般来说，很少需要将process的static events列表清除，因为在process的生命周期中，process
都需要依赖这些静态事件的发生来被调度。只有当process的生命周期显式地被要求结束（在disconnect_process中），才需要调用remove_static_events。

==== remove_dynamic_events

[[api::sc_process_b::remove_dynamic_events]]
在process生命周期显式杯结束的时候，还需要清除动态敏感事件，因此有一个 `remove_dynamic_events`
的成员函数：

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_process_b::remove_dynamic_events"
//
// This method removes this object instance from the events in its dynamic
// event lists.
//
// Arguments:
//     skip_timeout = skip cleaning up the timeout event, it will be done
//                    by sc_event_notify().
//------------------------------------------------------------------------------
void
sc_process_b::remove_dynamic_events( bool skip_timeout )
{
    sc_method_handle  method_h;   // This process as a method.
    sc_thread_handle  thread_h;   // This process as a thread.

    m_trigger_type = STATIC;
    switch ( m_process_kind )
    {
      case SC_THREAD_PROC_:
      case SC_CTHREAD_PROC_:
        thread_h = static_cast<sc_thread_handle>(this);
	if ( thread_h->m_timeout_event_p && !skip_timeout ) {
	    thread_h->m_timeout_event_p->remove_dynamic(thread_h);
	    thread_h->m_timeout_event_p->cancel();
	}
        if ( m_event_p )
        {
            m_event_p->remove_dynamic( thread_h );
            m_event_p = 0;
        }
        if ( m_event_list_p )
        {
            m_event_list_p->remove_dynamic( thread_h, 0 );
            m_event_list_p->auto_delete();
	    m_event_list_p = 0;
        }
        break;
      case SC_METHOD_PROC_:
        method_h = static_cast<sc_method_handle>(this);
	if ( method_h->m_timeout_event_p && !skip_timeout ) {
	    method_h->m_timeout_event_p->remove_dynamic(method_h);
	    method_h->m_timeout_event_p->cancel();
	}
        if ( m_event_p )
        {
            m_event_p->remove_dynamic( method_h );
            m_event_p = 0;
        }
        if ( m_event_list_p )
        {
            m_event_list_p->remove_dynamic( method_h, 0 );
            m_event_list_p->auto_delete();
	    m_event_list_p = 0;
        }
        break;
      default: // Some other type, it needs to clean up itself.
        // std::cout << "Check " << __FILE__ << ":" << __LINE__ << std::endl;
        break;
    }
}
----

对于sc_process_b而言，静态事件都保存在 `m_static_events` 列表中，然而动态事件：

* 单一的动态事件，指针保存在 m_event_p 中
* 组合的动态事件列表，指针保存在 m_event_list_p 中
* 定时的内部创建的事件（wait/next_trigger中带延时功能），保存在 m_timed_event_p 中

因此在 `remove_dynamic_events` 的时候，需要一个一个检查是否有效，并移除。

需要注意的是， `remove_dynamic_events` 可以接受一个布尔参数，表明是否跳过timeout event
的移除。默认情况下会将所有动态事件移除，如果设置跳过timed event，则移除除了timeout
event以外所有的动态事件（其实只有单一事件和多个事件列表）。只有在trigger_dynamic的时候，
process被disable，才会传入一个参数要求保留timeout event，但这么设计的原因目前未知。

==== child object management

sc_process_b中有三个用于管理子对象的函数：

* add_child_object
* remove_child_object
* get_child_objects 

这3个都调用基类sc_object的相应函数，来管理process的子对象，sc_process_b在其中
增加了引用计数 `m_references_n` 管理部分的工作：

.src/sysc/kernel/sc_process.h
[source,cpp]
----
inline void
sc_process_b::add_child_object( sc_object* object_p )
{
    sc_object::add_child_object( object_p );
    reference_increment();
}

inline bool
sc_process_b::remove_child_object( sc_object* object_p )
{
    if ( sc_object::remove_child_object( object_p ) ) {
	    reference_decrement();
            return true;
    }
    else
    {
        return false;
    }
}

inline const ::std::vector<sc_object*>&
sc_process_b::get_child_objects() const
{
    return m_child_objects;
}
----

==== disconnect_process
[[api::sc_process_b::disconnect_process]]

disconnect_process 用以在kill_process中，从其他与之关联的数据结构，如monitor, event等，
移除本process:

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
void sc_process_b::disconnect_process()
{
    int               mon_n;      // monitor queue size.
    sc_thread_handle  thread_h;   // This process as a thread.

    // IF THIS OBJECT IS PINING FOR THE FJORDS WE ARE DONE:

    if ( m_state & ps_bit_zombie ) return;

    // IF THIS IS A THREAD SIGNAL ANY MONITORS WAITING FOR IT TO EXIT:

    switch ( m_process_kind )
    {
      case SC_THREAD_PROC_:
      case SC_CTHREAD_PROC_:
        thread_h = static_cast<sc_thread_handle>(this);
        mon_n = thread_h->m_monitor_q.size();
        if ( mon_n )
        {
            for ( int mon_i = 0; mon_i < mon_n; mon_i++ )
            {
                thread_h->m_monitor_q[mon_i]->signal( thread_h,
			      sc_process_monitor::spm_exit);
            }
        }
        break;
      default:
        break;
    }

    // REMOVE EVENT WAITS, AND REMOVE THE PROCESS FROM ITS SC_RESET:

    remove_dynamic_events();
    remove_static_events();

    for ( std::vector<sc_reset*>::size_type rst_i = 0; rst_i < m_resets.size(); rst_i++ )
    {
        m_resets[rst_i]->remove_process( this );
    }
    m_resets.resize(0);


    // FIRE THE TERMINATION EVENT, MARK AS TERMINATED, AND DECREMENT THE COUNT:
    //
    // (1) We wait to set the process kind until after doing the removals
    //     above.
    // (2) Decrementing the reference count will result in actual object
    //     deletion if we hit zero.

    m_state = ps_bit_zombie;
    if ( m_term_event_p ) m_term_event_p->notify();
    reference_decrement();
}
----

disconnect process主要的动作有：

* 对于thread，调度monitor的signal接口函数，通知线程退出
* 使用<<api::sc_process_b::remove_static_events, remove_static_events>>和
<<api::sc_process_b::remove_dynamic_events, remove_dynamic_events>>断开与sc_event
之间的连接
* 从每个reset中移除本process，并清除本process保存的reset信息
* 将状态m_state置为zombie状态
* 如果有terminated event，就notify terminated event
* 减少引用计数器

调用了disconnect_process的process进入zombie状态，m_state被标记为ps_zombie
bit位。对一个zombie的process调用disconnect_process会直接返回。

==== delete_process
[[api::sc_process_b::delete_process]]

delete_process可以将本process所有分配的资源释放掉：

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
void sc_process_b::delete_process()
{
    sc_assert( m_references_n == 0 );

    // Immediate deletion:

    if ( NULL == sc_get_current_process_b() )
    {
        delete this; <1>
    }

    // Deferred deletion: note we set the reference count to one  for the call
    // to reference_decrement that occurs in sc_simcontext::crunch().

    else
    {
        m_references_n = 1;
        detach();
        simcontext()->mark_to_collect_process( this );
    }
}
----
<1> 之所以能够delete，是因为所有的process都是new出来的

注意只有引用计数为0的时候，才能够调用delete_process。如果删除的请求来源不是来自一个process，那么
立即删除，否则就将这个process标记为待回收的process。

待回收的process在每次<<concept::crunch, crunch>>的最后，do_collect_processes
会调用每一个待回收的process的reference_decrement()
[[api::sc_simcontext::do_collect_processes]]

.src/sysc/kernel/sc_simcontext.cpp
[source,cpp]
----
void sc_simcontext::do_collect_processes()
{
    while( ! m_collectable->empty() )
    {
        sc_process_b* del_p = m_collectable->front();
        m_collectable->pop_front();
        del_p->reference_decrement();
    }
}
----

[[api::sc_process_b::reference_decrement]]
而在sc_process_b的reference_decrement中，将引用计数减去一，如果引用计数为0，则
再次调用delete_process:

.src/sysc/kernel/sc_process.h
[source,cpp]
----
inline void sc_process_b::reference_decrement()
{
    m_references_n--;
    if ( m_references_n == 0 ) delete_process();
}
----

在simc的do_collect_processes之前，会调用reset_curr_proc，将当前的process
信息重置：

[source,cpp]
----
    this->reset_curr_proc();
    do_collect_processes();
----

所以这一次，sc_get_current_proc_b返回空指针，delete_process就可以正常 `delete this` 了。

==== reset_process
[[api::sc_process_b::reset_process]]

不同于disconnect_process或者delete_process, reset_process的处理相对来说比较复杂，因为
reset_process需要reset之后，process还能够正常运行。对于Method线程而言这比较容易做到，因为每个
Method执行的时候都是完整执行函数体的。但是对于Thread/CThread线程而言，reset就没那么简单了。

关于reset_process的内容，请参考<<concept::process::reset, reset机制>>的
<<api::sc_process_b::reset_process::impl, reset执行流程>>部分。

==== reset_event
[[api::sc_process_b::reset_event]]

sc_process_b的 `reset_event` 返回一个与本process相关联的reset event的引用。如果
成员变量 `m_reset_event_p` 为空，就新建一个kernel event：

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
sc_event& sc_process_b::reset_event()
{
    if ( !m_reset_event_p )
    {
        m_reset_event_p = new sc_event( sc_event::kernel_event, "reset_event" );
    }
    return *m_reset_event_p;
}
----

这个sc_event可以用来用来做静态或者动态的调度事件使用，也可以用在其他event能够使用的场合。

== sc_process_handle
[[data::sc_process_handle]]

=== 成员变量

sc_process_handle内部只保存了一个指向基类sc_process_b指针的成员变量 `m_target_p`:

.src/sysc/kernel/sc_process_handle.h
[source,cpp]
----
  protected:
    sc_process_b* m_target_p;   // Target for this object instance.

  protected:
    static std::vector<sc_event*>  empty_event_vector;  // If m_target_p == 0.
    static std::vector<sc_object*> empty_object_vector; // If m_target_p == 0.
    static sc_event                non_event;           // If m_target_p == 0.
----

另外三个静态成员变量，是为了在 `m_target_p` 为空的情况下，某些需要返回
对象引用的成员函数能够正确返回引用而添加的。

== sc_thread_process
[[data::sc_thread_process]]

=== 成员变量

除了基类 `sc_process_b` 的成员变量以外，sc_thread_process为支持协程
能力，增加了如下几个成员变量：

.src/sysc/kernel/sc_thread_process.h
[source,cpp]
----
  protected:
    sc_cor*                          m_cor_p;        // Thread's coroutine.
    std::vector<sc_process_monitor*> m_monitor_q;    // Thread monitors.
    std::size_t                      m_stack_size;   // Thread stack size.
    int                              m_wait_cycle_n; // # of waits to be done.
----

`m_cor_p` 以及 `m_stack_size` 是为支持协程而添加的。
`m_cor_p` 就是代表本thread的协程参数，用以启动、挂起和恢复协程时使用。
`m_stack_size` 则是有栈协程的协程栈的大小。

`m_monitor_q` 是thread monitor，后续我们再介绍。

最后一个m_wait_cycle_n，主要用在
<<api::sc_thread_process::wait_cycles, wait_cycles>>成员函数中，用以支持设定
特定等待时钟周期的场景。

=== 重要成员函数

==== throw_reset
[[api::sc_thread_process::throw_reset]]

== sc_method_process
[[data::sc_method_process]]

=== 成员变量

sc_method_process在基类 `sc_process_b` 的基础上增加了如下几个成员变量：

.src/sysc/kernel/sc_thread_process.h
[source,cpp]
----
    sc_cor*                          m_cor;        // Thread's coroutine.
    std::size_t                      m_stack_size; // Thread stack size.
    std::vector<sc_process_monitor*> m_monitor_q;  // Thread monitors.
----

然而这三个成员变量在sc_method_process中并没有得到使用。

=== 重要成员函数

==== throw_reset
[[api::sc_method_process::throw_reset]]

== sc_cthread_process
[[data::sc_cthread_process]]

=== 成员变量

sc_cthread_process在基类 `sc_thread_process` 基础上，没有新增加其他的
成员变量。

== reset机制

Process中有一套非常复杂的reset机制，来仿真模拟实际的RTL reset行为。

=== reset设置流程

sc_module提供了如下几组API，用来实现process的reset逻辑指定：

[[api::sc_module::reset_signal_is]]
[[api::sc_module::async_reset_signal_is]]
.src/sysc/kernel/sc_module.h
[source,cpp]
----
    // set reset sensitivity for SC_xTHREADs
    void async_reset_signal_is( const sc_in<bool>& port, bool level );
    void async_reset_signal_is( const sc_inout<bool>& port, bool level );
    void async_reset_signal_is( const sc_out<bool>& port, bool level );
    void async_reset_signal_is( const sc_signal_in_if<bool>& iface, bool level);
    void reset_signal_is( const sc_in<bool>& port, bool level );
    void reset_signal_is( const sc_inout<bool>& port, bool level );
    void reset_signal_is( const sc_out<bool>& port, bool level );
    void reset_signal_is( const sc_signal_in_if<bool>& iface, bool level );
----

这些API实际调用的是 `sc_reset` 数据结构的 `reset_signal_is` 函数。例如：

.src/sysc/kernel/sc_module.cpp
[source,cpp]
----
void
sc_module::reset_signal_is( const sc_in<bool>& port, bool level )
{
	sc_reset::reset_signal_is(false, port, level);
}
----

`reset_signal_is` 是 `sc_reset` 的一组带重载的静态函数，所以这里无需一个sc_reset
的instance，就可以直接调用 `reset_signal_is` 。

[[api::sc_reset::reset_signal_is]]
`reset_signal_is` 具有多种重载形式，这里我们选择最终实现逻辑的一种重载形式来进行分析。
其他几种重载形式如果能拿到interface指针，都会直接调用这个，否则采取类似于
<<api::sc_event_finder, sc_event_finder>>的方式，
构造<<data::sc_reset_finder, sc_reset_finder>>延迟查找
这些interface。

以下是reset_signal_is的实现：

.src/sysc/kernel/sc_reset.cpp
[source,cpp]
----
void sc_reset::reset_signal_is(
    bool async, const sc_signal_in_if<bool>& iface, bool level )
{
    sc_process_b*   process_p;    // process adding reset for.
    sc_reset_target reset_target; // entry to build for the process.
    sc_reset*       reset_p;      // reset object.

    process_p = sc_process_b::last_created_process_base(); <1>
    sc_assert( process_p );
    process_p->m_has_reset_signal = true;
    switch ( process_p->proc_kind() )
    {
      case SC_METHOD_PROC_:
      case SC_CTHREAD_PROC_:
      case SC_THREAD_PROC_:
	reset_p = iface.is_reset(); <2>
	process_p->m_resets.push_back(reset_p);
        reset_target.m_async = async;
	reset_target.m_level = level;
	reset_target.m_process_p = process_p;
	reset_p->m_targets.push_back(reset_target);
	if ( iface.read() == level ) process_p->initially_in_reset( async );
        break;
      default:
        SC_REPORT_ERROR(SC_ID_UNKNOWN_PROCESS_TYPE_, process_p->name());
        break;
    }
}
----
<1> process handle是直接获取的，类似于sensitive中获取的最后一个创建的process handle的方式
<2> is_reset是sc_signal_in_if<T>的接口函数，默认返回一个空指针

process中的 `m_resets` 保存了设置reset的 `sc_reset` 对象指针，而这个reset对象指针里的
`m_targets` 则保存了reset需要的三个信息：

1. reset的同步/异步情况
2. reset的level（低电平reset还是高电平reset）
3. reset的process handle

如果发现当前信号值等于所设置的reset电平值，则调用process的initially_in_reset函数：
[[api::sc_process_b::initially_in_reset]]

.src/sysc/kernel/sc_process.h
[source,cpp]
----
inline void sc_process_b::initially_in_reset( bool async )
{
    if ( async )
        m_active_areset_n++;
    else
        m_active_reset_n++;
}
----

而这里只是简单将reset的counter计数器做自增而已，至于加在哪个上边，取决于是异步reset还是
同步reset。

至此，用作reset的sc_signal和设置这个sc_signal作为reset的process已经建立了关系：

* sc_signal内保存了所有的需要reset的process 的一组三元信息
* process内保存了所有用作reset的sc_reset指针footnote:[从SystemC代码中并没有看到这里保存的m_resets被使用的情况]

=== reset执行流程

在SystemC中，reset大致可以分为两种：

* 异步reset(asynchronous)，这种reset一般是与clock无关的reset信号
* 同步reset(synchronous)，这种reset一般由clock驱动的signal发出来，与时钟同步

[[api::sc_process_handle::sync_reset_on]]
对于一个sc_process_handle，提供了3个API，支持这两种reset机制：

* `reset` 成员函数可以异步reset process
* `sync_reset_off` 和 `sync_reset_on` 可以同步reset process

.src/sysc/kernel/sc_process_handle.h
[source,cpp]
----
inline void sc_process_handle::reset( sc_descendant_inclusion_info descendants )
{
    if ( m_target_p )
        m_target_p->reset_process( sc_process_b::reset_asynchronous,
	                           descendants );
    else
        SC_REPORT_WARNING( SC_ID_EMPTY_PROCESS_HANDLE_, "reset()");
}

inline void sc_process_handle::sync_reset_off(
    sc_descendant_inclusion_info descendants)
{
    if ( m_target_p )
        m_target_p->reset_process( sc_process_b::reset_synchronous_off,
	                           descendants);
    else
        SC_REPORT_WARNING( SC_ID_EMPTY_PROCESS_HANDLE_, "sync_reset_off()");
}

// turn sync_reset on for this object instance's target.

inline void sc_process_handle::sync_reset_on(
    sc_descendant_inclusion_info descendants)
{
    if ( m_target_p )
    {
        m_target_p->reset_process(sc_process_b::reset_synchronous_on,
            descendants);
    }
    else
    {
        SC_REPORT_WARNING( SC_ID_EMPTY_PROCESS_HANDLE_, "sync_reset_on()");
    }
}
----

所以reset/sync_reset_on/sync_reset_off实际调用的都是sc_process_b的reset_process。

[[api::sc_process_b::reset_process::impl]]
以下是sc_process_b的reset_process代码实现：

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_process_b::reset_process"
//
// This inline method changes the reset state of this object instance and
// conditionally its descendants.
//
// Notes:
//   (1) It is called for sync_reset_on() and sync_reset_off(). It is not used
//       for signal sensitive resets, though all reset flow ends up in
//       reset_changed().
//
// Arguments:
//     rt = source of the reset:
//            * reset_asynchronous     - sc_process_handle::reset()
//            * reset_synchronous_off  - sc_process_handle::sync_reset_off()
//            * reset_synchronous_on   - sc_process_handle::sync_reset_on()
//     descendants = indication of how to process descendants.
//------------------------------------------------------------------------------
void sc_process_b::reset_process( reset_type rt,
                                  sc_descendant_inclusion_info descendants )
{

    // PROCESS THIS OBJECT INSTANCE'S DESCENDANTS IF REQUESTED TO:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*> children = get_child_objects();
        int                           child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->reset_process(rt, descendants);
        }
    }

    // PROCESS THIS OBJECT INSTANCE:

    switch (rt)
    {
      // One-shot asynchronous reset: remove dynamic sensitivity and throw:
      //
      // If this is an sc_method only throw if it is active.

      case reset_asynchronous:
	if ( sc_get_status() != SC_RUNNING )
	{
	    report_error(SC_ID_RESET_PROCESS_WHILE_NOT_RUNNING_);
	}
	else
	{
	    remove_dynamic_events();
	    throw_reset(true);
	}
        break;

      // Turn on sticky synchronous reset: use standard reset mechanism.

      case reset_synchronous_on:
	if ( m_sticky_reset == false )
	{
	    m_sticky_reset = true;
	    reset_changed( false, true );
	}
        break;

      // Turn off sticky synchronous reset: use standard reset mechanism.

      default:
	if ( m_sticky_reset == true )
	{
	    m_sticky_reset = false;
	    reset_changed( false, false );
	}
        break;
    }
}
----

最开始的代码用以处理子对象的reset请求。如前所述，reset来源分为异步reset，同步的reset开
和同步的reset关，反映在 `reset_process` 的第一个参数 `rt`, 即reset type上。

如果是异步的reset，首先移除所有动态事件，因为reset一个process需要从头开始执行，所以
这些阻塞的动态事件就没必要了，接下来调度 throw_reset(true)。这里代码会检查异步
reset的时机，保证异步reset发生在simulation运行过程中。

如果是同步的reset，这里使用了变量 `m_sticky_reset` 来辅助做同步reset。m_stick_reset
默认为false，其含义是是否处于同步reset周期内。如果请求打开同步reset，且未处于reset
周期内（m_sticky_reset为false），调用 `reset_changed(false, true)`，并设置 
m_sticky_reset为true，否则无动作。同样，如果请求关闭同步reset，且处于reset
周期内（m_sticky_reset为true），调用 `reset_changed(false, false)`，并设置
m_sticky_reset为false，否则无动作。m_sticky_reset的引入，保证了无论
同步reset持续多长的时钟周期，表现都如同一个reset一样。

[[api::sc_process_b::reset_changed]]
这里的 `reset_changed` 实现如下：

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_process_b::reset_changed"
//
// This method is called when there is a change in the value of the
// signal that was specified via reset_signal_is, or the value of the
// m_sticky_reset field. We get called any time m_sticky_reset changes
// or a signal value changes since, since we may need to throw an exception
// or clear one. Note that this method may be called when there is no
// active process, but rather the main simulator is executing so we must
// check for that case.
//
// Arguments:
//     async    = true if this is an asynchronous reset.
//     asserted = true if reset being asserted, false if being deasserted.
//------------------------------------------------------------------------------
void sc_process_b::reset_changed( bool async, bool asserted )
{

    // Error out on the corner case:

    if ( !sc_allow_process_control_corners && !async &&
         (m_state & ps_bit_suspended) )
    {
	report_error( SC_ID_PROCESS_CONTROL_CORNER_CASE_,
	              "synchronous reset changed on a suspended process" );
    }

    // IF THIS OBJECT IS PUSHING UP DAISIES WE ARE DONE:

    if ( m_state & ps_bit_zombie ) return;

    // Reset is being asserted:

    if ( asserted )
    {
        // if ( m_reset_event_p ) m_reset_event_p->notify();
        if ( async )
	{
	    m_active_areset_n++;
	    if ( sc_is_running() ) throw_reset(true);
	}
	else
	{
	    m_active_reset_n++;
	    if ( sc_is_running() ) throw_reset(false);
	}
    }

    // Reset is being deasserted:

    else
    {
        if ( async )
	{
	    m_active_areset_n--;
	}
	else
	{
	    m_active_reset_n--;
	}
    }

    // Clear the throw type if there are no active resets.

    if ( (m_throw_status == THROW_SYNC_RESET ||
          m_throw_status == THROW_ASYNC_RESET) &&
         m_active_areset_n == 0 && m_active_reset_n == 0 && !m_sticky_reset )
    {
        m_throw_status = THROW_NONE;
    }
}
----

这里最开始是处理一个corner case，即同步reset一个suspended的case。

异步和同步reset，主要是在相关的计数器加减上。另外，如果reset时simulation已经开始，这里
同样会调用 throw_reset()函数。

reset_changed这个函数除了在sc_process_b的reset_process中使用以外，还在sc_reset
的notify_processes中使用：
[[api::sc_reset::notify_processes]]

.src/sysc/kernel/sc_reset.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_reset::notify_processes"
//
// Notify processes that there is a change in the reset signal value.
//------------------------------------------------------------------------------
void sc_reset::notify_processes()
{
    bool                                    active;       // true if reset is active.
    sc_reset_target*                        entry_p;      // reset entry processing.
    std::vector<sc_reset_target>::size_type process_i;    // index of process resetting.
    std::vector<sc_reset_target>::size_type process_n;    // # of processes to reset.
    bool                                    value;        // value of our signal.

    value = m_iface_p->read();
    process_n = m_targets.size();
    for ( process_i = 0; process_i < process_n; process_i++ )
    {
        entry_p = &m_targets[process_i];
	active = ( entry_p->m_level == value );
	entry_p->m_process_p->reset_changed( entry_p->m_async, active );
    }
}
----

这相当于从一个sc_reset中触发所有依赖这个sc_reset的process的reset_changed函数了。

reset流程走到最后，着落点在于 `throw_reset` 这个函数。这是sc_process_b的接口函数，
<<api::sc_thread_process::throw_reset, thread>>和
<<api::sc_method_process::throw_reset, method>>都实现了自己的throw_reset逻辑。

异步的reset请求，每请求一次，就调用一次 `throw_reset(true)`。同步的reset请求，每一对
sync_reset_on和sync_reset_off，在sync_reset_on的时候，调用一次 `throw_reset(false)`。
实际从thread和method的throw_reset逻辑来看，同步的reset请求，throw_reset只是：

* 将 `m_throw_status` 设置为 `THROW_SYNC_RESET`
* 对于thread，清除 `m_wait_cycle_n` 为0

而没有其他的逻辑，这是因为对于同步reset，只需要标记 `m_throw_status` 为 `THROW_SYNC_RESET`
就足够了。

对于Method线程而言，将 `m_throw_status` 置为 `THROW_SYNC_RESET`，意味着在Method下次启动执行
的时候，<<api::sc_process_b::semantics, sc_process_b的semantics>>中会trigger可能的
reset event。但这种trigger reset event的事情，会在同步reset期间，每一次调度的时候都执行
一遍，直到同步reset结束为止。


=== 能够用作reset的类型

默认情况下， `sc_signal_in_if<T>` 的 is_reset 会返回一个空指针，这意味着普通的sc_signal
是无法作为reset的。从逻辑角度考虑这也是符合事实的，只有一根信号的sc_signal才能够作为
reset信号。

在SystemC中，只有 sc_signal<bool> footnote:[这意味着只有sc_signal<bool>才能作为reset信号]才实现了is_reset API返回一个sc_reset对象指针的功能：

.src/sysc/communication/sc_signal.cpp
[source,cpp]
----
template< sc_writer_policy POL >
sc_reset*
sc_signal<bool,POL>::is_reset() const
{
    sc_reset* result_p;
    if ( !m_reset_p ) m_reset_p = new sc_reset( this );
    result_p = m_reset_p;
    return result_p;
}
----

`sc_signal<sc_dt::sc_logic>` 不能作为reset信号，猜测是因为 `sc_logic` 是一个四值逻辑，不符合
作为reset信号的二值逻辑要求。

=== sc_reset_finder
[[data::sc_reset_finder]]


== process状态的迁移变化

在sc_process_b中，有一个记录当前线程状态的位掩码 <<data::sc_process_b::m_state, `m_state`>> 。
sc_process_b可能有如下几种状态：

* disable
* ready to run
* suspend
* zombie
* normal

前四种分别为位的掩码，意味着process可以同时处于前四种状态中的多种。

在使用过程中，应当调用自由函数 `sc_get_current_process_handle` ，获取一个
<<data::sc_process_handle, sc_process_handle>>的对象，然后通过这个对象的
如下成员函数，调度这些管理process状态的部分：

* suspend，调用所保管的process handle的 `suspend_process` 成员函数
* resume，调用所保管的process handle的 `resume_process` 成员函数
* enable，调用所保管的process handle的 `enable_process` 成员函数
* disable，调用所保管的process handle的 `disable_process` 成员函数
* kill，调用所保管的process handle的 `kill_process` 成员函数
* reset，调用所保管的process handle的 `reset_process` 成员函数

IEEE 1666对于SystemC在如下几种process状态切换时的行为，交给实现自行定义：

* 当一个disabled, suspended的process上调用resume()时的行为
* 当一个suspended的process上调用sync_reset_on()和sync_reset_off()时的行为
* 当一个suspended的process上的由reset_signal_is()所指定的signal值发生变化时的行为

Proof of Concept实现在默认情况下，对这三种情况都当做错误处理。此外，在设置
一个变量 `sc_allow_process_control_corners` 为true的时候，实现可以转而采用
一种不报错的方式：

* 如果一个disabled, suspended的process上调用了resume()，则这个process被标记为
不再suspend。如果这么处理后的process是可以调度执行的（没有阻塞在任何事件上），那么这个
process将会被放入runnable列表中
* sync_reset_on()和sync_reset_off()只会将相关的标志位置位或者复位。process是否处于
reset状态，取决于当process得到执行时候，相关标志位的状态。
* 如果一个suspended的process有由reset_signal_is()所制定的reset signal，则这个reset
signal的值只有在这个process下次执行的时候，才会被采样，采样的结果决定process是否reset

[[data::sc_allow_process_control_corners]]
`sc_allow_process_control_corners` 在SystemC中默认值是false:

.src/sysc/kernel/sc_simcontext.h
[source,cpp]
----
bool sc_allow_process_control_corners = false;

// The state transition diagram for the interaction of disable and suspend
// when sc_allow_process_control_corners is true is shown below:
//
// ......................................................................
// .         ENABLED                    .           DISABLED            .
// .                                    .                               .
// .                 +----------+    disable      +----------+          .
// .   +------------>|          |-------.-------->|          |          .
// .   |             | runnable |       .         | runnable |          .
// .   |     +-------|          |<------.---------|          |------+   .
// .   |     |       +----------+     enable      +----------+      |   .
// .   |     |          |    ^          .            |    ^         |   .
// .   |     |  suspend |    | resume   .    suspend |    | resume  |   .
// .   |     |          V    |          .            V    |         |   .
// .   |     |       +----------+    disable      +----------+      |   .
// .   |     |       | suspend  |-------.-------->| suspend  |      |   .
// . t |   r |       |          |       .         |          |      | r .
// . r |   u |       |  ready   |<------.---------|  ready   |      | u .
// . i |   n |       +----------+     enable      +----------+      | n .
// . g |   / |         ^                .                           | / .
// . g |   w |  trigger|                .                           | w .
// . e |   a |         |                .                           | a .
// . r |   i |       +----------+    disable      +----------+      | i .
// .   |   t |       | suspend  |-------.-------->| suspend  |      | t .
// .   |     |       |          |       .         |          |      |   .
// .   |     |       | waiting  |<------.---------| waiting  |      |   .
// .   |     |       +----------+     enable      +----------+      |   .
// .   |     |          |    ^          .            |    ^         |   .
// .   |     |  suspend |    | resume   .    suspend |    | resume  |   .
// .   |     |          V    |          .            V    |         |   .
// .   |     |       +----------+    disable      +----------+      |   .
// .   |     +------>|          |-------.-------->|          |      |   .
// .   |             | waiting  |       .         | waiting  |      |   .
// .   +-------------|          |<------.---------|          |<-----+   .
// .                 +----------+     enable      +----------+          .
// .                                    .                               .
// ......................................................................

----

如果需要支持不出错的处理，可以编译代码的时候将这个更改为true，或者在sc_main()中，第一行
加入：

[source,cpp]
----
sc_core::sc_allow_process_control_corners = true;
----

=== disable and enable
[[concept::process::control::disable_enable]]

sc_process_handle的enable/disable调用，如前所述，调用的其实是内部sc_process_b
的enable_process/disable_process接口函数：

.src/sysc/kernel/sc_process_handle.h
[source,cpp]
----
// enable this object instance's target.

inline void sc_process_handle::enable(sc_descendant_inclusion_info descendants)
{
    if ( m_target_p )
        m_target_p->enable_process(descendants);
    else
        SC_REPORT_WARNING( SC_ID_EMPTY_PROCESS_HANDLE_, "enable()");
}

// disable this object instance's target.

inline void sc_process_handle::disable(sc_descendant_inclusion_info descendants)
{
    if ( m_target_p )
        m_target_p->disable_process(descendants);
    else
        SC_REPORT_WARNING( SC_ID_EMPTY_PROCESS_HANDLE_, "disable()");
}
----

enable_process/disable_process是sc_process_b的接口函数，是纯虚函数。对于Thread和Method
有着不同的实现。

==== Thread/CThread

[[concept::process::control::disable::thread]]
首先我们来看Thread/CThread是如何实现disable的：

.src/sysc/kernel/sc_thread_process.cpp
[source,cpp]
----
void sc_thread_process::disable_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE DISABLE REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->disable_process(descendants);
        }
    }

    // DON'T ALLOW CORNER CASE BY DEFAULT:

    if ( !sc_allow_process_control_corners )
    {
        switch( m_trigger_type )
        {
          case AND_LIST_TIMEOUT:
          case EVENT_TIMEOUT:
          case OR_LIST_TIMEOUT:
          case TIMEOUT:
            report_error(SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                   "attempt to disable a thread with timeout wait");
            // may continue, if suppressed
            break;
          default:
            break;
        }
    }

    // DISABLE OUR OBJECT INSTANCE:

    m_state = m_state | ps_bit_disabled;

    // IF THIS CALL IS BEFORE THE SIMULATION DON'T RUN THE THREAD:

    if ( !sc_is_running() )
    {
	m_state = m_state | ps_bit_ready_to_run;
        simcontext()->remove_runnable_thread(this);
    }
}
----

所有的这些状态转移函数，都会带一个 `descendants` 参数，表示是否需要将动作
传播给子对象。这部分的内容基本就是检索所有的子对象，并使用dynamic_cast来
检查这鞋子对象是否是process对象，如果是，就将请求转发过去。后续类似这部分的内容
我们就不再多解析了。

默认情况下，disable一个process的时候回检查process的状态。如果process设置了
超时状态（延时执行），那么就报错。如果我们将 `sc_allow_process_control_corners`
置为true，就会跳过这一步的检查，允许在设置有超时（延时）状态的process上执行disable动作。

接下来，
<<data::sc_process_b::m_state, m_state>>的ps_bit_disabled位被置位。如果disable process
发生在仿真开始之前，同时会把m_state的ps_bit_ready_to_run置位，从simc中准备runnable
的列表中移除这个process。如果disalbe process发生在仿真过程中，就无需其他动作，只需要继续执行下去。
如果disable_process的请求来自线程本身，disable_process并不会立即生效，而是会继续执行，直到
此线程被阻塞朱，然后让渡出CPU执行权为止。

这么设计的原因还暂时不清楚。

[[concept::process::control::enable::thread]]
Thread/CThrad的enable_process实现则是：

.src/sysc/kernel/sc_thread_process.cpp
[source,cpp]
----
void sc_thread_process::enable_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE ENABLE REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->enable_process(descendants);
        }
    }

    // ENABLE THIS OBJECT INSTANCE:
    //
    // If it was disabled and ready to run then put it on the run queue.

    m_state = m_state & ~ps_bit_disabled;
    if ( m_state == ps_bit_ready_to_run && sc_allow_process_control_corners )
    {
        m_state = ps_normal;
	if ( next_runnable() == 0 )
	    simcontext()->push_runnable_thread(this);
    }
}
----

首先是将m_state的ps_bit_disabled位复位。接下来如果状态是ps_bit_ready_to_run，并且
设置了 sc_allow_process_control_corners为true的话，将m_state置为ps_normal。如果
next_runnable()为空，即这个process不在runnable列表中，就将这个thread加入到runnable
列表中去。

由此可见：

* 如果仿真前disable process，在仿真过程中enable process，process会被放入runnable列表中执行，在下一个delta cycle立马开始执行。如果不这样做，这个process只能等到与之关联的静态敏感事件发生才会被
放入调度列表中得到执行了，因为process disable发生在仿真之前，process根本没得到执行，无法动态
等待事件。
* 如果仿真中disable process，之后再enable process，除非之前process已经执行且处于ready to run状态，否则enable_process不会将这个process放入列表中执行。仿真已经开始，说明这个process handle要么可能被静态敏感事件注册为关联线程，要么动态等待在一个事件上，都会有机会被调度重新放入可执行列表的

==== Method

[[concept::process::control::disable::method]]
Method的disable_process实现如下：

.src/sysc/kernel/sc_method_process.cpp
[source,cpp]
----
void sc_method_process::disable_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE SUSPEND REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->disable_process(descendants);
        }
    }

    // DON'T ALLOW CORNER CASE BY DEFAULT:

    if ( !sc_allow_process_control_corners )
    {
        switch( m_trigger_type )
        {
          case AND_LIST_TIMEOUT:
          case EVENT_TIMEOUT:
          case OR_LIST_TIMEOUT:
          case TIMEOUT:
            report_error( SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                          "attempt to disable a method with timeout wait" );
            // may continue, if suppressed
            break;
          default:
            break;
        }
    }

    // DISABLE OUR OBJECT INSTANCE:

    m_state = m_state | ps_bit_disabled;

    // IF THIS CALL IS BEFORE THE SIMULATION DON'T RUN THE METHOD:

    if ( !sc_is_running() )
    {
        sc_get_curr_simcontext()->remove_runnable_method(this);
    }
}
----

Method的disable process处理基本和Thread的差不多，最大的区别在于，如果disable
发生在仿真开始之前，没有将状态位ready_to_run置位的。
这么做的原因还不是很清楚。

[[concept::process::control::enable::method]]
Method的enable_process实现则是：

.src/sysc/kernel/sc_method_process.cpp
[source,cpp]
----
void sc_method_process::enable_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE RESUME REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->enable_process(descendants);
        }
    }

    // ENABLE THIS OBJECT INSTANCE:
    //
    // If it was disabled and ready to run then put it on the run queue.

    m_state = m_state & ~ps_bit_disabled;
    if ( m_state == ps_bit_ready_to_run )
    {
        m_state = ps_normal;
	if ( next_runnable() == 0 )
	    simcontext()->push_runnable_method(this);
    }
}
----

这里的处理基本和Thread一致，除了检查状态时候，无须sc_allow_process_control_corners
为true。我个人猜测，这应该是因为Method每次都会完整执行一遍，不像Thread那样存在死循环，所以
disable之后，再enable，调度执行即可，不会是一个corner case.

=== disable-enable例子分析

现在我们有一个clock period为100ns的sc_clock clock，并且有如下代码：

[source,cpp]
----
void calling()
{
  wait(20, SC_NS);
  t.disable(); // @20 ns
  wait(30, SC_NS);
  t.enable() // @50 ns

  wait(110, SC_NS);
  t.disable(); // @160 ns

  wait(200, SC_NS);
  t.endable(); // @360 ns
}

void target()
{
  while(1)
  {
      wait();
      cout << sc_time_stamp(); // 100 400 500
  }
}
----

target线程设置静态敏感事件为 `sensitive << clock.pos();`。 t是target线程的
sc_process_handle。

在第一个时钟上升沿，也就是100ns时，target处于enable状态，因此会正确输出100。接下来200ns
和300ns的时钟上升沿，target都处于disable状态。clock的posedge事件调用target的
<<api::sc_thread_process::trigger_static, trigger_static>>
成员函数，在这个函数里，有何如下代码(以thread的trigger_static为例，method中
有一样的处理代码)：

[source,cpp]
----
    // No need to try queueing this thread if one of the following is true:
    //    (a) it is disabled
    //    (b) it is already queued for execution
    //    (c) it is waiting on a dynamic event
    //    (d) its wait count is not satisfied and it is not currently in reset

    if ( (m_state & ps_bit_disabled) || is_runnable() ||
          m_trigger_type != STATIC )
        return;
----

可以看到如果状态中有disable状态，那么trigger_static是不生效的，这里会直接返回。

直到400ns的上升沿事件发生，target才处于enable状态，target才会调度执行，从上次
执行时被阻塞的地方恢复执行。

如果动态阻塞在一个事件，这个事件在process disable状态发生的话，调用的是process
的
<<sc_process_b::trigger_dynamic, trigger_dynamic>>，这里有如下代码(以thread
为例，method中有一样的处理代码）：

[source,cpp]
----
    // If a process is disabled then we ignore any events, leaving them enabled:
    //
    // But if this is a time out event we need to remove both it and the
    // event that was being waited for.

    if ( m_state & ps_bit_disabled )
    {
        if ( e == m_timeout_event_p )
	{
	    remove_dynamic_events( true ); <1>
	    return true;
	}
	else
	{
	    return false;
	}
    }
----
<1> 保留timed event对象，参见<<api::sc_process_b::remove_dynamic_events, remove_dynamic_events>>部分

如果动态trigger这个disabled process的事件是个timed事件，那么disabled状态的
线程认为这个事件已经被accpet，需要清除掉这个事件，同时返回true。这个返回值用以
向事件表明是否线程被成功调度。这里可以看到，disabled process向外界报告自己被
重新调度，然而却没有放入runnable列表。

回到最初的那个例子，如果那个例子中target没有设置静态敏感事件，而是依赖动态敏感
事件的话：

[source,cpp]
----
void target()
{
  while(1)
  {
      wait(100, SC_NS);
      cout << sc_time_stamp(); // 100 360, 460
  }
}
----

那么在100ns时候输出100后，200ns 时候timed event发生，这里不会恢复执行，只会将200ns
的timed event移除。这样带来的后果是，target线程在之后永远不会被调度执行！因为200ns
的timed event被移除，但target没有恢复执行以创建下一个300ns的timed event，这个
target奖没有任何event能够唤醒，哪怕之后被enable了同样如此。这是使用disable-enable
时候应当注意的一点：一个使用disable-enable控制的线程，应当有静态敏感事件，以协助在enable
线程之后，线程可以继续调度执行。
在<<use::process::control::prepare_to_simulate, prepare_to_simulate中的状态判断>>
部分，我们也可能看到simc在初始的时候，是不允许disable状态的线程没有静态敏感事件的。


线程在disable状态，无法响应任何发生的事件。这种特性可以用来模拟clock-gating行为。disable-enable
机制一般适用于clock驱动的process，这些process天然带有clock的敏感沿作为静态事件。


=== suspend and resume
[[concept::process::control::suspend_resume]]

suspend操作会挂起一个线程，而resume操作则会继续此线程的执行。这里的suspend/resume
指的是从用户方显式地要求挂起和唤醒线程，而不是SystemC内部在线程切换的时候的线程挂起
和唤醒动作。

sc_process_handle的suspend和resume都转发给了下层的process的suspend_process()
和resume_process():

.src/sysc/kernel/sc_process_handle.h
[source,cpp]
----
// resume this object instance's target.

inline void sc_process_handle::resume(sc_descendant_inclusion_info descendants)
{
    if ( m_target_p )
        m_target_p->resume_process(descendants);
    else
        SC_REPORT_WARNING( SC_ID_EMPTY_PROCESS_HANDLE_, "resume()");
}

// suspend this object instance's target.

inline void sc_process_handle::suspend(sc_descendant_inclusion_info descendants)
{
    if ( m_target_p )
        m_target_p->suspend_process(descendants);
    else
        SC_REPORT_WARNING( SC_ID_EMPTY_PROCESS_HANDLE_, "suspend()");
}
----

Method和Thread/CThread有着不同的suspend/resume动作。

==== Thread/CThread

以下是Thread/CThread的suspend_process的代码：
[[concept::process::control::suspend::thread]]

.src/sysc/kernel/sc_thread_process.cpp
[source,cpp]
----
void sc_thread_process::suspend_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE SUSPEND REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->suspend_process(descendants);
        }
    }

    // CORNER CASE CHECKS, THE FOLLOWING ARE ERRORS:
    //   (a) if this thread has a reset_signal_is specification
    //   (b) if this thread is in synchronous reset

    if ( !sc_allow_process_control_corners && m_has_reset_signal )
    {
        report_error(SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                     "attempt to suspend a thread that has a reset signal");
        // may continue, if suppressed
    }
    else if ( !sc_allow_process_control_corners && m_sticky_reset )
    {
        report_error(SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                     "attempt to suspend a thread in synchronous reset");
        // may continue, if suppressed
    }

    // SUSPEND OUR OBJECT INSTANCE:
    //
    // (1) If we are on the runnable queue then set suspended and ready_to_run,
    //     and remove ourselves from the run queue.
    // (2) If this is a self-suspension then a resume should cause immediate
    //     scheduling of the process, and we need to call suspend_me() here.

    m_state = m_state | ps_bit_suspended;
    if ( next_runnable() != 0 )
    {
	m_state = m_state | ps_bit_ready_to_run;
	simcontext()->remove_runnable_thread( this );
    }
    if ( sc_get_current_process_b() == dynamic_cast<sc_process_b*>(this)  )
    {
	m_state = m_state | ps_bit_ready_to_run;
	suspend_me();
    }
}
----

中间检查了suspend的时候，是否有reset信号。如果有，并且sc_allow_process_control_corners
是false，就报错，否则就跳过检查。

主要的动作是把m_state的ps_bit_suspended置位。如果 `next_runnable()` 非空，说明当前
的process在runnable列表中，这种情况下需要将其标记为ready to run(因为已经要准备run了)
并且从simc的runnable列表中移除此线程。

如果是suspend请求是来自线程自身，即当suspend_process
调用的时候当前线程正在执行， 同样标记ready to run，并且调用suspend_me让渡出执行权。
这样的suspend表现的类似于一个wait()，调用后从不返回，直到线程被外部唤醒的时候才返回。

[[concept::process::control::resume::thread]]
resume_process的操作如下：

.src/sysc/kernel/sc_thread_process.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_thread_process::resume_process"
//
// This method resumes the execution of this process, and if requested, its
// descendants. If the process was suspended and has a resumption pending it
// will be dispatched in the next delta cycle. Otherwise the state will be
// adjusted to indicate it is no longer suspended, but no immediate execution
// will occur.
//------------------------------------------------------------------------------
void sc_thread_process::resume_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE RESUME REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->resume_process(descendants);
        }
    }

    // BY DEFAULT THE CORNER CASE IS AN ERROR:

    if ( !sc_allow_process_control_corners && (m_state & ps_bit_disabled) &&
         (m_state & ps_bit_suspended) )
    {
        m_state = m_state & ~ps_bit_suspended;
        report_error(SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                     "call to resume() on a disabled suspended thread");
        // may continue, if suppressed
    }

    // CLEAR THE SUSPENDED BIT:

    m_state = m_state & ~ps_bit_suspended;

    // RESUME OBJECT INSTANCE IF IT IS READY TO RUN:

    if ( m_state & ps_bit_ready_to_run )
    {
	m_state = m_state & ~ps_bit_ready_to_run;
	if ( next_runnable() == 0 )
	    simcontext()->push_runnable_thread(this);
	remove_dynamic_events();  // order important.
    }
}
----

如前所述，resume一个suspended，但是disabled的process是implementation defined行为，这里
用sc_allow_process_control_corners变量控制行为：如果这个变量为true，跳过检查，否则报错。

主要工作是清除ps_bit_suspended位。如果清除之后，m_state显示ready to run，说明线程在被挂起
的时候处于可运行状态（要么是在runnable列表中，要么就是正在运行）。此时清除掉ready to run
标志，同时向本线程放入runnable列表中，这样在下一个delta cycle本线程就会调度执行。线程
可以被执行，说明已经满足调度条件，所以这里可以移除所有动态的events。

所以一个自我suspended的thread，在resume的时候，会立即开始执行（实际上是从下一个delta cycle
开始执行），而不会等待阻塞事件发生（因为实际上并没有被事件阻塞）。一个满足调度条件的thread，再被
suspended之后不会执行，直到resume的时候才会被放入调度队列，重新开始执行。

对于Thread线程而言，suspend的地方可以是上次被调度出去的地方（某个wait），也可以是
自我suspend时候的 `suspend_me` 地方。当resume这个线程的时候，在下一个delta cycle，
线程会从上次被打断的地方恢复执行。对于自我suspend的情况，这相当于 suspend_process函数
中的suspend_me返回了。

==== Method

Method的suspend_process实现如下：
[[concept::process::control::suspend::method]]

.src/sysc/kernel/sc_method_process.cpp
[source,cpp]
----
void sc_method_process::suspend_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE SUSPEND REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->suspend_process(descendants);
        }
    }

    // CORNER CASE CHECKS, THE FOLLOWING ARE ERRORS:
    //   (a) if this method has a reset_signal_is specification
    //   (b) if this method is in synchronous reset

    if ( !sc_allow_process_control_corners && m_has_reset_signal )
    {
        report_error(SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                     "attempt to suspend a method that has a reset signal");
        // may continue, if suppressed
    }
    else if ( !sc_allow_process_control_corners && m_sticky_reset )
    {
        report_error(SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                     "attempt to suspend a method in synchronous reset");
        // may continue, if suppressed
    }

    // SUSPEND OUR OBJECT INSTANCE:
    //
    // (1) If we are on the runnable queue then set suspended and ready_to_run,
    //     and remove ourselves from the run queue.
    // (2) If this is a self-suspension then a resume should cause immediate
    //     scheduling of the process.

    m_state = m_state | ps_bit_suspended;
    if ( next_runnable() != 0 )
    {
	m_state = m_state | ps_bit_ready_to_run;
	simcontext()->remove_runnable_method( this );
    }
    if ( sc_get_current_process_b() == dynamic_cast<sc_process_b*>(this)  )
    {
	m_state = m_state | ps_bit_ready_to_run;
    }
}
----

可以看出，Method的suspend_process处理过程和tHREAD基本是一模一样的。
不同之处在于，Method没有suspend_me的概念，所以如果自我suspend的case, suspend_process
并不会立即阻塞此线程，而是标记为ready_to_run之后，立即返回。这意味着，如果在一个method
process中，我们调用了这个线程的suspend_process，线程不会阻塞，还是会继续执行下去。

[[concept::process::control::resume::method]]
Method的resume_process执行如下：

.src/sysc/kernel/sc_method_process.cpp
[source,cpp]
----

//------------------------------------------------------------------------------
//"sc_method_process::resume_process"
//
// This method resumes the execution of this process, and if requested, its
// descendants. If the process was suspended and has a resumption pending it
// will be dispatched in the next delta cycle. Otherwise the state will be
// adjusted to indicate it is no longer suspended, but no immediate execution
// will occur.
//------------------------------------------------------------------------------
void sc_method_process::resume_process(
    sc_descendant_inclusion_info descendants )
{

    // IF NEEDED PROPOGATE THE RESUME REQUEST THROUGH OUR DESCENDANTS:

    if ( descendants == SC_INCLUDE_DESCENDANTS )
    {
        const std::vector<sc_object*>& children = get_child_objects();
        int                            child_n  = children.size();

        for ( int child_i = 0; child_i < child_n; child_i++ )
        {
            sc_process_b* child_p = dynamic_cast<sc_process_b*>(children[child_i]);
            if ( child_p ) child_p->resume_process(descendants);
        }
    }


    // BY DEFAULT THE CORNER CASE IS AN ERROR:

    if ( !sc_allow_process_control_corners && (m_state & ps_bit_disabled) &&
         (m_state & ps_bit_suspended) )
    {
        m_state = m_state & ~ps_bit_suspended;
        report_error( SC_ID_PROCESS_CONTROL_CORNER_CASE_,
                      "call to resume() on a disabled suspended method" );
        // may continue, if suppressed
    }

    // CLEAR THE SUSPENDED BIT:

    m_state = m_state & ~ps_bit_suspended;

    // RESUME OBJECT INSTANCE:
    //
    // If this is not a self-resume and the method is ready to run then
    // put it on the runnable queue.

    if ( m_state & ps_bit_ready_to_run )
    {
	m_state = m_state & ~ps_bit_ready_to_run;
	if ( next_runnable() == 0 &&
	   ( sc_get_current_process_b() != dynamic_cast<sc_process_b*>(this) ) )
        {
	    simcontext()->push_runnable_method(this);
	    remove_dynamic_events();
	}
    }
}
----

resume一个Method线程的动作和resume一个Thread线程的动作是一模一样的。概念上的区别在于，resume
一个Method线程，这个线程会从头开始执行，而不像Thread线程那样，从上次suspend的地方开始执行。

=== suspend-resume例子分析

例如，我们有calling和target两个Thread，其中 `t` 是target的sc_process_handle:

[source,cpp]
----
void calling()
{
  wait(20, SC_NS);
  t.suspend(); // @20 ns
  wait(30, SC_NS);
  t.resume() // @50 ns

  wait(110, SC_NS);
  t.suspend(); // @160 ns

  wait(200, SC_NS);
  t.resume(); // @360 ns
}

void target()
{
  while(1)
  {
      wait(100, SC_NS);
      cout << sc_time_stamp(); // 100 360, 460
  }
}
----

这个例子中，target process的suspend和resume都是从另外一个线程calling发出的。
target线程每次都创建一个100ns延时的timed event，并等待此event的发生。

target中，第一个100ns的时候，target处于正常状态（20ns的suspend又在50ns的时候resume了），
所以target被正常调度执行，打印100，接下来又创建一个100ns的delay，准备在200ns的时候
唤醒此线程。然而，200ns的时候，设定的延时时间到达，事件发生，事件调用trigger_dynamic，将
动态阻塞在这个事件上的线程trigger起来的时候，线程处于suspended状态（160ns开始被suspend）。
在 <<sc_process_b::trigger_dynamic, trigger_dynamic>>的实现中，我们可以看到
如下部分代码(在method/thread的trigger_static中也是这套逻辑)：

[source,cpp]
----
    if ( (m_state & ps_bit_suspended) )
    {
	m_state = m_state | ps_bit_ready_to_run;
    }
    else
    {
        simcontext()->push_runnable_method(this);
    }
----

如果线程状态m_state的suspended位被置位，那么如果线程满足调度条件，这里也只是将其标记为
ready to run，而不会真正放入runnable列表。

因此，在这个例子中，200ns时候的timed event只会将线程target标记为ready to run，然后返回。
在360ns的时候，target线程被resume。由于
<<concept::process::control::resume::thread, resume此线程>>的时候，
线程是ready to run的，因此线程被
立即放入runnable列表，执行的时候打印出360的结果。之后线程以360ns为开始，每隔100ns
打印一个时间戳，直到仿真结束。

从这个例子中，我们也可以看到，一个被suspend的process，仍然可以接受调度请求。
在suspend期间，如果process满足调度条件，那么就会被延迟到resume的时候才会被
调度执行。如果suspend期间不满足调度请求，那么resume的时候，继续之前的状态，
表现起来好像这段suspend期间从未存在过一样。

suspend-resume机制不太适合用于clock驱动的process，因为使用clock驱动的process
很那理解这种把suspend期间发生的事件推迟到resume时候的概念。suspend-resume
一般用来抽象调度器。

=== prepare_to_simulate中的状态判断
[[use::process::control::prepare_to_simulate]]

在<<concept::simulate::initialize, 初始化>>部分，我们介绍过，在仿真开始前的时刻，
simc会将所有没有设定dont_initialize的method/thread都放入runnable列表中。这个
说法并不是很准确，因为里边还涉及到一些process状态的判断，现在我们回过头来看一下这部分代码：

.src/sysc/kernel/sc_simcontext.h
[source,cpp]
----
    // make all method processes runnable

    for ( method_p = m_process_table->method_q_head();
	  method_p; method_p = method_p->next_exist() )
    {
	if ( ((method_p->m_state & sc_process_b::ps_bit_disabled) != 0) ||
	     method_p->dont_initialize() )
	{
	    if ( method_p->m_static_events.size() == 0 )
	    {
	        SC_REPORT_WARNING( SC_ID_DISABLE_WILL_ORPHAN_PROCESS_,
		                   method_p->name() );
	    }
	}
	else if ( (method_p->m_state & sc_process_b::ps_bit_suspended) == 0)
	{
            if ( !method_p->is_runnable() ) // already scheduled?
                push_runnable_method_front( method_p );
        }
	else
	{
	    method_p->m_state |= sc_process_b::ps_bit_ready_to_run;
	}
    }

    // make thread processes runnable
    // (cthread processes always have the dont_initialize flag set)

    for ( thread_p = m_process_table->thread_q_head();
	  thread_p; thread_p = thread_p->next_exist() )
    {
	if ( ((thread_p->m_state & sc_process_b::ps_bit_disabled) != 0) ||
	     thread_p->dont_initialize() )
	{
	    if ( thread_p->m_static_events.size() == 0 )
	    {
	        SC_REPORT_WARNING( SC_ID_DISABLE_WILL_ORPHAN_PROCESS_,
		                   thread_p->name() );
	    }
	}
	else if ( (thread_p->m_state & sc_process_b::ps_bit_suspended) == 0)
	{
            if ( !thread_p->is_runnable() ) // already scheduled?
                push_runnable_thread_front( thread_p );
        }
	else
	{
	    thread_p->m_state |= sc_process_b::ps_bit_ready_to_run;
	}
    }
----

这两段代码分别处理了所有的method和thread，处理method和thread的代码一致，我们以thread
为例来说明。

对于每个thread，如果在仿真开始前被disable掉了，或者设置dont_initialize(CThread天然
设置无需初始化)，那么就需要检查，必须存在静态敏感事件。这个和我们之前的分析是一致的。
如果在仿真开始之前线程没有被suspend掉了，这表明线程应当可以执行，放入runnable列表。最后
就是仿真开始之前线程已经被suspend了，由于理论上此时线程应该被执行一次，但是却被suspend，按照
suspend-resume的逻辑，需要标记其为ready to run，这样在resume的时候就可以执行起来了。

== Dynamic Process

动态的process，指的是在仿真开始之后（simulation阶段）创建出来的线程，这些线程一般使用
sc_

=== sc_spawn


[[func::sc_spawn]]
sc_spawn用以从给定的参数中生成一个SystemC级别的线程（可以是Method，也可以是Thread，但不会是
CThread）。以下是sc_spawn的实现代码：

.src/sysc/kernel/sc_spawn.h
[source,cpp]
----
template <typename T>
inline sc_process_handle sc_spawn( 
    T object, 
    const char* name_p = 0,
    const sc_spawn_options* opt_p = 0)
{
    sc_simcontext*      context_p;
    sc_spawn_object<T>* spawn_p;
    
    context_p = sc_get_curr_simcontext();
    spawn_p = new sc_spawn_object<T>(object); <1>
    if ( !opt_p || !opt_p->is_method() )
    {
            sc_process_handle thread_handle = context_p->create_thread_process( 
            name_p, true,
            SC_MAKE_FUNC_PTR(sc_spawn_object<T>,semantics), <2>
            spawn_p, opt_p 
        );
        return thread_handle;
    }
    else
    {
            sc_process_handle method_handle = context_p->create_method_process( 
            name_p, true,
            SC_MAKE_FUNC_PTR(sc_spawn_object<T>,semantics), <2>
            spawn_p, opt_p 
        );
        return method_handle;
    }
}
----
<1> 从类型T的对象object创建一个 `sc_spawn_object<T>` 对象
<2> 设置Method/Thread的启动函数为刚才创建对象 spawn_p的 `semantics` 成员函数

从这段代码可以看出，对于给定的对象 `object`，这里会新建一个类型为 `sc_spawn_object<T>`
的对象，设置Method/Thread启动函数为这个新建的对象的 `semantics`。以下是 `sc_spawn_object<>`
的定义：

.src/sysc/kernel/sc_spawn.h
[source,cpp]
----
template<typename T>
class sc_spawn_object : public sc_process_host {
  public:
    sc_spawn_object( T object) : m_object(object)
    {
    }

    virtual void semantics()
    {
        m_object();
    }

  protected:
    T                        m_object; <1>
};
----
<1> sc_spwan_object保存了对象的拷贝

所以我们能看到， `semantics` 成员函数实际上调用的是 `m_object()` ，这意味着
对象的类必须重载了 `operator()` 才可以。

在sc_spawn的时候，我们可以看到，创建method/thread时候的第二个参数被设置为true，这与
使用<<api::SC_THREAD, SC_THREAD>>创建Thread线程，使用<<api::SC_METHOD, SC_METHOD>>
创建Method线程时都不同（那两个都将第二个参数设置为false）。这实际上是free_host参数，表明
这个method/thread所依赖的对象是否是一个自由对象。如果是，那么在相应的sc_process_b
析构的时候，会调用delete删除此对象。这也是为何在sc_spawn中，只new不delete却不会内存
泄漏的原因：

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
sc_process_b::~sc_process_b()
{

    // REDIRECT ANY CHILDREN AS CHILDREN OF THE SIMULATION CONTEXT:

    orphan_child_objects();


    // DELETE SEMANTICS OBJECTS IF NEED BE:

    if ( m_free_host ) delete m_semantics_host_p; <1>
#   if !defined(SC_USE_MEMBER_FUNC_PTR) // Remove invocation object.
        delete m_semantics_method_p;
#   endif


    // REMOVE ANY STRUCTURES THAT MAY HAVE BEEN BUILT:

    delete m_last_report_p;
    delete m_name_gen_p;
    delete m_reset_event_p;
    delete m_resume_event_p;
    delete m_term_event_p;
    delete m_throw_helper_p;
    delete m_timeout_event_p;

}
----
<1> 如果设置free host，在相应的sc_process_b析构的时候，会帮忙删除new出来的对象

另一个值得观察的地方在于，sc_spawn创建Method/Thread的最后一个参数都不为空，而是可能
给出参数。这个参数就是 `sc_spawn_options` 指针。之所以如此，是因为sc_spawn创建
出来的method/thread，没有类似<<api::SC_THREAD, SC_THREAD>>和<<api::SC_METHOD, SC_METHOD>>
那样可以辅助设置静态敏感事件、设定是否需要初始化等操作。为了支持这些，sc_spawn允许
传入一个 `sc_spwan_options` 对象的指针，补上这些。

例如，在sc_thread_process的构造函数中，有这么一段代码：

.src/sysc/kernel/sc_thread_process.cpp
[source,cpp]
----
    if (opt_p) {
        m_dont_init = opt_p->m_dont_initialize;
        if ( opt_p->m_stack_size ) m_stack_size = opt_p->m_stack_size;

        // traverse event sensitivity list
        for (unsigned int i = 0; i < opt_p->m_sensitive_events.size(); i++) {
            sc_sensitive::make_static_sensitivity(
                this, *opt_p->m_sensitive_events[i]);
        }

        // traverse port base sensitivity list
        for ( unsigned int i = 0; i < opt_p->m_sensitive_port_bases.size(); i++)
        {
            sc_sensitive::make_static_sensitivity(
                this, *opt_p->m_sensitive_port_bases[i]);
        }

        // traverse interface sensitivity list
        for ( unsigned int i = 0; i < opt_p->m_sensitive_interfaces.size(); i++)
        {
            sc_sensitive::make_static_sensitivity(
                this, *opt_p->m_sensitive_interfaces[i]);
        }

        // traverse event finder sensitivity list
        for ( unsigned int i = 0; i < opt_p->m_sensitive_event_finders.size();
            i++)
        {
            sc_sensitive::make_static_sensitivity(
                this, *opt_p->m_sensitive_event_finders[i]);
        }

        // process any reset signal specification:

	opt_p->specify_resets();

    }

    else
    {
        m_dont_init = false;
    }
----

这里在 `opt_p` 非空，即外界传入一个有效的 `sc_spawn_options` 指针的时候，使用这个
对象里的选项来初始化sc_thread_process的内容。sc_method_process的构造函数有着一样
的实现。

[[usage::sc_spawn::sc_clock]]
举个sc_spawn使用的例子。在sc_clock的before_end_of_elaboration中，
sc_clock就是用sc_spawn，创造出两个
METHOD，分别用来实现上升沿事件和下降沿事件：

.src/sysc/communication/sc_clock.cpp
[source,cpp]
----
void sc_clock::before_end_of_elaboration()
{
    std::string gen_base;
    sc_spawn_options posedge_options;	// Options for posedge process.
    sc_spawn_options negedge_options;	// Options for negedge process.

    posedge_options.spawn_method();
    posedge_options.dont_initialize();
    posedge_options.set_sensitivity(&m_next_posedge_event);
    gen_base = basename();
    gen_base += "_posedge_action";
    sc_spawn(sc_clock_posedge_callback(this),
	sc_gen_unique_name( gen_base.c_str() ), &posedge_options);

    negedge_options.spawn_method();
    negedge_options.dont_initialize();
    negedge_options.set_sensitivity(&m_next_negedge_event);
    gen_base = basename();
    gen_base += "_negedge_action";
    sc_spawn( sc_clock_negedge_callback(this),
    	sc_gen_unique_name( gen_base.c_str() ), &negedge_options );
}
----

这里sc_clock需要用 sc_spawn_options，指定：

* 创造出来的是Method，而不是Thread(如果不指定，则默认创造Thread)
* 无需初始化
* 设置两个Method的静态敏感事件列表

sc_spawn设置的两个Method，宿主是 `sc_clock_posedge_callback(this)` 和
`sc_clock_negedge_callback(this)` 。两个都是临时对象，这不会带来问题，因为
在 `sc_spawn_object<T>` 构造的时候，对象是**拷贝**而不是引用进来的。两个Method
的函数体就是 `sc_clock_posedge_callback(this)` 和 `sc_clock_negedge_callback(this)`
的 `operator()` :

.src/sysc/communication/sc_clock.h
[source,cpp]
----

class SC_API sc_clock_posedge_callback {
public:
    sc_clock_posedge_callback(sc_clock* target_p) : m_target_p(target_p) {}
    inline void operator () () { m_target_p->posedge_action(); }
  protected:
    sc_clock* m_target_p;
};

class SC_API sc_clock_negedge_callback {
  public:
    sc_clock_negedge_callback(sc_clock* target_p) : m_target_p(target_p) {}
    inline void operator () () { m_target_p->negedge_action(); }
  protected:
    sc_clock* m_target_p;
};
----

所以实际上，当 `sc_clock` 的 m_next_posedge_event发生的时候，调用的是自己的 `posedge_action`
函数。当 m_next_negedge_event发生的时候，调用的是自己的 `negedge_action` 函数。
这也是这两个辅助类名字里的 `callback` 含义所在。

.src/sysc/communication/sc_clock.h
[source,cpp]
----
inline
void
sc_clock::posedge_action()
{
    m_next_negedge_event.notify_internal( m_negedge_time );
	m_new_val = true;
	request_update(); <1>
}

inline
void
sc_clock::negedge_action()
{
    m_next_posedge_event.notify_internal( m_posedge_time );
	m_new_val = false;
	request_update(); <1>
}
----
<1> sc_clock继承自sc_signal，需要调用 `request_update` 在UPDATE PHASE更新值

在 `posedge_action` 中，设置了延时 `m_negedge_time` 后，`m_next_negedge_event`
发生。同样，在 `negedge_action` 中，设置了延时 `m_posedge_time` 后， `m_next_posedge_event`
发生。如此，只要 m_next_posedge_event和m_next_negedge_event中有一个事件发生，sc_clock
就可以自我驱动下去，实现了时钟的功能。

m_next_posedge_event和m_next_negedge_event谁先发生，取决于sc_clock初始化的时候
的设置。这是概念上，一个clock时钟初始时是0还是1的区别：初始为0，那么先发生上升沿事件，初始为1
则先发生下降沿事件。例如，在sc_clock的某个构造函数中，有这么一段：

.src/sysc/communication/sc_clock.h
[source,cpp]
----
    init( sc_time( period_v_, period_tu_, simcontext() ),
	  duty_cycle_,
	  sc_time( start_time_v_, start_time_tu_, simcontext() ),
	  posedge_first_ );

    if( posedge_first_ ) {
	// posedge first
	m_next_posedge_event.notify_internal( m_start_time );
    } else {
	// negedge first
	m_next_negedge_event.notify_internal( m_start_time );
    }
----

先用 `init` 成员函数初始化值。接下来，如果要求现有上升沿，就让事件m_next_posedge_event
发生，否则就先让 m_next_negedge_event发生。可以想象，在init中，也是根据是否先要上升沿
决定当前值的：如果现有上升沿，初始值为0，否则为1：

[source,cpp]
----
    if( posedge_first_ ) {
	this->m_cur_val = false;
	this->m_new_val = false;
    } else {
	this->m_cur_val = true;
	this->m_new_val = true;
    }
----

sc_clock虽然只是一个sc_signal，但是借助sc_spawn，获得了类似于sc_module
这样的能够创建单独线程的能力，这就实现了sc_clock的自激励特性。

=== sc_bind, sc_ref和sc_cref
[[func::sc-bind]]
[[func::sc_ref]]
[[func::sc_cref]]

为支持动态process功能，SystemC内置了如下3个辅助函数：

* sc_bind
* sc_ref
* sc_cref

.src/sysc/kernel/sc_dynamic_processes.h
[source,cpp]
----
namespace sc_unnamed {
using namespace std::placeholders;
} // namespace sc_unnamed

namespace sc_core {

template<typename F, typename... Args>
auto sc_bind( F&& f, Args&&... args )
#  if SC_CPLUSPLUS < 201402L // explicit return type needed before C++14
   -> decltype( std::bind(std::forward<F>(f), std::forward<Args>(args)...) )
#  endif
 { return std::bind( std::forward<F>(f), std::forward<Args>(args)... ); }

template<typename T>
auto sc_ref( T&& v )
#  if SC_CPLUSPLUS < 201402L // explicit return type needed before C++14
   -> decltype( std::ref(std::forward<T>(v) ) )
#  endif
 { return std::ref( std::forward<T>(v) ); }

template<typename T>
auto sc_cref( T&& v )
#  if SC_CPLUSPLUS < 201402L // explicit return type needed before C++14
   -> decltype( std::cref(std::forward<T>(v) ) )
#  endif
 { return std::cref( std::forward<T>(v) ); }

} // namespace sc_core
----

从代码实现来看，对于支持C++11的编译器而言，这三个其实就是 `std::bind`， `std::ref`
和 `std::cref` 的别名而已。

sc_bind(可以认为就是std::bind)返回的是一个functor，天然重载了 `operator()` ，无需
显式重载 `operator()` 。