:source-highlighter: coderay


= SystemC中的其他组件和用例分析
[[chap::misc]]
:toc: left

== sc_interface
[[data::sc_interface]]

((sc_interface))是一个抽象基类，提供了带interface能力类的接口信息。

 DEFINITION: A SystemC interface is an abstract class that inherits from sc_interface and provides only pure virtual declarations of methods referenced by SystemC channels and ports. No implementations or data are provided in a SystemC interface.
 -- <<SystemC: from ground up>>

sc_interface提供的接口包括：

* `register_port` 将port注册到本interface内
* `default_event` 返回本interface相关的默认事件引用，当敏感信息设置为一个sc_interface类，而不是
直接的sc_event的时候，调用的就是 `default_event` 返回一个事件引用，作为敏感源事件使用

.src/sysc/kernel/sc_sensitive.cpp
[source,cpp]
----
sc_sensitive&
sc_sensitive::operator << ( const sc_interface& interface_ )
{
    // check
    if( sc_is_running() ) {
	SC_REPORT_ERROR( SC_ID_MAKE_SENSITIVE_, "simulation running" );
    }

    // make sensitive
    switch( m_mode ) {
    case SC_METHOD_:
    case SC_THREAD_: {
	m_handle->add_static_event( interface_.default_event() ); <1>
	break;
    }
    case SC_NONE_:
        /* do nothing */
        break;
    }

    return *this;
}
----
<1> 使用sc_interface作为敏感源，其本质就是要使用sc_interface的默认事件作为敏感事件

sc_interface的完整定义如下：

.src/sysc/communication/sc_interface.h
[source,cpp]
----
class SC_API sc_interface
{
public:

    // register a port with this interface (does nothing by default)
    virtual void register_port( sc_port_base& port_,
				const char*    if_typename_ );

    // get the default event
    virtual const sc_event& default_event() const;

    // destructor (does nothing)
    virtual ~sc_interface();

protected:

    // constructor (does nothing)
    sc_interface();

private:

    // disabled
    sc_interface( const sc_interface& );
    sc_interface& operator = ( const sc_interface& );
};
----

sc_interface的两个虚函数的实现如下：

.src/sysc/communication/sc_interface.cpp
[source,cpp]
----
void
sc_interface::register_port( sc_port_base&, const char* )
{}


// get the default event

const sc_event&
sc_interface::default_event() const
{
    SC_REPORT_WARNING( SC_ID_NO_DEFAULT_EVENT_, 0 );
    return sc_event::none;
}
----

从这里也可以看出，register_port函数可以直接使用，但实现为空。与之相对应，default_event
则必须由派生类自行实现，否则会报出warning。当然，如果interface不需要返回event的话，
派生类不重新实现default_event也是允许的。


sc_interface的概念非常重要，是连接sc_fifo/sc_signal等primitive channel和sc_port/sc_export接口的重要桥梁。
简单来说，sc_port/sc_export的模板参数必须是一个sc_interface类，或者继承sc_interface的派生类。而在
sc_port/sc_export中，也只保存指向这些sc_interface或者sc_interface子类的指针。sc_port/sc_export
表现为指向primitive channel的指针，但本质上表象的更多的像是指向sc_interface或子类的指针，只使用
这些sc_interface或者子类提供的接口函数。而primitive channel则需要继承sc_interface或者子类，并
实现这些具体的接口函数。这样一来，从概念上，sc_port/sc_export就可以调用pirmitive channel的
接口函数了。

== sc_clock是如何工作的

((sc_clock))是一个sc_signal<bool, SC_ONE_WRITER>的继承类，sc_signal<bool, SC_ONE_WRITER> 
实现了sc_signal_in_if<bool>接口定义的功能，因此sc_clock可以被sc_in<bool> 绑定：

.src/sysc/communication/sc_clock.h
[source,cpp]
----
class SC_API sc_clock
  : public sc_signal<bool,SC_ONE_WRITER>
----

sc_clock的工作主要分为3个stage：

1. 在sc_module构造的时候，作为准备绑定sc_clock（但还没有绑定sc_clock）的 sc_in<bool> 端口，如何将之设置为静态敏感源
2. 在hierarchy建立之后，仿真开始之前，如何resolve之前设置的静态敏感源，使之获取真正的event事件
3. 在仿真过程中，sc_clock是如何调度相关的process handle的

=== module构造时

在sc_module的构造函数中，SC_CTHREAD/SC_THREAD可以将sc_in<bool>变量clk的pos()/neg()设置为静态
敏感事件。然而，此时sc_in<bool> clk并没有绑定具体的sc_clock。所以，这里SystemC用一个
<<api::sc_event_finder, sc_event_finder>>来代替。

在SC_THREAD的情况下，`sensitive << clk.pos()` , `sc_in<bool> clk` 的pos()返回的并不是
一个具体的sc_event，而是一个sc_event_finder:

.src/sysc/communication/sc_signal_ports.h
[source,cpp]
----
    sc_event_finder& pos() const
    {
        return sc_event_finder::cached_create
                ( m_pos_finder_p, *this, &in_if_type::posedge_event );
    }
----

所以sensitive设置的参数是一个 `sc_event_finder`:

.src/sysc/kernel/sc_sensitive.cpp
[source,cpp]
----
sc_sensitive&
sc_sensitive::operator << ( sc_event_finder& event_finder_ )
{
    // check
    if( sc_is_running() ) {
	SC_REPORT_ERROR( SC_ID_MAKE_SENSITIVE_, "simulation running" );
    }

    // make sensitive
    switch( m_mode ) {
    case SC_METHOD_: {
	event_finder_.port().make_sensitive( as_method_handle( m_handle ),
					     &event_finder_ );
	break;
    }
    case SC_THREAD_: {
	event_finder_.port().make_sensitive( as_thread_handle( m_handle ),
					     &event_finder_ );
	break;
    }
    case SC_NONE_:
        /* do nothing */
        break;
    }

    return *this;
}
----

这里调用了 `sc_port_base` 的 `make_sensitive` :

.src/sysc/communication/sc_port.cpp
[source,cpp]
----
void
sc_port_base::make_sensitive( sc_thread_handle handle_,
			      sc_event_finder* event_finder_ ) const
{
    sc_assert( m_bind_info != 0 );
    m_bind_info->thread_vec.push_back( 
	new sc_bind_ef( (sc_process_b*)handle_, event_finder_ ) );
}

void
sc_port_base::make_sensitive( sc_method_handle handle_,
			      sc_event_finder* event_finder_ ) const
{
    sc_assert( m_bind_info != 0 );
    m_bind_info->method_vec.push_back( 
	new sc_bind_ef( (sc_process_b*)handle_, event_finder_ ) );
}
----

sc_port_base的make_sensitive将sc_event_finder设置在sc_in<bool> clk这个sc_port的
bind_info中，这里放置着在bind_info的thread_vec数组里。

在SC_CTHREAD的情况下， `sensitive(clk.pos())` 调用的则是：

.src/sysc/kernel/sc_sensitive.cpp
[source,cpp]
----
sc_sensitive&
sc_sensitive::operator () ( sc_cthread_handle handle_,
			    sc_event_finder& event_finder_ )
{
    event_finder_.port().make_sensitive( handle_, &event_finder_ );
    return *this;
}
----

最终调用的也是讲sc_event_finder设置在sc_in<bool> clk中，效果和SC_THREAD时候一致。

module构造的结果是，在 `sc_in<bool> clk` 中，保存了相应的event finder函数，主要是一个
函数指针。因为module构造的时候，输入端口 `sc_in<bool> clk` 作为一个port还没有绑定
到最终的signal上，所以此时是无法决议给出最终的sc_event的。 `sc_in<bool> clk` 中
只能暂时先保存一个sc_event_finder，等待绑定完成后，使用所绑定的interface提供的指针，结合
保存的成员函数指针，调用得到真正的sc_event事件对象。

=== elaboration done时

在所有的hierarchy都初始化，并且port绑定到interface之后，sc_in<bool> clk即绑定到sc_clock
上。在elaboration_done阶段，sc_port_registry调用所有port的complete_binding函数，
这会调用sc_in<bool> clk的complete_binding函数。
这里event_finder主要保存的是sc_clock的成员函数指针 `posedge_event`:

.src/sysc/communication/sc_signal.cpp
[source,cpp]
----
template< sc_writer_policy POL >
const sc_event&
sc_signal<bool,POL>::posedge_event() const
{
    return *this->lazy_kernel_event(&m_posedge_event_p,"posedge_event");
}
----

这里返回的是新创建的一个sc_event变量m_posedge_event_p。其中，创建部分的逻辑是：

.src/sysc/communication/sc_signal.cpp
[source,cpp]
----
// create a (kernel) event, if needed
sc_event*
sc_signal_channel::lazy_kernel_event( sc_event** ev, const char* name ) const
{
    if ( !*ev ) {
        *ev = new sc_event( sc_event::kernel_event, name );
    }
    return *ev;
}
----

在sc_in<bool> clk的complete_binding函数中：

.src/sysc/communication/sc_port.cpp
[source,cpp]
----
        // complete static sensitivity for threads
        size = m_bind_info->thread_vec.size();
        for( int k = 0; k < size; ++ k ) {
            sc_bind_ef* p = m_bind_info->thread_vec[k];
            const sc_event& event = ( p->event_finder != 0 )
                                  ? p->event_finder->find_event(iface)
                                  : iface->default_event();
            p->handle->add_static_event( event );
        }
----

`iface` 指针就是 `sc_clock clock` 指针。所以这里的 `p->event_finder->find_event(iface)`
返回的结果是：

.src/sysc/communication/sc_event_finder.h
[source,cpp]
----
template <class IF>
inline
const sc_event&
sc_event_finder_t<IF>::find_event( sc_interface* if_p ) const
{
    const IF* iface = ( if_p ) ? dynamic_cast<const IF*>( if_p ) :
                                 dynamic_cast<const IF*>( port().get_interface() );
    if( iface == 0 ) {
        report_error( SC_ID_FIND_EVENT_, "port is not bound" );
        return sc_event::none;
    }
    return (const_cast<IF*>( iface )->*m_event_method) ();
}
----

传入的 `if_p` 指针是 `&clock`。这里首先通过dynamic_cast，将基类指针
转回到派生类指针，之所以需要派生类的指针，而不能使用基类指针，是因为
sc_event_finder需要支持那些不是sc_interface接口类定义的虚函数。
例如这里的 `posedge_event` 就是一个sc_interface基类没有定义的函数，但是在
派生类 `sc_clock` 中却定义了这个函数。cast回到派生类指针后，根据这个函数指针
和注册的成员函数指针，调用函数，获得需要的event事件对象。

这部分代码取得的 `event` 引用就是 `*m_posedge_event_p` 这个事件。调用
`p->handle->add_static_event(event)` 的结果则是：

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
//------------------------------------------------------------------------------
//"sc_process_b::add_static_event"
//
// This method adds an event to the list of static events, and sets the
// event up to call back this process when it fires.
//------------------------------------------------------------------------------
void sc_process_b::add_static_event( const sc_event& e )
{
    sc_method_handle method_h; // This process as a method.
    sc_thread_handle thread_h; // This process as a thread.


    // CHECK TO SEE IF WE ARE ALREADY REGISTERED WITH THE EVENT:

    for( int i = m_static_events.size() - 1; i >= 0; -- i ) {
        if( &e == m_static_events[i] ) {
            return;
        }
    }

    // REMEMBER THE EVENT AND THEN REGISTER OUR OBJECT INSTANCE WITH IT:

    m_static_events.push_back( &e );

    switch ( m_process_kind )
    {
      case SC_THREAD_PROC_:
      case SC_CTHREAD_PROC_:
        thread_h = static_cast<sc_thread_handle>( this );
        e.add_static( thread_h );
        break;
      case SC_METHOD_PROC_:
        method_h = static_cast<sc_method_handle>( this );
        e.add_static( method_h );
        break;
      default:
        sc_assert( false );
        break;
    }
}
----

将这个事件加入到handle自己的 `m_static_events` 数组中，同时调用事件 `*m_posedge_event_p`
本身的 `add_static` 函数：

.src/sysc/kernel/sc_process.cpp
[source,cpp]
----
inline
void
sc_event::add_static( sc_thread_handle thread_h ) const
{
    m_threads_static.push_back( thread_h );
}
----

将process handle注册到了 `*m_posedge_event_p` 保存的m_thread_static列表中。

elaboration done阶段的结果则是，对于 `sc_clock clock`，其内部的 `*m_posedge_event_p`
保存了所有静态设置时对其sensitive的SC_THREAD/SC_CTHREAD的process handle，同时这些
process handle内部也保存了 `*m_posedge_event_p` 的指针。

=== 仿真过程中

在运行中，由于sc_clock的<<usage::sc_spawn::sc_clock, 自激励>>，在UPDATE PHASE，根据
primitive channel的framework, `*m_posedge_event_p` 的成员函数 `update` 函数被调用：

.src/sysc/communication/sc_signal.cpp
[source,cpp]
----
template< sc_writer_policy POL >
void
sc_signal<bool,POL>::update()
{
    policy_type::update();
    if( !( base_type::m_new_val == base_type::m_cur_val ) ) {
        do_update();
    }
}

template< sc_writer_policy POL >
void
sc_signal<bool,POL>::do_update()
{
    // order of execution below is important, the notify_processes() call
    // must come after the update of m_cur_val for things to work properly!
    base_type::do_update();
    if ( m_reset_p ) m_reset_p->notify_processes();

    sc_event* event_p = this->m_cur_val ? m_posedge_event_p : m_negedge_event_p;
    sc_signal_channel::notify_next_delta( event_p );
}
----

这又调用了do_update成员函数。在do_update函数中，除了调用基类的do_update函数外，最为重要的
是 `sc_signal_channel::notify_next_delta(event_p)`。对于发生posedge信号而言：

.src/sysc/communication/sc_signal.h
[source,cpp]
----
    void notify_next_delta( sc_event* ev ) const
        { if( ev ) ev->notify_next_delta(); }
----

这等同在UPDATE PHASE调用 `m_posedge_event_p` 的notify_next_delta函数:

.src/sysc/kernel/sc_event.h
[source,cpp]
----
inline
void
sc_event::notify_next_delta()
{
    if( m_notify_type != NONE ) {
        SC_REPORT_ERROR( SC_ID_NOTIFY_DELAYED_, 0 );
    }
    // add this event to the delta events set
    m_delta_event_index = m_simc->add_delta_event( this );
    m_notify_type = DELTA;
}
----

这里主要是将notify type设置为DELTA，同时将这个事件，也就是 `*m_posedge_event_p`
放入simc的delta event列表中。这样一来，在NOTIFICATION PHASE，所有被注册到
simc delta event列表中的事件都会调度其trigger函数，从而调度process handle的trigger_static
函数，将这个process handle放入下一个delta cycle的runnable列表中。

至此，sc_clock的pos()完成了将所有对这个事件敏感的process handle的调度工作。

== sc_phase_callback_registry
[[data::sc_phase_callback_registry]]

((sc_phase_callback_registry))是SystemC在仿真器内部使用的一个维护
callback机制的类，这个类没有继承自其他类：

.src/sysc/kernel/sc_phase_callback_registry.h
[source,cpp]
----
class sc_phase_callback_registry
{
public:
    typedef sc_phase_callback_registry this_type;
    typedef sc_object                  cb_type;
    typedef cb_type::phase_cb_mask     mask_type;

    struct entry
    {
        cb_type*  target;
        mask_type mask;
    };

    // blabla

private:
    typedef std::vector<entry>    storage_type;
    typedef std::vector<cb_type*> single_storage_type;

#if SC_HAS_PHASE_CALLBACKS_

    // set and restore simulation status
    struct scoped_status
    {
        scoped_status( sc_status& ref, sc_status s )
          : ref_(ref), prev_(ref) { ref_ = s;}
        ~scoped_status() { ref_ = prev_; }
    private:
        sc_status& ref_;
        sc_status  prev_;
    }; // scoped_status

    mask_type validate_mask( cb_type&, mask_type, bool warn );

private:

    sc_simcontext*        m_simc;
    storage_type          m_cb_vec;            // all callbacks
#if 0
    single_storage_type   m_cb_eval_vec;     //  - eval cb shortcut
#endif
    single_storage_type   m_cb_update_vec;   //  - update cb shortcut
    single_storage_type   m_cb_timestep_vec; //  - timestep cb shortcut

#endif // SC_HAS_PHASE_CALLBACKS_

private:
    // disabled
    sc_phase_callback_registry( const this_type& );
    this_type& operator=(const this_type&);

}; // sc_phase_callback_registry
----

主要的成员函数包括，一个指向sc_simcontext内核的指针 `m_simc`，一个用来保存
所有callback的vector `m_cb_vec`，以及两个single_storage_type
类型的成员变量 `m_cb_update_vec` 和 `m_cb_timestep_vec`。

其中，cb_type就是sc_object，而mask_type则是：

.src/sysc/kernel/sc_object.h
[source,cpp]
----
    typedef unsigned phase_cb_mask;
----

即mask_type就是一个unsigned integer。entry类型就是保存了一对sc_object指针和unsigned integer
的mask的类型。

=== callbacks

sc_phase_callback_registry定义了很多类型的callback回调函数：

.src/sysc/kernel/sc_phase_callback_registry.h
[source,cpp]
----
    // --- callback forwarders

    bool construction_done()   const; //< returns false
    void elaboration_done()    const;
    void initialization_done() const;
    void start_simulation()    const;

    void evaluation_done()     const;
    void update_done()         const;
    void before_timestep()     const;

    void simulation_paused()   const;
    void simulation_stopped()  const;
    void simulation_done()     const;
----

这些回调函数的在仿真流程中的具体位置，请参考
<<concept::systemc_flow, SystemC仿真流程>>部分的介绍。

这些函数本身的实现都是调用了另一个核心的do_callback函数：

.src/sysc/kernel/sc_phase_callback_registry.h
[source,cpp]
----
nline bool
sc_phase_callback_registry::construction_done() const
{
#if SC_HAS_PHASE_CALLBACKS_
    do_callback( SC_BEFORE_END_OF_ELABORATION );
#endif
    return false;
}

inline void
sc_phase_callback_registry::elaboration_done() const
{
#if SC_HAS_PHASE_CALLBACKS_
    do_callback( SC_END_OF_ELABORATION );
#endif
}

inline void
sc_phase_callback_registry::start_simulation() const
{
#if SC_HAS_PHASE_CALLBACKS_
    do_callback( SC_START_OF_SIMULATION );
#endif
}

inline void
sc_phase_callback_registry::initialization_done() const
{
#if SC_HAS_PHASE_CALLBACKS_
    scoped_status scope( m_simc->m_simulation_status
                       , SC_END_OF_INITIALIZATION );

    do_callback( SC_END_OF_INITIALIZATION );
#endif
}

inline void
sc_phase_callback_registry::simulation_paused() const
{
#if SC_HAS_PHASE_CALLBACKS_
    do_callback( SC_PAUSED );
#endif
}

inline void
sc_phase_callback_registry::simulation_stopped() const
{
#if SC_HAS_PHASE_CALLBACKS_
    do_callback( SC_STOPPED );
#endif
}

inline void
sc_phase_callback_registry::simulation_done() const
{
#if SC_HAS_PHASE_CALLBACKS_
    do_callback( SC_END_OF_SIMULATION );
#endif
}
----

[[data::sc_status]]
可以看出，虽然((sc_status))定义了很多仿真的阶段，但其中，只有这7种才有相应的回调函数可供执行：

.src/sysc/kernel/sc_status.h
[source,cpp]
----
enum sc_status
{   // sc_get_status values:
    SC_UNITIALIZED=0x00,                 // initialize() not called yet

    SC_ELABORATION               = 0x01, // during module hierarchy construction
    SC_BEFORE_END_OF_ELABORATION = 0x02, // during before_end_of_elaboration()
    SC_END_OF_ELABORATION        = 0x04, // during end_of_elaboration()
    SC_START_OF_SIMULATION       = 0x08, // during start_of_simulation()

    SC_RUNNING                   = 0x10, // initialization, evaluation or update
    SC_PAUSED                    = 0x20, // when scheduler stopped by sc_pause()
    SC_STOPPED                   = 0x40, // when scheduler stopped by sc_stop()
    SC_END_OF_SIMULATION         = 0x80, // during end_of_simulation()

    // detailed simulation phases (for dynamic callbacks)
    SC_END_OF_INITIALIZATION     = 0x100, // after initialization
//    SC_END_OF_EVALUATION         = 0x200, // between eval and update
    SC_END_OF_UPDATE             = 0x400, // after update/notify phase
    SC_BEFORE_TIMESTEP           = 0x800, // before next time step

    SC_STATUS_LAST               = SC_BEFORE_TIMESTEP,
    SC_STATUS_ANY                = 0xdff
};
----

<<data::sc_phase_callback_registry::evaluation_done, evaluation_done>>
, <<data::sc_phase_callback_registry::update_done, update_done>>
以及<<data::sc_phase_callback_registry::before_timestep, before_timestep>>
并不是直接调用do_callback实现的，我们
在后续介绍。

=== do_callback
[[data::sc_phase_callback_registry::do_callback]]

do_callback是实现回调的核心部分：

.src/sysc/kernel/sc_phase_callback_registry.cpp
[source,cpp]
----
// generic implementation (for non-critical callbacks)
//  - also restores hierarchy around callback object
void
sc_phase_callback_registry::do_callback( sc_status s ) const
{
    typedef storage_type::const_iterator it_type;
    storage_type const & vec = m_cb_vec;

    for(it_type it = vec.begin(), end = vec.end(); it != end; ++it) {
        if( s & it->mask ) {
            sc_object::hierarchy_scope scope(it->target);
            it->target->do_simulation_phase_callback();
        }
    }
}
----

从代码实现中可以看出，do_callback会遍历 m_cb_vec，对于取出来的每一个sc_object指针和mask，首先
将需要回调的mask与上，如果与的结果不为0，即相应的mask置位，那么就先调用
hierarchy_scope，然后调用这个sc_object的do_simulation_phase_callback方法。

而sc_object的do_simulation_phase_callback实现则是：

.src/sysc/kernel/sc_object_int.h
[source,cpp]
----
inline void
sc_object::do_simulation_phase_callback()
{
    simulation_phase_callback();
}
----

simulation_phase_callback函数是sc_object的一个虚函数，sc_object自己的
是现实打印一个warning，实际上什么都不做：

.src/sysc/kernel/sc_object.cpp
[source,cpp]
----
void
sc_object::simulation_phase_callback()
{
    SC_REPORT_WARNING( SC_ID_PHASE_CALLBACK_NOT_IMPLEMENTED_, name() );
}
----

可以看出，回调的时候，simulation_phase_callback并没有接受任何phase参数。这意味着如果
一个sc_object定义了多个phase的回调函数，那么无法直接从simulation_phase_callback的参数
中获取究竟是哪个phase触发了回调。这种场景下，sc_object可以用 `sc_get_status()` 标准
API，来获取当前的仿真器状态，从而确定目前出于何种状态。

目前的SystemC代码中，只有sc_trace_file_base override了simulation_phase_callback的
实现。

=== register_callback
[[api::sc_phase_callback_registry::register_callback]]

register_callback用来向sc_phase_callback_registry中注册一个回调：

.src/sysc/kernel/sc_phase_callback_registry.cpp
[source,cpp]
----
sc_phase_callback_registry::mask_type
sc_phase_callback_registry::register_callback( cb_type& cb, mask_type m )
{
    storage_type::iterator it =
      find_if( m_cb_vec.begin(), m_cb_vec.end(), entry_match(&cb) );

    m = validate_mask(cb, m, /* warn */ true );

    mask_type diff_mask = m;
    mask_type new_mask  = m;

    if( it != m_cb_vec.end() ) // update existing entry
    {
        // update masks
        new_mask   =  (*it).mask | m;
        diff_mask  = ~(*it).mask & m;
        (*it).mask = new_mask;
    }
    else // new entry
    {
        if( !m ) // empty, do nothing
            return SC_UNITIALIZED;

        entry new_entry = { &cb, new_mask };
        m_cb_vec.push_back( new_entry );
    }

    // add to callback shortcut sets
#if 0
    if( diff_mask & SC_END_OF_EVALUATION )
        m_cb_eval_vec.push_back( &cb );
#endif
    if( diff_mask & SC_END_OF_UPDATE )
        m_cb_update_vec.push_back( &cb );
    if( diff_mask & SC_BEFORE_TIMESTEP )
        m_cb_timestep_vec.push_back( &cb );

    return new_mask;
}
----

调用register_callback的时候，需要提供一个sc_object的引用，以及希望enable的回调
阶段的mask值，回调阶段的mask值属于<<data::sc_status, sc_status>>范围。

这里首先检查下m_cb_vec中是否已经存在对象的指针，如果有，那么只需要在原先基础上修改即可，如果没有，就需要
新建一个entry，放入进对象的指针，以及回调mask阶段。注意，mask在使用之前，需要经过validate_mask修改，防止
出现不希望的场景。

如果注册的对象希望在SC_END_OF_UPDATE阶段得到回调，则对象本身会同样被放入到m_cb_update_vec中。如果
注册的对象希望在SC_BEFORE_TIMESTEP阶段得到回调，那么对象本身同样也放入m_cb_timestep_vec中。

---

sc_phase_callback_registry的register_callback只在sc_object的
<<api::sc_object::register_simulation_phase_callback, register_simulation_phase_callback>>
中得到调用：

.src/sysc/kernel/sc_object.cpp
[source,cpp]
----
sc_object::phase_cb_mask
sc_object::register_simulation_phase_callback( phase_cb_mask mask )
{
    mask = simcontext()->m_phase_cb_registry
                       ->register_callback(*this, mask);
    return mask;
}
----

目前的SystemC中，也只有sc_trace_file_base会调用基类sc_object的这个函数，注册
特定阶段的回调函数了。

=== unregister_callback
[[api::sc_phase_callback_registry::unregister_callback]]

与register_callback相对应，sc_phase_callback_registry也提供了一个
unregister_callback的实现：

.src/sysc/kernel/sc_phase_callback_registry.cpp
[source,cpp]
----
sc_phase_callback_registry::mask_type
sc_phase_callback_registry::unregister_callback( cb_type& cb, mask_type m )
{
    storage_type::iterator it =
      find_if( m_cb_vec.begin(), m_cb_vec.end(), entry_match(&cb) );

    m = validate_mask(cb, m);

    mask_type diff_mask = m;
    mask_type new_mask  = m;

    if( it == m_cb_vec.end() ) { // not registered
        return SC_UNITIALIZED;
    }

    // update masks
    new_mask   = (*it).mask & ~m;
    diff_mask  = (*it).mask & m;
    (*it).mask = new_mask;

    if( !new_mask )
        m_cb_vec.erase(it);

    // drop from callback shortcut sets
#if 0
    if( diff_mask & SC_END_OF_EVALUATION )
        erase_remove( &m_cb_eval_vec, &cb );
#endif
    if( diff_mask & SC_END_OF_UPDATE )
        erase_remove( &m_cb_update_vec, &cb );
    if( diff_mask & SC_BEFORE_TIMESTEP )
        erase_remove( &m_cb_timestep_vec, &cb );

    return new_mask;
}
----

unregister_callback的实现与register_callback基本一致，同样
也只在<<api::sc_object::unregister_simulation_phase_callback, unregister_simulation_phase_callback>>
中使用。

=== update_done
[[data::sc_phase_callback_registry::update_done]]

在register_callback中，我们看到，如果注册了SC_UPDATE阶段回调，那么
对象会被放入到一个sc_cb_update_vec中，所以update_done的实现就无法
借助do_callback实现，而需要单独做了：

.src/sysc/kernel/sc_phase_callback_registry.cpp
[source,cpp]
----
inline void
sc_phase_callback_registry::update_done() const
{
#if SC_HAS_PHASE_CALLBACKS_

    if( !m_cb_update_vec.size() ) return;

    typedef single_storage_type::const_iterator it_type;
    single_storage_type const & vec = m_cb_update_vec;

    scoped_status scope( m_simc->m_simulation_status
                       , SC_END_OF_UPDATE );

    for(it_type it = vec.begin(), end = vec.end(); it != end; ++it)
        (*it)->do_simulation_phase_callback();
#endif
}
----

目前尚不清楚SystemC为何要单独处理update_done阶段，后续看到相关部分的文档再补充理由。

=== before_timestep
[[data::sc_phase_callback_registry::before_timestep]]

before_timestep的实现和update_done基本一样，也是需要特殊处理的：

.src/sysc/kernel/sc_phase_callback_registry.cpp
[source,cpp]
----
inline void
sc_phase_callback_registry::before_timestep() const
{
#if SC_HAS_PHASE_CALLBACKS_

    if( !m_cb_timestep_vec.size() ) return;

    typedef single_storage_type::const_iterator it_type;
    single_storage_type const & vec = m_cb_timestep_vec;

    scoped_status scope( m_simc->m_simulation_status
                       , SC_BEFORE_TIMESTEP );

    for(it_type it = vec.begin(), end = vec.end(); it != end; ++it)
        (*it)->do_simulation_phase_callback();
#endif
}
----

目前尚不清楚为何SystemC单独处理before_timestep，后续看到了设计缘由再补充。

=== evaluation_done
[[data::sc_phase_callback_registry::evaluation_done]]

目前看到的代码中，evaluate_done的实现被注释掉了，很奇怪。sc_simcontext实现
也将evaluate_done阶段的回调注释掉了。

== CALLBACK

=== module的callback
[[api::module::callback]]

sc_module为派生类提供了四个虚函数，派生类实现这些函数后，可以在合适的
时机做需要的事情：

1. `void before_end_of_elaboration(void)`
2. `void end_of_elaboration(void)`
3. `void start_of_simulation(void)`
4. `void end_of_simulation(void)`

所有的sc_module都被注册到sc_module_registry中，而sc_module_registry则在
<<concept::systemc_flow, 仿真流程>>中，会调用如下4个回调函数 footnote:[这四个回调函数不是虚函数，所以派生类无法通过重写的方式改变行为]

1. construction_done
2. elaboration_done
3. start_simulation
4. simulation_done

这些sc_module_registry会调用所有sc_module的同名函数：

.src/sysc/kernel/sc_module.cpp
[source,cpp]
----
// We push the sc_module instance onto the stack of open objects so 
// that any objects that are created in before_end_of_elaboration have
// the proper parent. After the call we pop the hierarchy.
void
sc_module::construction_done()
{
    hierarchy_scope scope(this);
    before_end_of_elaboration(); <1>
}

// We push the sc_module instance onto the stack of open objects so 
// that any objects that are created in end_of_elaboration have
// the proper parent. After the call we pop the hierarchy.
void
sc_module::elaboration_done( bool& error_ )
{
    if( ! m_end_module_called ) {
        std::stringstream msg;
        msg << "module '" << name() << "'";
        SC_REPORT_WARNING( SC_ID_END_MODULE_NOT_CALLED_, msg.str().c_str() );
        if( error_ ) {
            SC_REPORT_WARNING( SC_ID_HIER_NAME_INCORRECT_, 0 );
        }
        error_ = true;
    }
    hierarchy_scope scope(this);
    end_of_elaboration(); <2>
}

void
sc_module::start_simulation()
{
    hierarchy_scope scope(this);
    start_of_simulation(); <3>
}

void
sc_module::simulation_done()
{
    hierarchy_scope scope(this);
    end_of_simulation(); <4>
}
----
<1> before_end_of_elaboration会在construction_done快要结束的时候调用
<2> end_of_simulation会在elaboration_done最后调用
<3> start_of_simulation会在start_simulation最后调用
<4> end_of_simulation会在end_of_simulation最后调用

=== port的callback
[[api::port::callback]]

与sc_module一样，所有的sc_port的基类sc_port_base也提供了四个虚函数，可以用来
在特定的阶段完成工作：

1. `void before_end_of_elaboration(void)`
2. `void end_of_elaboration(void)`
3. `void start_of_simulation(void)`
4. `void end_of_simulation(void)`

这4个虚函数的实现机制和sc_module是一样的。所有的sc_port_base都被注册到sc_port_registry
中，而sc_port_registry则会在合适的时机调用包括construction_done, elaboration_done, 
start_simulation和simulation_done，进而调用所有的sc_port_base的同名函数。而sc_port_base
的这四个同名函数（不是虚函数）的实现如下：

.src/sysc/communication/sc_port.cpp
[source,cpp]
----
void
sc_port_base::construction_done()
{
    sc_module* parent = static_cast<sc_module*>( get_parent_object() );
    sc_object::hierarchy_scope scope( parent );
    before_end_of_elaboration(); <1>
}

void
sc_port_base::elaboration_done()
{
    sc_assert( m_bind_info != 0 && m_bind_info->complete );
    delete m_bind_info;
    m_bind_info = 0;

    sc_module* parent = static_cast<sc_module*>( get_parent_object() );
    sc_object::hierarchy_scope scope( parent );
    end_of_elaboration(); <2>
}

void
sc_port_base::start_simulation()
{
    sc_module* parent = static_cast<sc_module*>( get_parent_object() );
    sc_object::hierarchy_scope scope( parent );
    start_of_simulation(); <3>
}

void
sc_port_base::simulation_done()
{
    sc_module* parent = static_cast<sc_module*>( get_parent_object() );
    sc_object::hierarchy_scope scope( parent );
    end_of_simulation(); <4>
}
----
<1> before_end_of_elaboration会在construction_done快要结束的时候调用
<2> end_of_simulation会在elaboration_done最后调用
<3> start_of_simulation会在start_simulation最后调用
<4> end_of_simulation会在end_of_simulation最后调用

=== export的callback
[[api::export::callback]]

sc_export_base提供了4个虚函数，提供相应的定制能力：

1. `void before_end_of_elaboration(void)`
2. `void end_of_elaboration(void)`
3. `void start_of_simulation(void)`
4. `void end_of_simulation(void)`

这4个虚函数的实现机制和sc_module是一样的。所有的sc_export_base都被注册到sc_export_registry
中，而sc_export_registry则会在合适的时机调用包括construction_done, elaboration_done, 
start_simulation和simulation_done，进而调用所有的sc_export_base的同名函数。而sc_export_base
的这四个同名函数（不是虚函数）的实现如下：

.src/sysc/communication/sc_port.cpp
[source,cpp]
----
// called when construction is done

void
sc_export_base::construction_done()
{
    sc_module* parent = static_cast<sc_module*>( get_parent_object() );
    sc_object::hierarchy_scope scope( parent );
    before_end_of_elaboration(); <1>
}

// called when elaboration is done

void
sc_export_base::elaboration_done()
{
    if ( get_interface() == 0 )
    {
        report_error( SC_ID_COMPLETE_BINDING_, "export not bound" );
        // may continue, if suppressed
    }

    sc_module* parent = static_cast<sc_module*>( get_parent_object() );
    sc_object::hierarchy_scope scope( parent );
    end_of_elaboration(); <2>
}

// called before simulation starts

void
sc_export_base::start_simulation()
{
    sc_module* parent = static_cast<sc_module*>( get_parent_object() );
    sc_object::hierarchy_scope scope( parent );
    start_of_simulation(); <3>
}

// called after simulation ends

void
sc_export_base::simulation_done()
{
    sc_module* parent = static_cast<sc_module*>( get_parent_object() );
    sc_object::hierarchy_scope scope( parent );
    end_of_simulation(); <4>
}
----
<1> before_end_of_elaboration会在construction_done快要结束的时候调用
<2> end_of_simulation会在elaboration_done最后调用
<3> start_of_simulation会在start_simulation最后调用
<4> end_of_simulation会在end_of_simulation最后调用

=== primitive channel的callback
[[api::prim_channel::callback]]

sc_prim_channel提供了4个虚函数，供派生类重写以实现特定阶段的定制行为：

1. `void before_end_of_elaboration(void)`
2. `void end_of_elaboration(void)`
3. `void start_of_simulation(void)`
4. `void end_of_simulation(void)`

这4个虚函数的实现机制和sc_module是一样的。所有的sc_prim_channel都被注册到sc_prim_channel_registry
中，而sc_prim_channel_registry则会在合适的时机调用包括construction_done, elaboration_done, 
start_simulation和simulation_done，进而调用所有的sc_prim_channel的同名函数。而sc_export_base
的这四个同名函数（不是虚函数）的实现如下：

.src/sysc/communication/sc_prim_channel.cpp
[source,cpp]
----
// called when construction is done

void
sc_prim_channel::construction_done()
{
    sc_object::hierarchy_scope scope( get_parent_object() );
    before_end_of_elaboration(); <1>
}

// called when elaboration is done

void
sc_prim_channel::elaboration_done()
{
    sc_object::hierarchy_scope scope( get_parent_object() );
    end_of_elaboration(); <2>
}

// called before simulation begins

void
sc_prim_channel::start_simulation()
{
    sc_object::hierarchy_scope scope( get_parent_object() );
    start_of_simulation(); <3>
}

// called after simulation ends

void
sc_prim_channel::simulation_done()
{
    sc_object::hierarchy_scope scope( get_parent_object() );
    end_of_simulation(); <4>
}
----
<1> before_end_of_elaboration会在construction_done快要结束的时候调用
<2> end_of_simulation会在elaboration_done最后调用
<3> start_of_simulation会在start_simulation最后调用
<4> end_of_simulation会在end_of_simulation最后调用


=== Simulation Kernel PHASE CALLBACK机制
[[macro::SC_DO_PHASE_CALLBACK_]]

Phase Callback机制是SystemC在2.3.3开始，实验性质的一种特性。Phase Callback
允许用户注册特定阶段的回调函数，来实现非侵入式的场景下，定制SystemC代码的行为。

Phase Callback允许任何sc_object的继承类，为特定的phase注册回调函数。

在sc_simcontext中，在特定的时间点会调用这些回调函数。这些回调函数是通过
宏控制的 footnote:[因为目前只是实验性质的特性，等确保稳定后，就会移除宏的控制]：

.src/sysc/kernel/sc_simcontext.cpp
[source,cpp]
----
#if SC_HAS_PHASE_CALLBACKS_
#  define SC_DO_PHASE_CALLBACK_( Kind ) \
    m_phase_cb_registry->Kind()
#else
#  define SC_DO_PHASE_CALLBACK_( Kind ) \
    ((void)0) /* do nothing */
#endif
----

宏 SC_HAS_PHASE_CALLBACKS_ 在定义了宏 SC_HAS_PHASE_CALLBACKS_
的场景下，调用的是 `m_phase_cb_registry` 的同名成员函数，参考
<<data::sc_phase_callback_registry, sc_phase_callback_registry>>
部分的介绍。

目前sc_simcontext实现了如下几个<<data::sc_status, sc_status>>的回调：

* update_done
* simulation_paused
* construction_done
* elaboration_done
* start_simulation
* initialization_done
* before_timestep
* simulation_stopped
* simulation_done

对应了sc_phase_callback_registry所实现的同行函数。