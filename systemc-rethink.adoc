:source-highlighter: coderay


= SystemC: 重新审视
[[chap::rethink]]
:toc: left

== 引言

在开始TLM的代码学习之前，这里我们对Systemc再次审视一遍，汇总下SystemC其内在的设计组件
是如何组织，以及如何构成整个仿真体系的。

SystemC的主要构成方式有如下几个部分：

* sc内核调度器
* method和thread类型的线程构成的SystemC的基本执行单元
* primitive channel，以及由此派生的sc_fifo，sc_buffer等实用数据类型
* event
* sc_interface, sc_port和sc_export构成的层次化接口框架
* module

---

sc内核调度器，是SystemC中内建的一组单件实例，负责整个SystemC中构造和执行过程。sc内核
调度器并不只是sc_context单件实例而已，还包括了其他类型的单件，后者往往以registry结尾，
是sc中用来管理不同类型对象的注册表。例如，所有的primitive channel都被一个primitive 
channel registry管理，primitive channel的基类在构造的时候，就需要将自己注册到
registry中。sc内核调度器是实现SystemC功能的基石，包括如下几个单件实例：

* sc_context类型的单件实例，这个是主要的仿真器调度核心
* 管理所有module的sc_module_registry单件
* 管理所有primitive channel的sc_primitive_channel_registry单件
* 管理所有port的sc_port_registry单件
* 管理所有export的sc_export_registry单件

注意，event并没有一个sc_event_registry，所有的event是被注册到object manager中，进行管理的。
之所以所有的port和export都需要一个注册表来管理，是为了能够在仿真开始之前检查所有的port/export
的绑定情况，避免出现未绑定而导致仿真的过程中出现错误。

在sc内核调度器中，一个<<concept::crunch, delta cycle>>的执行包括如下三个阶段：

1. EVALUATE，执行method和thread等线程
2. UPDATE，执行primitive channel的update
3. NOTIFICATION，执行基于event的更新

所以，在sc的内核调度中，只和线程, primitve channel以及event打交道，而并没有任何
sc_interface/sc_port/sc_export的位置。线程，primitive channel以及event，这就是
SystemC内核仿真最为重要的三个元素，分别对应了仿真时候的三个阶段。

[NOTE]
====

SystemC仿真三要素，就是这里的线程，primitive channel和event。这三要素中，线程和
event是不可或缺的，然而primitive channel却可以有别的方法代替。

在SC仿真三要素中，primitive channel起到的主要作用是隔离线程对数据的访问，使得本delta cycle
内，对一些数据的修改，直到下一个delta cycle才可以被其他线程观察到。这样一来，无论修改线程
和观察线程以什么样的调度顺序运行，修改线程的修改总是发生在UPDATE阶段，在所有的线程执行完毕之后
才生效。这样，就可以保证无论调度顺序如何，仿真总能得到一致的结果。

然而，对数据修改的隔离，使用其他的方式也能够办到。例如，要求修改数据的线程，和使用数据的线程，
不能再一个detal cycle内调度，也可以达到同样的目的。从这层意义上来说，只要能够提供约束，保证
修改线程和观察线程不在一个delta cycle内调度，那么实际上即使没有primitive channel，也能达到
同样的目的。这其实就是TLM 2.0的思想。在TLM 2.0中，所有的API函数调用都增加了一个延时时间的参数，
这个参数至少是SC_ZERO_TIME，这就保证了，调用方运行一个线程，修改数据，使用对应的API传输后，
被调用方至少隔一个delta cycle才能够做出响应，从而从机制上隔绝了两个线程在同一个delta cycle
内同时运行的可能。所以，在TLM 2.0中，无需任何primitive channel类型的数据，仅使用
线程和event就达到了目的。

事实上，对于纯粹基于TLM 2.0建模的模型而言，一次delta cycle内，只有EVALUATE和NOTIFICATION
两个阶段，因为UPDATE阶段没有任何需要更新的primitive channel子类了。基于TLM 2.0建模的模型，
其本质已经变成了接口的API函数，其调用和返回分配在不同的时间单位上进行了。例如一个b_transport
接口的调用发生在5ns，指定延时5ns，那么b_transport就被拆成了两部分，5ns的时候调用，以及
10ns时候的返回。相关的数据传输直接在调用和返回的时候完成了。

// 这里需要进一步的思考，TLM 2.0模型下，所有的接口函数的调用是如何在时间轴上分配的，以及
// 这种分配的仿真意义何在
// 是否有可能基于纯粹的TLM 2.0模型，不使用任何primitive channel，就完成的仿真模型？
// TLM 2.0看起来只是一个接口调用的方式，如果下游的b_transport不使用延时时间，照样可以
// 工作正常，这是因为函数的调用就足以保证顺序了，并且这实际上是在一个thread内，thread
// 和thread之间交换数据，是否还是必须有primitive channel的参与呢？

====

实际上，sc_interface/sc_port/sc_export
只是为了满足层次化的绑定需求，而设计出来的一套封装框架而已。从本质上而言，sc_interface
相当于虚指针，而sc_port则是持有一个或者一组虚指针的包装类而已。sc_export则是只能持有
一个虚指针的特殊的包装类。

虽然sc_interface, sc_port和sc_export并不是SystemC核心中的一部分，却是组织
TLM最重要的部分。所以我们在<<chap::interface_and_port_and_export, 再谈SystemC中的Interface, Port和Export>>
中，对这部分的内容进行了更为细致的考察和审视。

---

SystemC中的method和thread类型的线程，是SystemC中运行的基本组成单元。所谓的method类型的线程，
更本质的现象就是一个注册到sc内核的函数片段（准确的说，是成员函数和对象指针组成的一个可供调用执行
的代码片段）。所以method类型的线程无法提供阻塞的能力，其每一次执行都会从头开始，直到此函数片段
执行完毕为止。sc的内核调度在EVALUTE阶段，对于所需要执行的method线程，都是像调用一个个普通
函数一样，挨个执行的。注意，并非所有注册到sc内核的method线程在某次特定的delta cycle内都会
得到执行，只有那些在前一个delta cycle内，在NOTIFICATION phase中得到唤醒，被sc内核放入到待执行
列表中的method线程，才会在本delta cycle得到执行。

与之相对应，thread类型的线程则是实现了协程功能的代码片段。这些thread类型的线程一经执行，永不返回。
而在这些thread类型的线程执行过程中，可以显式或者隐式地调用wait，让渡出自己的执行权，给下一个待
执行的thread类型的线程。类似地，并非所有注册到sc内核的thread线程在某次delta cycle内都会得到执行，而
只有那些在上一个delta cycle的NOTIFICATION阶段，被放入到待执行列表中的thread，才会在本delta cycle的
EVALUATE阶段得到执行。在sc内核执行所有的thread类型的时候，sc内核只调用第一个thread类型，将执行权限
交给这个thread线程，这个thread线程执行到wait的时候，交给下一个，直到最后一个thread线程执行完毕，将
执行权交还给sc内核为止。所以，与method线程不同，thread线程在sc内核中的执行只会执行第一个thread线程，
然后等待其返回即可（如果不是很理解协程的概念，这一点可能难以理解）。

---

<<data::sc_event, event>>，这是另一个SystemC中非常核心的概念。SystemC中的event是一个final的类，
既不是一个模板类，也无需被继承实现。event是实现所有的method和thread类型的线程调度的基础。当init完成
之后，只有被event静态或者动态触发的method/thread线程，才会在NOTIFICATION阶段被sc内核放入待执行
列表，在下一个delta cycle内获得执行。如果一个method/thread类型的线程没有与之关联的event，那么这个
线程就是一个死的线程，因为它永远不会得到调度执行。

从本质上来讲，sc_event对象只是一个记录与之关联的method/thread线程指针的对象而已。当sc_event被触发
起来，这个sc_event就被sc内核收集起来，并在NOTIFICATION阶段，调用sc_event对象所提供的接口函数，通知
所有与之相关联的method/thread线程，检测是否满足线程设置的触发条件（在and list条件下，需要多个
event同时满足才能触发），如果满足那就将这些线程函数放入待执行队列，以在下一个delta cycle的EVALUATE阶段
执行这些线程。

除了用来作为delta cycle之间传递信息的对象之外，sc_event同样支持作为一个定时的对象出现。所谓的定时event，
只是对象约定从此刻开始，间隔一定时间之后，对象会自动触发。这里的自动触发，实际上是sc内核维护了一个定时
event的列表，按照这些定时event所设定时间的远近进行排序。在一批delta cycle结束，已经没有delta event存在的
时候，sc内核会从定时event中挑选一个离当前最近的event，触发此事件的发生，来进行下一轮的delta cycles。只有
定时event参与，仿真时间才会前进。如果只有delta event，没有定时event，那么仿真的时间是无法前进的。

sc_clock就是可以使用定时event的一个典型的例子。sc_clock提供了上升沿事件和下降沿事件，这两个事件本质上就是
定时事件，可以被周期性地触发。

---

primitive channel，是SystemC核心仿真的三种数据结构中，最为复杂的一种。primitive channel的复杂在于，
相比于线程的可执行性，以及event管理线程执行的能力，primitive channel有着自己的一套更新机制，以在
UPDATE阶段执行。这套更新机制还可以支持异步的更新。

primitive channel的这种更新机制设计的目的，是为了解决在仿真过程中，信号在thread中的传递过程。primitive channel
的值是可以在delta cycle内隔开读和写的。这种隔绝的效果，保证了读写不会发生条件竞争。例如，基于primitive channel
的fifo，如果一个线程写，另一个线程在同一个delta cycle读，那么如果没有了primitive channel的隔绝作用，读线程
可能在本delta cycle内就能获得写的数据，也可能无法获得，这就带来了条件竞争。如果是基于primitive channel
的signal，一个线程写，几个线程读，如若没有primitive channel的隔绝作用，读线程获取的值就完全取决于这些读线程
在建模的过程中，是在写线程之前还是之后执行了。

primitive channel的隔绝，主要是在一个delta cycle内，对所有的线程（无论是读还是写），都呈现一致的状态。这些
线程对primitive channel的更新，primitive channel内部会记录下来，但并不会反映到当前delta cycle内的线程
执行过程，而是直到delta时的UPDATE阶段，才更新所有注册了的primitive channel的状态，将本delta cycle的EVALUATE
阶段对这些primitive channel的更新全部应用进去。这些primitive channel
的更新可能导致事件的触发，进而导致下一个delta cycle的可执行线程变化，这正是我们所想要的。

在不同线程之间传递信息，最好总是使用primitive channel，这样可以避免因为调度顺序而带来的潜在bug。

== SystemC中的时间

这里我们考察下SystemC中的时间、时钟，以及由此引发开来的不同的编程模型的区别。

使用SystemC，可以设计如下几种编程模型：

* 时钟精确的模型，Approximate Timed, AT Model
* 松散时间的模型，Loose Timed, LT Model
* 无时间的模型，Untimed, UT Model

SystemC中的时间，是配合着event使用的。没有event与之关联的时间，是无法SystemC中使用的。

== Notification Phase Call back

对于派生自

<<api::module::callback, sc_module>>, 
<<api::port::callback, sc_port>>, 
<<api::export::callback, sc_export>>和
<<api::prim_channel::callback, sc_prim_channel>>的子类，可以实现以下几种
callback函数，这样SC在仿真的相应阶段，会调用这些函数：

* before_end_of_elaboration
* end_of_elaboration
* start_of_simulation
* end_of_simulation

这四个函数在对应的基类中都是虚函数(然而并不是纯虚函数)。派生类如果需要的话，可以override这些方法。

注意，这四个call-back函数并不是sc_object对象拥有的，所以只有sc_module, sc_port, sc_export和
sc_primitive_channel的派生类才可以override。

例如，在<<data::multi_passthrough_initiator_socket, multi_passthrough_initiator_socket>>中，使用了
了before_end_of_elaboration。而<<data::multi_passthrough_target_socket, multi_passthrough_target_socket>>
则使用了end_of_elaboration，来为仿真前的所有注册的binder设置callback函数。这样一来，从机制上就保证了
所有的multi_passthrough_initiator_socket注册一定发生在所有的
multi_passthrough_target_socket注册之前。